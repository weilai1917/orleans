{
  "Documentation/grains/event_sourcing/immediate_vs_delayed_confirmation.html": {
    "href": "Documentation/grains/event_sourcing/immediate_vs_delayed_confirmation.html",
    "title": "Immediate vs. Delayed Confirmation | Microsoft Orleans 中文文档",
    "keywords": "立即确认 对于许多应用程序，我们希望确保事件立即得到确认，以便持久化的版本不会落后于内存中的当前版本，并且我们不会冒丢失最新状态的风险(如果grain失败)。我们可以通过以下规则来保证： 在Grain方法返回之前，使用 ConfirmEvents 确认所有 RaiseEvent 调用。 在Grain方法返回之前确保由 RaiseConditionalEvent 返回的任务已完成。 避免 [Reentrant] 或 [AlwaysInterleave] 属性，因此一次只能处理一个grain调用。 如果我们遵循这些规则，则意味着在引发事件之后，在将事件写入存储器之前，不能执行其他Grain代码。因此，不可能观察到内存中的版本和存储中的版本之间的不一致。虽然这通常正是我们想要的，但它也有一些潜在的缺点。 潜在劣势 如果 与远程群集或存储的连接暂时中断 ，则grain变得不可用：实际上，grain在等待确认事件时无法执行任何代码，这可能需要无限长的时间(日志一致性协议一直在重试，直到恢复存储连接)。 处理时 对单个grain实例的大量更新 ，一次确认一个会变得非常低效，即吞吐量很低。 延迟确认 为了提高上述情况下的可用性和吞吐量，Grains可以选择执行以下一项或两项操作： 允许grain方法在不等待确认的情况下引发事件。 允许重入，这样即使以前的调用在等待确认时被阻塞，grain也可以继续处理新的调用。 这意味着当某些事件仍在确认过程中时，可以执行Grain代码。这个 日志记录 api有一些具体规定，让开发人员能够精确控制如何处理当前“正在运行”的未经确认的事件。 可以检查以下属性以了解当前未确认的事件： IEnumerable<EventType> UnconfirmedEvents { get; } 而且，由于 State 属性不包括未确认事件的影响，有一个可选属性 StateType TentativeState { get; } 它返回一个“暂定”状态，通过应用所有未确认的事件从“状态”获得。在所有未经证实的事件被证实后，暂时状态本质上是对下一个确认状态的“最佳猜测”。然而，并不能保证它真的会发生，因为Grains可能会失败，或者因为事件可能与其他事件竞争而失败，导致它们被取消(如果它们是有条件的)或者出现在序列中比预期的更晚的位置(如果它们是无条件的)。 并发保证 请注意，即使在使用Reentrant性或延迟确认的情况下，基于orleans turn的调度(协作并发)保证也始终适用。这意味着，即使有几个方法在进行中，也只有一个方法可以主动执行——所有其他的方法都处于等待状态，因此从来没有任何真正的竞争是由并行线程引起的。 尤其要注意： State , TentativeState , Version , 和 UnconfirmedEvents 属性可以在方法执行期间更改。 但这种变化只能在等待的时候发生。 这些保证假定用户代码保持在 推荐做法 关于任务和异步/等待(特别是，不使用线程池任务，或者只将它们用于不调用grain功能且等待正确的代码)。"
  },
  "Documentation/grains/event_sourcing/log_consistency_providers.html": {
    "href": "Documentation/grains/event_sourcing/log_consistency_providers.html",
    "title": "Log-Consistency Providers | Microsoft Orleans 中文文档",
    "keywords": "内置日志一致性提供程序 的 Microsoft.Orleans.EventSourcing 该软件包包括几个日志一致性提供程序，这些提供程序涵盖了适合入门的基本方案，并具有一定的可扩展性。 Orleans.EventSourcing. StateStorage .LogConsistencyProvide 该提供商存储 grains状态快照 ，使用可以独立配置的标准存储提供程序。 保留在存储中的数据是一个对象，它既包含Grain状态(由第一个type参数指定为 JournaledGrain )和一些元数据(版本号，以及用于避免存储访问失败时事件重复的特殊标记)。 由于每次访问存储时都会读取/写入整个grains状态，因此此提供程序不适用于grains状态非常大的对象。 该提供者不支持 RetrieveConfirmedEvents (检索已确认事件)：它不能从存储中检索事件，因为事件没有持久化。 Orleans.EventSourcing。 LogStorage .LogConsistencyProvider 该提供商存储 完整的事件序列作为单个对象 ，使用可以独立配置的标准存储提供程序。 保留在存储中的数据是一个包含以下内容的对象： List <EventType> object 以及一些元数据(一个特殊的标记，用于在存储访问失败时避免事件重复)。 该提供者确实支持 RetrieveConfirmedEvents . 所有事件始终可用并保存在内存中。 由于每次访问存储时都会读取/写入整个事件序列，因此此提供程序是 不适合在生产中使用 ，除非保证事件序列保持很短。此提供程序的主要目的是说明事件源的语义，以及用于示例/测试环境的语义。 Orleans.EventSourcing. CustomStorage .LogConsistencyProvider 此提供程序允许开发人员插入自己的存储接口，然后在适当的时间由conistency协议调用。这个提供程序不会对存储的内容是状态快照还是事件做出特定的假设—程序员可以控制这个选择(并且可以存储其中一个或两个)。 要使用此提供程序，必须从 JournaledGrain<StateType, EventType> ，但还必须实现以下接口： public interface ICustomStorageInterface<StateType, EventType> { Task<KeyValuePair<int,StateType>> ReadStateFromStorage(); Task<bool> ApplyUpdatesToStorage(IReadOnlyList<EventType> updates, int expectedversion); } 一致性提供程序希望它们以某种方式运行。程序员应该意识到： 第一种方法， ReadStateFromStorage ，应同时返回版本和状态read。如果尚未存储任何内容，则应为版本返回零，并返回与的默认构造函数相匹配的状态 状态类型 . ApplyUpdatesToStorage 如果预期版本与实际版本不匹配，则必须返回false(这类似于e-tag检查)。 如果 ApplyUpdatesToStorage 失败，但出现异常，一致性提供程序将重试。这意味着如果抛出这样的异常，某些事件可能会被复制，但事件实际上是持久化的。开发人员负责确保这是安全的：例如，要么通过不引发异常来避免这种情况，要么确保重复事件对应用程序逻辑无害，要么添加一些额外的机制来过滤重复项。 此提供程序不支持 RetrieveConfirmedEvents . 当然，由于开发人员无论如何都控制着存储接口，所以他们不需要首先调用这个接口，而是可以实现自己的事件检索。"
  },
  "Documentation/grains/event_sourcing/replicated_instances.html": {
    "href": "Documentation/grains/event_sourcing/replicated_instances.html",
    "title": "Replicated Grains | Microsoft Orleans 中文文档",
    "keywords": "多副本 Grains 有时，同一Grain的多个实例可能处于活动状态，例如在操作多集群时，使用 [OneInstancePerCluster] 属性。journaledgrain旨在以最小的影响支持多副本实例。它依赖于 日志一致性提供程序 运行必要的协议以确保所有实例同意相同的事件序列。特别要注意以下几个方面： 一致的版本 ：Grains状态的所有版本(临时版本除外)都基于相同的全局事件序列。特别是，如果两个实例看到相同的版本号，则它们看到相同的状态。 事件竞争 ：多个实例可以同时引发事件。一致性提供程序解决了这个竞争，并确保每个人都同意相同的顺序。 通知/反应性 ：在一个Grains实例上引发事件后，一致性提供程序不仅更新存储，还通知所有其他Grains实例。 有关一致性模型的一般讨论，请参见 技术报告 以及 GSP 论文 (全局序列协议)。 条件事件 如果事件竞争有冲突，也就是说，由于某种原因，不应该同时进行，那么事件竞争可能会有问题。例如，在从银行账户取款时，有两个实例可以独立地确定有足够的资金用于取款，并发出取款事件。但这两个事件的结合可能透支。为了避免这种情况，journaledgrain api支持 RaiseConditionalEvent 方法。 bool success = await RaiseConditionalEvent(new WithdrawalEvent() { ... }); 条件事件仔细检查本地版本是否与存储中的版本匹配。如果没有，则意味着事件序列同时增长，这意味着此事件已失去与其他事件的竞争。在这种情况下，条件事件是 不 附加到日志中，并且 RaiseConditionalEvent 返回false。 这类似于在条件存储更新中使用e-tags，并且同样提供了一种简单的机制来避免提交冲突事件。 对同一个Grain同时使用条件和无条件事件是可能和明智的，例如 DepositEvent 以及 WithdrawalEvent 。存款不需要有条件：即使 DepositEvent 如果竞争失败，则不必取消，但仍可以附加到全局事件序列中。 等待任务返回者 RaiseConditionalEvent 足以确认事件，即不必同时调用 ConfirmEvents 。 显式同步 有时，最好确保Grains完全赶上最新版本。这可以通过调用 await RefreshNow(); 其中(1)确认所有未确认事件，和(2)从存储中加载最新版本。"
  },
  "Documentation/grains/interceptors.html": {
    "href": "Documentation/grains/interceptors.html",
    "title": "Grain Call Filters | Microsoft Orleans 中文文档",
    "keywords": "Grains访问过滤器 Grains调用过滤器提供了一种拦截Grains调用的方法。筛选器可以在Grains调用之前和之后执行代码。可以同时安装多个过滤器。过滤器是异步的，可以修改 RequestContext ，参数和被调用方法的返回值。过滤器还可以检查 方法信息 可以在Grain类上调用的方法，可用于引发或处理异常。 Grain调用过滤器的一些示例用法是： 授权：过滤器可以检查正在调用的方法以及其中的参数或某些授权信息 RequestContext 确定是否允许呼叫继续进行。 记录/遥测：过滤器可以记录信息并捕获计时数据和有关方法调用的其他统计信息。 错误处理：过滤器可以拦截方法调用引发的异常，并将其转换为另一个异常，或者在通过过滤器时处理该异常。 过滤器有两种口味： 访问过滤 呼出调用过滤器 收到呼叫时，将执行传入呼叫过滤器。拨调用时执行呼出调用过滤器。 访问过滤 传入的Grain调用过滤器实现了 IIncomingGrainCallFilter 接口，它具有一种方法： public interface IIncomingGrainCallFilter { Task Invoke(IIncomingGrainCallContext context); } 的 IIncomingGrainCallContext 参数传递给 Invoke 方法具有以下形状： public interface IIncomingGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the interface method being invoked. /// </summary> MethodInfo InterfaceMethod { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the implementation method being invoked. /// </summary> MethodInfo ImplementationMethod { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } 的 IIncomingGrainCallFilter.Invoke(IIncomingGrainCallContext) 方法必须等待或返回的结果 IIncomingGrainCallContext.Invoke() 执行下一个配置的过滤器，最终执行grain方法本身。的 Result 可以在等待 Invoke() 方法。 ImplementationMethod 属性返回 MethodInfo 实现类。获取 MethodInfo 可以使用 InterfaceMethod 属性。对于所有对Grains的方法调用，都会调用Grains调用过滤器，其中包括对Grains扩展的调用( IGrain扩展 )安装在Grains中。例如，grains扩展用于实现流和取消令牌。因此，应该期望 ImplementationMethod 在Grains类本身中并不总是一种方法。 配置传入呼叫过滤器 的实现 IIncomingGrainCallFilter 可以通过Dependency Injection注册为silos级过滤器，也可以通过Grains实现将其注册为grains级过滤器 IIncomingGrainCallFilter 直。 silos范围内的所有访问过滤器 可以使用Dependency Injection将委托注册为silos级的Grain调用过滤器，如下所示： siloHostBuilder.AddIncomingGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.InterfaceMethod.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); 同样，可以使用 AddIncomingGrainCallFilter 辅助方法。这是一个grain调用过滤器的示例，它记录每个grain方法的结果： public class LoggingCallFilter : IIncomingGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IIncomingGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } 然后可以使用 AddIncomingGrainCallFilter 扩展方法： siloHostBuilder.AddIncomingGrainCallFilter<LoggingCallFilter>(); 或者，可以在不使用扩展方法的情况下注册过滤器： siloHostBuilder.ConfigureServices( services => services.AddSingleton<IIncomingGrainCallFilter, LoggingCallFilter>()); 每粒Grains调用过滤器 Grains类可以将自己注册为Grains调用过滤器，并可以通过实现对它的所有调用进行过滤 IIncomingGrainCallFilter 像这样： public class MyFilteredGrain : Grain, IMyFilteredGrain, IIncomingGrainCallFilter { public async Task Invoke(IIncomingGrainCallContext context) { await context.Invoke(); // Change the result of the call from 7 to 38. if (string.Equals(context.InterfaceMethod.Name, nameof(this.GetFavoriteNumber))) { context.Result = 38; } } public Task<int> GetFavoriteNumber() => Task.FromResult(7); } 在上面的示例中，对 GetFavoriteNumber 方法将返回 38 代替 7 ，因为返回值已被过滤器更改。 过滤器的另一个用例是在访问控制中，如以下示例所示： [AttributeUsage(AttributeTargets.Method)] public class AdminOnlyAttribute : Attribute { } public class MyAccessControlledGrain : Grain, IMyFilteredGrain, IIncomingGrainCallFilter { public Task Invoke(IIncomingGrainCallContext context) { // Check access conditions. var isAdminMethod = context.ImplementationMethod.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool) RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {context.ImplementationMethod.Name}!\"); } return context.Invoke(); } [AdminOnly] public Task<int> SpecialAdminOnlyOperation() => Task.FromResult(7); } 在以上示例中， SpecialAdminOnlyOperation 该方法只能在以下情况下调用 “ isAdmin” 设定为 真正 在里面 RequestContext 。这样，可以将Grains调用过滤器用于授权。在此示例中，呼叫者有责任确保 “ isAdmin” 值设置正确，并且验证正确执行。请注意 [仅管理员] 属性是在Grains类方法上指定的。这是因为 实现方法 属性返回 方法信息 的实现，而不是接口。过滤器还可以检查 接口方法 属性。 grains呼叫过滤器的订购 Grains调用过滤器遵循定义的顺序： IIncomingGrainCallFilter 在依赖项注入容器中配置的实现(按注册顺序)。 Grains级过滤器(如果使用Grains) IIncomingGrainCallFilter 。 grain方法实施或grain扩展方法实施。 每次调用 IIncomingGrainCallContext.Invoke() 封装下一个定义的过滤器，以便每个过滤器都有机会在链中下一个过滤器之前和之后执行代码，并最终执行grain方法本身。 呼出调用过滤器 传出Grains调用过滤器类似于传入Grains调用过滤器，主要区别在于它们是在调用者(客户端)而不是被调用者(grains)上调用的。 传出呼叫过滤器实现了 IOutgoingGrainCallFilter 接口，它具有一种方法： public interface IOutgoingGrainCallFilter { Task Invoke(IOutgoingGrainCallContext context); } 的 IOutgoingGrainCallContext 参数传递给 Invoke 方法具有以下形状： public interface IOutgoingGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the interface method being invoked. /// </summary> MethodInfo InterfaceMethod { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } 的 IOutgoingGrainCallFilter.Invoke(IOutgoingGrainCallContext) 方法必须等待或返回的结果 IOutgoingGrainCallContext.Invoke() 执行下一个配置的过滤器，最终执行grain方法本身。的 结果 可以在等待 调用() 方法。的 方法信息 可以使用 接口方法 属性。传出的Grains调用过滤器会针对所有对Grains的方法调用进行调用，其中包括对Orleans进行的系统方法的调用。 配置去电呼叫过滤器 的实现 IOutgoingGrainCallFilter 可以使用依赖注入在silos和客户端上注册。 可以将委托注册为呼叫过滤器，如下所示： builder.AddOutgoingGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.InterfaceMethod.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); 在上面的代码中， 建造者 可能是 ISiloHostBuilder 要么 IClientBuilder 。 同样，可以将一个类注册为传出的Grain调用过滤器。这是一个grain调用过滤器的示例，它记录每个grain方法的结果： public class LoggingCallFilter : IOutgoingGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IOutgoingGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } 然后可以使用 AddOutgoingGrainCallFilter 扩展方法： builder.AddOutgoingGrainCallFilter<LoggingCallFilter>(); 或者，可以在不使用扩展方法的情况下注册过滤器： builder.ConfigureServices( services => services.AddSingleton<IOutgoingGrainCallFilter, LoggingCallFilter>()); 与委托调用过滤器示例一样， 建造者 可能是以下任何一个的实例 ISiloHostBuiler 要么 IClientBuilder 。 用例 异常转换 当从服务器引发的异常在客户端上反序列化时，有时可能会收到以下异常，而不是实际的异常： TypeLoadException：找不到Whatever.dll。 如果包含异常的程序集对客户端不可用，则会发生这种情况。例如，假设您在grain实现中使用实体框架；那么有可能 EntityException 被抛出。另一方面，客户端不(也不应该)引用 EntityFramework.dll 因为它不了解基础数据访问层。 当客户端尝试反序列化 EntityException ，它将因缺少DLL而失败；结果是 TypeLoadException类型加载异常 把原来的东西藏起来了 实体异常 . 有人可能会说这很好，因为客户永远不会处理 实体异常 否则就得参考 EntityFramework.dll . 但是如果客户端希望至少记录异常呢？问题是原来的错误消息丢失了。解决此问题的一种方法是截获服务器端异常并用类型的纯异常替换它们 例外 如果异常类型可能在客户端未知。 然而，有一件重要的事我们必须牢记：我们只想替换一个例外 如果调用者是Grains客户 . 如果调用者是另一个grain(或者正在进行grain调用的Orleans基础设施；例如 GrainBasedReminderTable Grains)。 在服务器端，这可以通过silos级别的拦截器来实现： public class ExceptionConversionFilter : IIncomingGrainCallFilter { private static readonly HashSet<string> KnownExceptionTypeAssemblyNames = new HashSet<string> { typeof(string).Assembly.GetName().Name, \"System\", \"System.ComponentModel.Composition\", \"System.ComponentModel.DataAnnotations\", \"System.Configuration\", \"System.Core\", \"System.Data\", \"System.Data.DataSetExtensions\", \"System.Net.Http\", \"System.Numerics\", \"System.Runtime.Serialization\", \"System.Security\", \"System.Xml\", \"System.Xml.Linq\", \"MyCompany.Microservices.DataTransfer\", \"MyCompany.Microservices.Interfaces\", \"MyCompany.Microservices.ServiceLayer\" }; public async Task Invoke(IIncomingGrainCallContext context) { var isConversionEnabled = RequestContext.Get(\"IsExceptionConversionEnabled\") as bool? == true; if (!isConversionEnabled) { // If exception conversion is not enabled, execute the call without interference. await context.Invoke(); return; } RequestContext.Remove(\"IsExceptionConversionEnabled\"); try { await context.Invoke(); } catch (Exception exc) { var type = exc.GetType(); if (KnownExceptionTypeAssemblyNames.Contains(type.Assembly.GetName().Name)) { throw; } // Throw a base exception containing some exception details. throw new Exception( string.Format( \"Exception of non-public type '{0}' has been wrapped.\" + \" Original message: <<<<----{1}{2}{3}---->>>>\", type.FullName, Environment.NewLine, exc, Environment.NewLine)); } } } 然后可以在silos上注册此筛选器： siloHostBuilder.AddIncomingGrainCallFilter<ExceptionConversionFilter>(); 通过添加传出呼叫筛选器，为客户端发出的呼叫启用筛选器： clientBuilder.AddOutgoingGrainCallFilter(context => { RequestContext.Set(\"IsExceptionConversionEnabled\", true); return context.Invoke(); }); 这样，客户端就告诉服务器它要使用异常转换。 从拦截器呼叫Grains 通过注入，可以从拦截器发出grain调用 IGR工厂 进入拦截器类： private readonly IGrainFactory grainFactory; public CustomCallFilter(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Invoke(IIncomingGrainCallContext context) { // Hook calls to any grain other than ICustomFilterGrain implementations. // This avoids potential infinite recursion when calling OnReceivedCall() below. if (!(context.Grain is ICustomFilterGrain)) { var filterGrain = this.grainFactory.GetGrain<ICustomFilterGrain>(context.Grain.GetPrimaryKeyLong()); // Perform some grain call here. await filterGrain.OnReceivedCall(); } // Continue invoking the call on the target grain. await context.Invoke(); }"
  },
  "Documentation/grains/transactions.html": {
    "href": "Documentation/grains/transactions.html",
    "title": "标题：Orleans2.0中的交易 | Microsoft Orleans 中文文档",
    "keywords": "布局：页面 标题：Orleans2.0中的交易 Orleans交易 Orleans支持针对持久Grains状态的分布式ACID交易。 建立 Orleans选择加入交易。必须将silos配置为使用事务。如果不是，对Grains上的事务方法的任何调用都将收到一个 OrleansTransactionsDisabledException 。要在silos上启用交易，请调用 UseTransactions() 在silos主机构建器上。 var builder = new SiloHostBuilder().UseTransactions(); 交易状态存储 要使用事务，用户需要配置数据存储。为了支持带有事务的各种数据存储，存储抽象 ITransactionalStateStorage 已经介绍了。这种抽象是特定于交易需求的，与普通的Grains存储不同( IGrain存储 )。要使用特定于事务的存储，用户可以使用以下任何实现来配置其silos ITransactionalStateStorage ，例如Azure( AddAzureTableTransactionalStateStorage )。 例： var builder = new SiloHostBuilder() .AddAzureTableTransactionalStateStorage(\"TransactionStore\", options => { options.ConnectionString = ”YOUR_STORAGE_CONNECTION_STRING”); }) .UseTransactions(); 出于开发目的，如果特定事务的存储不适用于您需要的数据存储，则 IGrain存储 实现可以代替使用。对于任何未为其配置存储的事务状态，事务将尝试使用网桥故障转移到Grains存储。通过通往Grains存储的桥梁访问交易状态将效率较低，并且不是我们打算长期支持的模式，因此建议将其仅用于开发目的。 程式设计模型 grains接口 为了使Grains支持交易，必须使用“交易”属性将Grains接口上的交易方法标记为交易的一部分。该属性需求通过下面的事务选项指示在调用环境中grain调用的行为： TransactionOption.Create -调用是事务性的，即使在现有事务上下文中被调用，也总是会创建一个新的事务上下文(即它将启动一个新事务)。 TransactionOption.Join -调用是事务性的，但只能在现有事务的上下文中调用。 TransactionOption.CreateOrJoin -通话具有交易性。如果在事务上下文中调用，它将使用该上下文，否则它将创建一个新的上下文。 TransactionOption.Suppress -调用不是事务性的，但可以从事务中调用。如果在事务上下文中调用，则上下文将不会传递给调用。 TransactionOption.Supported -通话不是交易性的，但支持交易。如果在事务上下文中调用，则上下文将传递给调用。 TransactionOption.NotAllowed -访问不是事务性的，不能从事务中进行访问。如果在交易环境中调用，它将抛出一个 NotSupportedException 。 可以将访问标记为“创建”，这意味着访问将始终启动自己的事务。例如，下面的ATM中的“转帐”操作将始终启动一个涉及两个引用帐户的新交易。 public interface IATMGrain : IGrainWithIntegerKey { [Transaction(TransactionOption.Create)] Task Transfer(Guid fromAccount, Guid toAccount, uint amountToTransfer); } 帐户上的提款和存款交易操作标记为“加入”，表示只能在现有交易的上下文中调用它们，如果在 IATMGrain.Transfer(…) 。的 取得平衡 通话被标记 创建或加入 因此可以在现有交易中调用它，例如通过 IATMGrain.Transfer(…) ，或单独使用。 public interface IAccountGrain : IGrainWithGuidKey { [Transaction(TransactionOption.Join)] Task Withdraw(uint amount); [Transaction(TransactionOption.Join)] Task Deposit(uint amount); [Transaction(TransactionOption.CreateOrJoin)] Task<uint> GetBalance(); } grain实施 grain实施需要使用 ITransactionalState facet(请参阅Facet System)以通过ACID事务管理grains状态。 public interface ITransactionalState<TState> where TState : class, new() { Task<TResult> PerformRead<TResult>(Func<TState, TResult> readFunction); Task<TResult> PerformUpdate<TResult>(Func<TState, TResult> updateFunction); } 必须通过传递给事务状态方面的同步功能来执行对持久状态的所有读取或写入访问。这允许交易系统以交易方式执行或取消这些操作。要在Grains中使用事务状态，只需要定义一个可序列化的状态类即可保留，并在Grains的构造函数中使用 交易状态 属性。后者声明状态名称和(可选)使用哪个事务状态存储(请参阅安装程序)。 [AttributeUsage(AttributeTargets.Parameter)] public class TransactionalStateAttribute : Attribute { public TransactionalStateAttribute(string stateName, string storageName = null) { … } } 例： public class AccountGrain : Grain, IAccountGrain { private readonly ITransactionalState<Balance> balance; public AccountGrain( [TransactionalState(\"balance\", \"TransactionStore\")] ITransactionalState<Balance> balance) { this.balance = balance ?? throw new ArgumentNullException(nameof(balance)); } Task IAccountGrain.Deposit(uint amount) { return this.balance.PerformUpdate(x => x.Value += amount); } Task IAccountGrain.Withdrawal(uint amount) { return this.balance.PerformUpdate(x => x.Value -= amount); } Task<uint> IAccountGrain.GetBalance() { return this.balance.PerformRead(x => x.Value); } } 在上面的示例中，属性 交易状态 用于声明“ balance”构造函数参数应与名为“ balance”的交易状态相关联。通过此声明，Orleans将注入 ITransactionalState 从名为“ TransactionStore”的事务状态存储中加载状态的实例(请参阅安装程序)。可以通过以下方式修改状态 执行更新 或通过阅读 PerformRead 。交易基础架构将确保作为交易一部分进行的任何此类更改，即使是在分布于Orleans集群中的多个Grains之间，也将在创建交易的Grains调用完成后全部提交或全部撤消( IATMGrain.Transfer 在上述示例中)。 访问交易 如同其他任何Grains调用一样，调用Grains接口上的事务方法。 IATMGrain atm = client.GetGrain<IATMGrain>(0); Guid from = Guid.NewGuid(); Guid to = Guid.NewGuid(); await atm.Transfer(from, to, 100); uint fromBalance = await client.GetGrain<IAccountGrain>(from).GetBalance(); uint toBalance = await client.GetGrain<IAccountGrain>(to).GetBalance(); 在上述访问中，使用ATMGrains将100个单位的货币从一个帐户转移到另一个帐户。转帐完成后，将查询两个帐户以获取其当前余额。货币转帐以及两个帐户查询均作为ACID事务执行。 如上例所示，事务可以像其他grain调用一样返回任务中的值，但是在调用失败时，它们不会引发应用程序异常，而是 OrleansTransactionException 要么 TimeoutException 。如果应用程序在事务期间引发异常，并且该异常导致事务失败(与其他系统故障导致的失败相反)，则应用程序异常将是事务的内部异常。 OrleansTransactionException 。如果抛出类型的交易异常 OrleansTransactionAbortedException ，交易失败，可以重试。引发的任何其他异常都表示事务以未知状态终止。由于事务是分布式操作，因此处于未知状态的事务可能已经成功，失败或仍在进行中。因此，建议设置通话超时时间( SiloMessagingOptions.ResponseTimeout )传递，以避免级联中止，然后再验证状态或重试操作。"
  },
  "Documentation/grains/grainservices.html": {
    "href": "Documentation/grains/grainservices.html",
    "title": "GrainServices | Microsoft Orleans 中文文档",
    "keywords": "grain服务 GrainService是一种特殊的Grains。一个没有身份的，并且从启动到关闭都在每个silos中运行的程序。 创建一个GrainService 第1步。 创建接口。GrainService的接口是使用与构建其他任何grain的接口完全相同的原理构建的。 public interface IDataService : IGrainService { Task MyMethod(); } 第2步。 创建DataService本身。如果可能，使GrainServiceReentrant以获得更好的性能。注意必要的基本构造函数调用。很高兴知道您也可以注入 IGrainFactory 因此您可以从GrainService进行Grains调用。 关于流的说明：GrainService无法在Orleans流中写入，因为它在Grain Task Scheduler中不起作用。如果您需要GrainService为您写入流，则必须将对象发送到另一种Grains以写入流。 [Reentrant] public class LightstreamerDataService : GrainService, IDataService { readonly IGrainFactory GrainFactory; public LightstreamerDataService(IServiceProvider services, IGrainIdentity id, Silo silo, ILoggerFactory loggerFactory, IGrainFactory grainFactory) : base(id, silo, loggerFactory) { GrainFactory = grainFactory; } public override Task Init(IServiceProvider serviceProvider) { return base.Init(serviceProvider); } public override async Task Start() { await base.Start(); } public override Task Stop() { return base.Stop(); } public Task MyMethod() { } } 第三步 为GrainServiceClient创建一个接口，供其他Grains使用以连接到GrainService。 public interface IDataServiceClient : IGrainServiceClient<IDataService>, IDataService { } 第4步。 创建实际的Grains服务客户端。它几乎只是充当数据服务的代理。不幸的是，您必须手动输入所有方法映射，它们只是简单的一列式。 public class DataServiceClient : GrainServiceClient<IDataService>, IDataServiceClient { public DataServiceClient(IServiceProvider serviceProvider) : base(serviceProvider) { } public Task MyMethod() => GrainService.MyMethod(); } 第五步 将Grains服务客户端注入需要它的其他Grains中。注意，GrainServiceClient不保证访问本地silos上的GrainService。您的命令可能会发送到集群中任何silos上的GrainService。 public class MyNormalGrain: Grain<NormalGrainState>, INormalGrain { readonly IDataServiceClient DataServiceClient; public MyNormalGrain(IGrainActivationContext grainActivationContext, IDataServiceClient dataServiceClient) { DataServiceClient = dataServiceClient; } } 第六步 将grain服务注入Silo本身。您需要执行此操作，以便silos将启动GrainService。 (ISiloHostBuilder builder) => builder .ConfigureServices(services => { services.AddSingleton<IDataService, DataService>(); }); 补充笔记 ###注1 有一个扩展方法 ISiloHostBuilder：AddGrainService <SomeGrainService>() 。类型约束是： 其中T：GrainService 。最终调用此位： orleans / src / Orleans.Runtime / Services / GrainServicesSiloBuilderExtensions.cs 返回服务。AddSingleton <IGrainService>(sp => GrainServiceFactory(grainServiceType，sp)); 基本上，silos取 IGrain服务 启动时来自服务提供商的类型： orleans / src / Orleans.Runtime / Silo / Silo.cs var grainServices = this.Services.GetServices <IGrainService>(); 的 Microsoft.Orleans.OrleansRuntime Nuget软件包应由Grainservice项目引用。 ＃＃＃笔记2 为了使其正常工作，您必须注册服务及其客户端。代码看起来像这样： var builder = new SiloHostBuilder() .AddGrainService<DataService>() // Register GrainService .ConfigureServices(s => { // Register Client of GrainService s.AddSingleton<IDataServiceClient, DataServiceClient>(); })"
  },
  "Documentation/grains/timers_and_reminders.html": {
    "href": "Documentation/grains/timers_and_reminders.html",
    "title": "Timers and Reminders | Microsoft Orleans 中文文档",
    "keywords": "计时器和提醒 Orleans运行时提供了两种机制，称为计时器和提醒，使开发人员可以指定Grains的周期性行为。 计时器 计时器说明 计时器 用于创建不需要多次激活(Grains实例化)的周期性Grains行为。它与标准基本上相同。 NET System.Threading.Timer 类。另外，它在运行的Grains激活中要受单线程执行保证的约束。 每次激活可能具有零个或多个与其关联的计时器。运行时在与之关联的激活的运行时上下文中执行每个计时器例程。 计时器使用 要启动计时器，请使用 Grain.RegisterTimer 方法，该方法返回一个 IDisposable 参考： public IDisposable RegisterTimer( Func<object, Task> asyncCallback, // function invoked when the timer ticks object state, // object tp pass to asyncCallback TimeSpan dueTime, // time to wait before the first timer tick TimeSpan period) // the period of the timer 通过丢弃计时器来取消它。 如果取消激活激活或发生故障并且其silos崩溃，计时器将停止触发。 重要注意事项 启用激活收集后，计时器回调的执行不会将激活状态从空闲更改为使用中。这意味着无法使用计时器来推迟其他情况下空闲激活的取消激活。 期间过去了 Grain.RegisterTimer 是从任务返回的那一刻起经过的时间 asyncCallback 解决到下一次调用 asyncCallback 应该发生。这不仅使得无法连续调用 asyncCallback 重叠但也使时间长 asyncCallback 完成需要影响的频率 asyncCallback 被调用。这与 System.Threading.Timer 。 每次调用 asyncCallback 将在单独的回合上传递给激活，并且永远不会与同一激活中的其他回合同时运行。请注意， asyncCallback 调用不作为消息传递，因此不受消息交织语义的约束。这意味着 asyncCallback 相对于传递给该Grains的其他消息，应被视为表现为在ReentrantGrains上运行。 提醒事项 提醒说明 提醒与计时器类似，但有一些重要区别： 提醒是持久化的，除非明确取消，否则提醒将在几乎所有情况下(包括部分或完全重启群集)继续触发。 提醒“定义”被写入存储。但是，不是每个特定的事件及其特定的时间。这样做的副作用是，如果在某个特定的提醒滴答声时群集完全崩溃，则它将丢失，并且仅会发生提醒的下一个滴答声。 提醒与Grains相关联，而不是任何特定的激活。 如果某个Grains没有与之关联的激活并且有提示音，则将创建一个。例如：如果激活闲置而被停用，则与同一Grains关联的提醒会在下次勾选时重新激活Grains。 提醒是通过消息传递的，并且与其他所有grain方法都具有相同的交织语义。 提醒事项不应用于高频计时器，其周期应以分钟，小时或天为单位。 组态 提醒是持久的，依赖于存储来发挥作用。在提醒子系统起作用之前，您必须指定要使用的存储支持。这是通过以下方式配置提醒提供程序之一来完成的： UseXReminderService 扩展方法，其中X是提供者的名称，例如， UseAzureTableReminderService 。 Azure表配置： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() [...] .UseAzureTableReminderService(options => options.ConnectionString = connectionString) [...] SQL： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; const string invariant = \"YOUR_INVARIANT\"; var silo = new SiloHostBuilder() [...] .UseAdoNetReminderService(options => { options.ConnectionString = connectionString; options.Invariant = invariant; }) [...] 如果只希望使用提醒的占位符实现而不需要设置Azure帐户或SQL数据库，那么这将为您提供提醒系统的仅开发实现： var silo = new SiloHostBuilder() [...] .UseInMemoryReminderService() [...] 提醒用法 使用提醒的grain必须实现 IRemindable.RecieveReminder 方法。 Task IRemindable.ReceiveReminder(string reminderName, TickStatus status) { Console.WriteLine(\"Thanks for reminding me-- I almost forgot!\"); return Task.CompletedTask; } 要启动提醒，请使用 Grain.RegisterOrUpdateReminder 方法，该方法返回一个 IOrleansReminder 目的： protected Task<IOrleansReminder> RegisterOrUpdateReminder(string reminderName, TimeSpan dueTime, TimeSpan period) hinterName是一个字符串，必须在上下文范围内唯一地标识提醒。 dueTime指定发出第一个计时器刻度之前要等待的时间。 period指定计时器的时间。 由于提醒在任何一次激活的生命周期中都可以保留，因此必须将其明确取消(而不是处置)。您通过调用取消提醒 Grain.UnregisterReminder ： protected Task UnregisterReminder(IOrleansReminder reminder) 提醒是返回的句柄对象 Grains.RegisterOrUpdateReminder . 实例 IOrleansReminder 不能保证在激活的有效期之外有效。如果希望以持续的方式标识提醒，请使用包含提醒名称的字符串。 如果您只有提醒的名称并需要相应的实例 IOrleansReminder ，访问 Grains.GetReminder 方法： protected Task<IOrleansReminder> GetReminder(string reminderName) 我应该用哪一个？ 我们建议您在以下情况下使用计时器： 如果激活被停用或发生故障，计时器停止工作并不重要(或是可取的)。 计时器的分辨率很小(例如，可以用秒或分钟表示)。 计时器回调可以从 Grain.OnActivateAsync 或者调用grain方法时。 我们建议您在以下情况下使用提醒： 当周期性行为需要在激活和任何失败中幸存下来时。 执行一些不经常发生的任务(例如，在几分钟、几小时或几天内可以合理地表达)。 组合计时器和提醒 你可以考虑结合使用提醒和计时器来完成你的目标。例如，如果您需要一个分辨率很小的计时器，而该计时器需要在激活期间继续存在，则可以使用每五分钟运行一次的提醒，该提醒的目的是唤醒一个grains，该grains将重新启动可能因停用而丢失的本地计时器。"
  },
  "Documentation/grains/observers.html": {
    "href": "Documentation/grains/observers.html",
    "title": "Observers | Microsoft Orleans 中文文档",
    "keywords": "观察者 在某些情况下，简单的消息/响应模式是不够的，客户端需要接收异步通知。例如，当朋友发布了新的即时消息时，用户可能希望收到通知。 客户端观察器是一种允许异步通知客户端的机制。观察者是一个单向异步接口，它继承自 IGrainObserver ，其所有方法都必须是无效的。grain通过像grain接口方法一样调用它来向观察者发送通知，只是它没有返回值，因此grain不需要依赖于结果。Orleans运行时将确保单向传递通知。发布此类通知的Grain应该提供一个api来添加或删除观察者。此外，通常公开一种允许取消现有订阅的方法通常是方便的。Grains开发商可能会使用Orleans ObserverSubscriptionManager<T> 类，以简化观察到的grains类型的开发。 要订阅通知，客户端必须首先创建一个实现观察者接口的本地c对象。然后调用观察者工厂上的静态方法， CreateObjectReference() ，将c对象转换为一个grain引用，然后可以将其传递给通知grain上的订阅方法。 这个模型也可以被其他Grains用来接收异步通知。与客户端订阅情况不同，订阅Grain只是将observer接口实现为一个方面，并将引用传递给自己(例如。 this.AsReference<IMyGrainObserverInterface> )中。 代码示例 假设我们有一个周期性地向客户发送消息的Grain。为了简单起见，我们的示例中的消息将是一个字符串。我们首先在客户端上定义将接收消息的接口。 接口将如下所示 public interface IChat : IGrainObserver { void ReceiveMessage(string message); } 唯一特别的是接口应该继承自 IGrainObserver 是的。现在，任何希望观察这些消息的客户端都应该实现一个实现 IChat 是的。 最简单的例子是这样的： public class Chat : IChat { public void ReceiveMessage(string message) { Console.WriteLine(message); } } 现在在服务器上，我们应该有一个Grains发送这些聊天信息给客户端。grain还应该有一个机制，让客户端订阅和取消订阅自己以接收通知。对于订阅，grain可以使用utility类 ObserverSubscriptionManager 是的。这个班的学生 OrleansException 如果您尝试订阅已订阅的观察者(或取消订阅未订阅的观察者)，那么使用 IsSubscribed() 方法或通过处理 OrleansException 以下内容： class HelloGrain : Grain, IHello { private ObserverSubscriptionManager<IChat> _subsManager; public override async Task OnActivateAsync() { // We created the utility at activation time. _subsManager = new ObserverSubscriptionManager<IChat>(); await base.OnActivateAsync(); } // Clients call this to subscribe. public Task Subscribe(IChat observer) { if (!_subsManager.IsSubscribed(observer)) { _subsManager.Subscribe(observer); } return Task.CompletedTask; } //Also clients use this to unsubscribe themselves to no longer receive the messages. public Task UnSubscribe(IChat observer) { if (_subsManager.IsSubscribed(observer)) { _subsManager.Unsubscribe(observer); } return Task.CompletedTask; } } 将消息发送到客户端 Notify 方法 ObserverSubscriptionManager<Ichat> 可以使用实例。这种方法需要 Action<T> 方法或lambda表达式(其中 T 属于类型 IChat )。可以调用接口上的任何方法将其发送给客户端。我们只有一种方法 ReceiveMessage 我们在服务器上发送的代码如下所示： public Task SendUpdateMessage(string message) { _subsManager.Notify(s => s.ReceiveMessage(message)); return Task.CompletedTask; } 现在，我们的服务器有一个向观察者客户端发送消息的方法，两个用于订阅/取消订阅的方法，并且客户端实现了一个能够观察到grain消息的类。最后一步是使用之前实现的 Chat 类并让它在订阅后接收消息。 代码如下所示： //First create the grain reference var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Chat c = new Chat(); //Create a reference for chat usable for subscribing to the observable grain. var obj = await GrainClient.GrainFactory.CreateObjectReference<IChat>(c); //Subscribe the instance to receive messages. await friend.Subscribe(obj); 现在每当服务器上的Grains调用 SendUpdateMessage 方法，所有已订阅的客户端都将收到消息。在我们的客户代码中， Chat 变量中的实例 C 将接收消息并将其输出到控制台。 注： 传递给的对象 CreateObjectReference 通过 WeakReference<T> 因此，如果没有其他引用，则将被垃圾收集。用户应该为每个不希望被收集的观察者维护一个引用。 注： 观察者本质上是不可靠的，因为您没有得到任何响应来知道消息是被接收和处理的，还是仅仅由于分布式系统中可能出现的任何情况而失败。因此，您的观察者应该定期轮询grain或使用任何其他机制来确保他们接收到了所有应该接收到的消息。在某些情况下，您可能会丢失一些消息，并且不需要任何附加机制，但如果您需要确保所有观察者始终接收消息并接收所有消息，则定期重新订阅和轮询观察者Grain有助于确保最终处理所有消息。"
  },
  "Documentation/grains/reentrancy.html": {
    "href": "Documentation/grains/reentrancy.html",
    "title": "Reentrancy | Microsoft Orleans 中文文档",
    "keywords": "Reentrant Grain激活是单线程的，默认情况下，在下一个请求可以开始处理之前，从头到尾处理每个请求。在某些情况下，当一个请求等待异步操作完成时，可能需要激活来处理其他请求。由于这个和其他原因，Orleans给了开发人员一些控制请求交错行为的权限。在以下情况下，多个请求可能被交错： Grains等级标记为 [Reentrant] 接口方法标记为 [AlwaysInterleave] 同一调用链中的请求 Grains的 MayInterleave 谓词返回 true 以下各节将讨论这些情况。 重入grains Grains 实现类可以用 [Reentrant] 属性指示不同的请求可以自由交错。 换言之，Reentrant激活可能在前一个请求尚未完成处理时开始执行另一个请求。执行仍然局限于单个线程，因此激活仍然一次执行一个回合，并且每个回合只代表激活的一个请求执行。 ReentrantGrain代码永远不会并行运行多个Grain代码(Grain代码的执行将始终是单线程的)，但ReentrantGrain代码 可能 看见不同请求交错执行的代码。也就是说，不同请求的续转可以交错。 例如，使用下面的伪代码，当Foo和Bar是同一grain类的2个方法时： Task Foo() { await task1; // line 1 return Do2(); // line 2 } Task Bar() { await task2; // line 3 return Do2(); // line 4 } 如果这个grains有标记 [Reentrant] ，Foo和Bar的执行可以交错执行。 例如，可以按以下顺序执行： 1号线、3号线、2号线和4号线。也就是说，来自不同请求的圈数交错。 如果grain不Reentrant，唯一可能的执行将是：第1行、第2行、第3行、第4行或：第3行、第4行、第1行、第2行(在前一个请求完成之前，新请求无法启动)。 在选择Reentrant和不Reentrantgrains时，主要的折衷是使交织正确工作的代码复杂度和对此进行推理的困难。 在一个很小的例子中，当Grain是无状态的，逻辑也很简单时，更少(但不是太少，以便使用所有的硬件线程)Reentrantgrains通常会稍微更有效一些。 如果代码更复杂，那么大量的不Reentrantgrains，即使总体效率稍低，也可以避免您在解决不明显的交错问题时的许多痛苦。 最终答案将取决于具体的应用程序。 交错方法 grains接口被标记为 [AlwaysInterleave] 无论grains是否Reentrant，都将被交错执行。考虑以下示例： public interface ISlowpokeGrain : IGrainWithIntegerKey { Task GoSlow(); [AlwaysInterleave] Task GoFast(); } public class SlowpokeGrain : Grain, ISlowpokeGrain { public async Task GoSlow() { await Task.Delay(TimeSpan.FromSeconds(10)); } public async Task GoFast() { await Task.Delay(TimeSpan.FromSeconds(10)); } } 现在考虑由以下客户端请求启动的调用流： var slowpoke = client.GetGrain<ISlowpokeGrain>(0); // A) This will take around 20 seconds await Task.WhenAll(slowpoke.GoSlow(), slowpoke.GoSlow()); // B) This will take around 10 seconds. await Task.WhenAll(slowpoke.GoFast(), slowpoke.GoFast(), slowpoke.GoFast()); 访问 GoSlow 不会交错，所以执行两个 GoSlow() 调用大约需要20秒。另一方面，因为 GoFast 有标记 [AlwaysInterleave] ，对它的三个调用将同时执行，并将在大约10秒内完成，而不是至少需要30秒才能完成。 访问链中的Reentrant性 为了避免死锁，调度器允许在给定的调用链中进行重入。考虑以下两个grains的例子，它们具有相互递归的方法， IsEven 和 IsOdd : public interface IEvenGrain : IGrainWithIntegerKey { Task<bool> IsEven(int num); } public interface IOddGrain : IGrainWithIntegerKey { Task<bool> IsOdd(int num); } public class EvenGrain : Grain, IEvenGrain { public async Task<bool> IsEven(int num) { if (num == 0) return true; var oddGrain = this.GrainFactory.GetGrain<IOddGrain>(0); return await oddGrain.IsOdd(num - 1); } } public class OddGrain : Grain, IOddGrain { public async Task<bool> IsOdd(int num) { if (num == 0) return false; var evenGrain = this.GrainFactory.GetGrain<IEvenGrain>(0); return await evenGrain.IsEven(num - 1); } } 现在考虑由以下客户端请求启动的调用： var evenGrain = client.GetGrain<IEvenGrain>(0); await evenGrain.IsEven(2); 上面的代码调用 IEvenGrain.IsEven(2) ，调用 IOddGrain.IsOdd(1) ，调用 IEvenGrain.IsEven(0) ，返回 true 将访问链备份到客户端。如果没有调用链Reentrant，上述代码将在以下情况下导致死锁当 IOddGrain 调用 IEvenGrain.IsEven(0) . 然而，对于调用链Reentrant，调用被认为是开发人员的意图，因此允许继续进行。 可以通过设置来禁用此行为 SchedulingOptions.AllowCallChainEntrancy 为 false . 例如： siloHostBuilder.Configure<SchedulingOptions>( options => options.AllowCallChainReentrancy = false); 使用谓词的Reentrant性 Grain类可以指定一个谓词，用于通过检查请求逐个调用确定交错。这个 [MayInterleave(string methodName)] 属性提供此功能。属性的参数是grain类中接受 InvokeMethodRequest 对象并返回 bool 指示是否应交错请求。 下面是一个示例，如果请求参数类型具有 [Interleave] 属性： [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)] public sealed class InterleaveAttribute : Attribute { } // Specify the may-interleave predicate. [MayInterleave(nameof(ArgHasInterleaveAttribute))] public class MyGrain : Grain, IMyGrain { public static bool ArgHasInterleaveAttribute(InvokeMethodRequest req) { // Returning true indicates that this call should be interleaved with other calls. // Returning false indicates the opposite. return req.Arguments.Length == 1 && req.Arguments[0]?.GetType().GetCustomAttribute<InterleaveAttribute>() != null; } public Task Process(object payload) { // Process the object. } }"
  },
  "Documentation/grains/grain_identity.html": {
    "href": "Documentation/grains/grain_identity.html",
    "title": "Grain Identity | Microsoft Orleans 中文文档",
    "keywords": "Grains身份 在面向对象的环境中，很难将对象的标识与对其的引用区分开。因此，当使用new创建对象时，您获得的引用代表其身份的所有方面，除了那些将对象映射到其所代表的外部实体的方面。 在分布式系统中，对象引用不能表示实例身份，因为引用通常限于单个地址空间。.NET引用肯定是这种情况。此外，无论Grains是否处于活动状态，它都必须具有身份，以便我们可以按需激活它。因此，Grains具有主键。主键可以是全局唯一标识符(GUID)，长整数或字符串。 Grain的主键在其类型中定义。因此，Grain的完整标识由Grain的类型及其键组成。 Grains的调用者决定应使用哪种方案。选项包括： long GUID string GUID + string long + string 因为基础数据是相同的，所以这些方案可以互换使用。当使用长整数时，实际上会创建一个GUID并用零填充。 需要使用单例Grains实例的情况(例如字典或注册表)可从使用中受益 Guid.Empty 作为其关键。这仅仅是一个约定，但是通过坚持，正如我们在第一个教程中所看到的，在调用站点处，事情已经很清楚了。 使用GUID 当有多个进程可能需要请求grain时，例如Web场中的许多Web服务器，GUID很有用。您不需要协调主键的分配，这可能会导致系统出现单点故障，也可能不需要对资源进行系统侧锁定就可能造成瓶颈。GUID发生碰撞的可能性很小，因此在构建Orleans系统时，它们可能是默认选择。 在客户端代码中通过GUID引用Grains： var grain = grainFactory.GetGrain<IExample>(Guid.NewGuid()); 从Grains代码中检索主键： public override Task OnActivateAsync() { Guid primaryKey = this.GetPrimaryKey(); return base.OnActivateAsync(); } 使用Longs 也可以使用一个长整数，如果将Grains持久保存到关系数据库中(在该数据库中数字索引优先于GUID)，这将是有意义的。 在客户端代码中通过长整数引用Grains： var grain = grainFactory.GetGrain<IExample>(1); 检索主键形式的Grain代码： public override Task OnActivateAsync() { long primaryKey = this.GetPrimaryKeyLong(); return base.OnActivateAsync(); } 使用字符串 字符串也是可用的。 在客户端代码中按字符串引用Grains： var grain = grainFactory.GetGrain<IExample>(\"myGrainKey\"); 检索主键形式的Grain代码： public override Task OnActivateAsync() { string primaryKey = this.GetPrimaryKeyString(); return base.OnActivateAsync(); } 使用复合主键 如果您的系统与GUID或long均不合适，则可以选择复合主键，该主键允许您使用GUID或long与字符串的组合来引用Grains。 您可以从 IGrainWithGuidCompoundKey 或 IGrainWithIntegerCompoundKey 接口继承接口，如下所示： public interface IExampleGrain : Orleans.IGrainWithIntegerCompoundKey { Task Hello(); } 在客户端代码中，这会向 GetGrain 粮厂的方法。 var grain = grainFactory.GetGrain<IExample>(0, \"a string!\", null); 要访问Grains中的复合键，我们可以在 GetPrimaryKey 方法： public class ExampleGrain : Orleans.Grain, IExampleGrain { public Task Hello() { string keyExtension; long primaryKey = this.GetPrimaryKeyLong(out keyExtension); Console.WriteLine(\"Hello from \" + keyExtension); Task.CompletedTask; } }"
  },
  "Documentation/grains/request_context.html": {
    "href": "Documentation/grains/request_context.html",
    "title": "Request Context | Microsoft Orleans 中文文档",
    "keywords": "请求上下文 RequestContext是一个Orleans特性，它允许应用程序元数据(如跟踪ID)与请求一起流动。应用程序元数据可以添加到客户端上；它将与Orleans请求一起流向接收Grain。 该特性由Orleans名称空间中的一个公共静态类RequestContext实现。此类公开了两个简单方法： void Set(string key, object value) 用于在请求上下文中存储值。该值可以是任何可序列化类型。 Object Get(string key) 用于从当前请求上下文中检索值。 RequestContext的后台存储是线程静态的。当一个线程(无论是客户端还是在Orleans内)发送请求时，发送线程的RequestContext的内容都包含在请求的Orleans消息中；当grain代码接收到请求时，可以从本地RequestContext访问该元数据。如果grain代码没有修改RequestContext，那么它请求的任何grain都将接收相同的元数据，依此类推。 当您使用StartNew或ContinueWith计划未来的计算时，也会维护应用程序元数据；在这两种情况下，后续的任务将使用与调度代码在调度计算时所具有的相同元数据执行(即，系统复制当前元数据并将其传递给后续任务，因此，调用StartNew或ContinueWith之后的更改将不会被后续任务看到)。 请注意，应用程序元数据不会随响应返回；也就是说，由于接收到响应而运行的代码，无论是在ContinueWith 后续任务中，还是在调用Wait或GetValue之后，仍将在原始请求设置的当前上下文中运行。 例如，要将客户端中的跟踪ID设置为新的GUID，只需调用： RequestContext.Set(\"TraceId\", new Guid()); 在grain代码(或在Orleans内运行的调度程序线程上的其他代码)中，可以使用原始客户端请求的跟踪ID，例如，在编写日志时： Logger.Info(\"Currently processing external request {0}\", RequestContext.Get(\"TraceId\")); 虽然任何可序列化的对象都可以作为应用程序元数据发送，但值得一提的是，大型或复杂的对象可能会给消息序列化时间增加显著的开销。因此，建议使用简单类型(字符串、guid或数字类型)。"
  },
  "Documentation/grains/code_generation.html": {
    "href": "Documentation/grains/code_generation.html",
    "title": "Code Generation | Microsoft Orleans 中文文档",
    "keywords": "代码生成 orleans运行时使用生成的代码，以确保跨集群使用的类型的正确序列化，并生成样板文件，该样板文件抽象出方法传送、异常传播和其他内部运行时概念的实现细节。 启用代码生成 代码生成可以在项目生成或应用程序初始化时执行。 在构建期间 执行代码生成的首选方法是在生成时。可以使用以下包之一启用生成时代码生成： Microsoft.Orleans.OrleansCodeGenerator.Build 是的。使用Roslyn生成代码并使用.NET反射进行分析的包。 Microsoft.Orleans.CodeGenerator.MSBuild 是的。一个新的代码生成包，它利用roslyn进行代码生成和代码分析。它不加载应用程序二进制文件，因此避免了由相互冲突的依赖项版本和不同的目标框架引起的问题。新的代码生成器还改进了对增量构建的支持，这将缩短构建时间。 这些包中的一个应该安装到所有包含Grain、Grain接口、自定义序列化程序或在Grain之间发送的类型的项目中。安装包会将目标插入到项目中，该项目将在生成时生成代码。 两个包( Microsoft.Orleans.CodeGenerator.MSBuild 和 Microsoft.Orleans.OrleansCodeGenerator.Build )只支持C项目。使用 Microsoft.Orleans.Orleanscodegenerator 下面描述的包，或者通过创建一个c项目，该项目可以作为用其他语言编写的程序集生成的代码的目标。 通过指定 奥尔兰斯科德格勒 在目标项目的 项目文件 文件。例如， <orleanscodegenloglevel>跟踪</orleanscodegenloglevel> 是的。 初始化期间 通过安装 Microsoft.Orleans.Orleanscodegenerator 打包并使用 IApplicationPartManager.WithCodeGeneration 扩展方法。 builder.ConfigureApplicationParts( parts => parts .AddApplicationPart(typeof(IRuntimeCodeGenGrain).Assembly) .WithCodeGeneration()); 在上面的例子中， builder 可能是其中之一的实例 IsiloHostBuilder 或 IClientBuilder 是的。可选的 ILoggerfactory 实例可以传递到 WithCodeGeneration 要在代码生成期间启用日志记录，例如： ILoggerFactory codeGenLoggerFactory = new LoggerFactory(); codeGenLoggerFactory.AddProvider(new ConsoleLoggerProvider()); builder.ConfigureApplicationParts( parts => parts .AddApplicationPart(typeof(IRuntimeCodeGenGrain).Assembly) .WithCodeGeneration(codeGenLoggerFactory)); 影响代码生成 为特定类型生成代码 自动为grain接口、grain类、grain状态和在grain方法中作为参数传递的类型生成代码。如果类型不符合此条件，则可以使用以下方法进一步指导代码生成。 添加 [Serializable] 指示代码生成器为类型生成序列化程序。 添加 [assembly: GenerateSerializer(Type)] 指示代码生成器将该类型视为可序列化的，并且如果无法为该类型生成序列化程序(例如，因为该类型不可访问)，则将导致错误。如果启用代码生成，此错误将停止生成。此属性还允许从另一个程序集为特定类型生成代码。 [assembly：knownype(type)] 还指示代码生成器包含特定类型(可能来自引用的程序集)，但如果该类型不可访问，则不会导致异常。 为所有子类型生成序列化程序 添加 [KnownBaseType] 指示代码生成器为继承/实现该类型的所有类型生成序列化代码。 为其他程序集中的所有类型生成代码 在某些情况下，生成的代码在生成时不能包含在特定程序集中。例如，这可以包括不引用Orleans的共享库、用C以外的语言编写的程序集以及开发人员没有源代码的程序集。在这些情况下，为这些程序集生成的代码可以放在一个单独的程序集中，该程序集在初始化期间被引用。 要为程序集启用此功能，请执行以下操作： 创建一个C项目。 安装 Microsoft.Orleans.CodeGenerator.MSBuild 或者 Microsoft.Orleans.OrleansCodeGenerator.Build 包裹。 添加对目标程序集的引用。 添加 [assembly: knownAssembly(\"otherAssembly\")] 在C文件的顶层。 这个 KnownAssemblyAttribute 属性指示代码生成器检查指定的程序集并为其中的类型生成代码。该属性可以在项目中多次使用。 然后，必须在初始化期间将生成的程序集添加到客户端/silos： builder.ConfigureApplicationParts( parts => parts.AddApplicationPart(\"CodeGenAssembly\")); 在上面的例子中， builder 可能是其中之一的实例 IsiloHostBuilder 或 IClientBuilder 是的。 KnownAssemblyAttribute 具有可选属性， TreatTypesAsSerializable ，可以设置为 true 指示代码生成器将程序集中的所有类型标记为可序列化。"
  },
  "Documentation/grains/cancellation_tokens.html": {
    "href": "Documentation/grains/cancellation_tokens.html",
    "title": "Grain cancellation tokens | Microsoft Orleans 中文文档",
    "keywords": "Grains取消令牌 orleans运行时提供了一种称为grain cancellation token的机制，使开发人员能够取消正在执行的grain操作。 说明 GrainCancellationToken 是标准的包装 .NET System.Threading.CancellationToken ，它启用线程、线程池工作项或任务对象之间的协作取消，并且可以作为grain方法参数传递。 一个 GrainCancellationTokenSource 是通过其token属性提供取消令牌并通过调用 取消 方法。 用法 实例化CancellationTokenSource对象，该对象管理并向各个取消令牌发送取消通知。 var tcs = new GrainCancellationTokenSource(); 将GrainCancellationTokenSource.Token属性返回的令牌传递给侦听取消的每个Grain方法。 var waitTask = grain.LongIoWork(tcs.Token, TimeSpan.FromSeconds(10)); 可取消的Grains操作需要处理底层 GrainCancellationToken 属性的 CancellationToken 就像在其他.NET代码中一样。 public async Task LongIoWork(GrainCancellationToken tc, TimeSpan delay) { while(!tc.CancellationToken.IsCancellationRequested) { await IoOperation(tc.CancellationToken); } } 调用给 GrainCancellationTokenSource.Cancel 方法启动取消。 await tcs.Cancel(); 当使用完 GrainCancellationTokenSource 对象调用 Dispose 方法。 tcs.Dispose(); 重要注意事项： 这个 GrainCancellationTokenSource.Cancel 方法返回 Task ，并且为了确保取消，必须在短暂通信失败的情况下重试取消调用。 在基础中注册的回调 System.Threading.CancellationToken 在注册它们的grain 激活中受单线程执行保证的约束。 每个 GrainCancellationToken 可以通过多个方法调用传递。"
  },
  "Documentation/grains/index.html": {
    "href": "Documentation/grains/index.html",
    "title": "Developing a Grain | Microsoft Orleans 中文文档",
    "keywords": "准备 在编写代码以实现Grains类之前，请创建一个针对.NET Standard（首选）或.NET Framework 4.6.1或更高版本的新类库项目（如果由于依赖性而无法使用.NET Standard）。可以在同一个“类库”项目中或在两个不同的项目中定义grains接口和grains类，以更好地将接口与实现分开。无论哪种情况，项目都需要参考 Microsoft.Orleans.Core.Abstractions 和 Microsoft.Orleans.CodeGenerator.MSBuild NuGet软件包。 有关更详尽的说明，请参见 项目设置 的部分 教程一–Orleans基础 。 Grains接口和类 Grains通过从外部调用各个Grains接口申明的方法进行相互交互。Grains类实现一个或多个先前声明的Grains接口。Grain接口的所有方法都必须返回 Task （对于 virtual 方法），一个 Task<T> 或一个 ValueTask <T> （对于返回类型为值的方法 T ）。 以下是Orleans 1.5 Presence Service示例的摘录： //an example of a Grain Interface public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } //an example of a Grain class implementing a Grain Interface public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGame() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGame(IGameGrain game) { currentGame = game; Console.WriteLine( \"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGame(IGameGrain game) { currentGame = null; Console.WriteLine( \"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } } Grains方法的返回值 返回 T 类型值的grain方法在grain接口中定义为返回 Task<T> 。对于未标有async关键字，当返回值可用时，通常通过以下语句返回： public Task<SomeType> GrainMethod1() { ... return Task.FromResult(<variable or constant with result>); } 没有返回值的grain方法（实际上是void方法）在grain接口中定义为返回 Task 。返回的 Task 指示方法的异步执行和完成。对于未标有async关键字，当 void 方法完成执行时，需要返回的特殊值 Task.CompletedTask ： public Task GrainMethod2() { ... return Task.CompletedTask; } 标记为async直接返回值： public async Task<SomeType> GrainMethod3() { ... return <variable or constant with result>; } 一种 void 的Grains方法标记为async不返回值的代码只是在执行结束时返回： public async Task GrainMethod4() { ... return; } 如果grain方法从另一个异步方法调用接收到的返回值（是否返回grain），并且不需要对该调用执行错误处理，则只需返回 Task 它从该异步调用接收作为其返回值： public Task<SomeType> GrainMethod5() { ... Task<SomeType> task = CallToAnotherGrain(); return task; } 同样， void Grain方法可以返回 Task 通过另一个调用返回给它，而不是等待它。 public Task GrainMethod6() { ... Task task = CallToAsyncAPI(); return task; } ValueTask <T> 可以代替 Task<T> Grains引用 Grains引用是实现与相应Grains类相同的Grains接口的代理对象。它封装了目标Grain的逻辑标识（类型和唯一键）。Grains引用是用于调用目标Grains的工具。每个Grains引用都针对单个Grains（Grains类的单个实例），但是可以为同一个Grains创建多个独立的引用。 由于Grains引用代表目标Grains的逻辑标识，因此它与Grains的物理位置无关，即使在系统完全重启后也仍然有效。开发人员可以像其他任何.NET对象一样使用Grains引用。它可以传递给方法，用作方法的返回值等，甚至可以保存到持久化存储中。 可以通过将Grains的身份传递给 GrainFactory.GetGrain <T>(key) 方法，在哪里 T 是Grains接口， key 是该类型中纹理的唯一键。 以下是如何获取 IPlayerGrain 上面定义的接口。 从Grains类内部： //construct the grain reference of a specific player IPlayerGrain player = GrainFactory.GetGrain<IPlayerGrain>(playerId); 来自Orleans客户代码。 IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Grain方法调用 Orleans编程模型基于 异步编程 。 使用上一个示例中的grain引用，这里是执行grain方法调用的方法： //Invoking a grain method asynchronously Task joinGameTask = player.JoinGame(this); //The await keyword effectively makes the remainder of the method execute asynchronously at a later point (upon completion of the Task being awaited) without blocking the thread. await joinGameTask; //The next line will execute later, after joinGameTask is completed. players.Add(playerId); 可以加入两个或多个 Task ;联接操作创建一个新的 Task 当所有组成部分都解决时 Task s完成。当Grains需要启动多个计算并等待所有计算完成后再继续操作时，这是一种有用的模式。例如，生成由许多部分组成的网页的前端纹理可能会进行多个后端调用，每个部分一个，并接收一个 Task 对于每个结果。然后Grains将等待所有这些的加入 Task ;当加入 Task 解决了，个人 Task 已完成，并且已收到格式化网页所需的所有数据。 例： List<Task> tasks = new List<Task>(); Message notification = CreateNewMessage(text); foreach (ISubscriber subscriber in subscribers) { tasks.Add(subscriber.Notify(notification)); } // WhenAll joins a collection of tasks, and returns a joined Task that will be resolved when all of the individual notification Tasks are resolved. Task joinedTask = Task.WhenAll(tasks); await joinedTask; // Execution of the rest of the method will continue asynchronously after joinedTask is resolve. 虚方法 Grains类可以选择覆盖 OnActivateAsync 和 OnDeactivateAsync 在激活和停用类的每个Grain时，由Orleans运行时调用的虚拟方法。这使Grains代码有机会执行其他初始化和清理操作。引发的异常 OnActivateAsync 无法激活过程。而 OnActivateAsync ，如果被覆盖，则始终被称为Grains激活过程的一部分， OnDeactivateAsync 不能保证在所有情况下（例如在服务器故障或其他异常事件的情况下）都会被调用。因此，应用程序不应依赖 OnDeactivateAsync 用于执行关键操作，例如状态变化的持久化。他们应仅将其用于尽力而为的操作。"
  },
  "Documentation/deployment/multi-cluster_support/SiloConfiguration.html": {
    "href": "Documentation/deployment/multi-cluster_support/SiloConfiguration.html",
    "title": "Multi-Cluster Silo Configuration | Microsoft Orleans 中文文档",
    "keywords": "Orleanssilos配置 为了快速了解，我们在下面的XML语法中显示了所有相关的配置参数(包括可选参数)： <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <MultiClusterNetwork ClusterId=\"clusterid\" DefaultMultiCluster=\"uswest,europewest,useast\" BackgroundGossipInterval=\"30s\" UseGlobalSingleInstanceByDefault=\"false\" GlobalSingleInstanceRetryInterval=\"30s\" GlobalSingleInstanceNumberRetries=\"3\" MaxMultiClusterGateways=\"10\"> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> </MultiClusterNetwork> <SystemStore ... ServiceId=\"some-guid\" .../> </Globals> </OrleansConfiguration> var silo = new SiloHostBuilder() [...] .Configure<ClusterInfo>(options => { options.ClusterId = \"us3\"; options.ServiceId = \"myawesomeservice\"; }) .Configure<MultiClusterOptions>(options => { options.HasMultiClusterNetwork = true; options.DefaultMultiCluster = new[] { \"us1\", \"eu1\", \"us2\" }; options.BackgroundGossipInterval = TimeSpan.FromSeconds(30); options.UseGlobalSingleInstanceByDefault = false; options.GlobalSingleInstanceRetryInterval = TimeSpan.FromSeconds(30); options.GlobalSingleInstanceNumberRetries = 3; options.MaxMultiClusterGateways = 10; options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"); options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\") [...] }) [...] 与往常一样，所有配置设置也可以通过 全球配置 上课。 这个 服务ID 是用于标识此服务的任意ID。所有集群和所有silos必须相同。 这个 多集群网络 节是可选的-如果不存在，则禁用此silos的所有多群集支持。 这个 所需参数 棒状的 和 八卦频道 在 多集群通信 是的。 可选参数 MaxMultiClusterGateways系列 和 背景消息间隔 在 多集群通信 是的。 可选参数 默认多群集 在 多群集配置 是的。 可选参数 默认为UseGlobalSingleInstances ，请 GlobalSingleInstanceRetryInterval 和 GlobalSingleInstanceNumberEntries全局 在 全局单实例Grain 是的。 Orleans客户端配置 Orleans客户端不需要额外配置。同一客户端可能无法连接到不同集群中的silos(silos在这种情况下拒绝连接)。"
  },
  "Documentation/deployment/multi-cluster_support/GlobalSingleInstance.html": {
    "href": "Documentation/deployment/multi-cluster_support/GlobalSingleInstance.html",
    "title": "Global-Single-Instance Grains | Microsoft Orleans 中文文档",
    "keywords": "grains协调属性 开发人员可以指示集群应该在何时以及如何根据特定的grain类协调其grain目录。这个 [全球照明] 属性意味着我们需要与在单个全局集群中运行orleans时相同的行为：即将所有调用路由到一个单一的grain激活。相反地， [OneInstancePerCluster] 属性指示每个群集可以有自己的独立激活。如果集群之间的通信是不需要的，这是合适的。 属性放在grain实现上。例如： using Orleans.MultiCluster; [GlobalSingleInstance] public class MyGlobalGrain : Orleans.Grain, IMyGrain { ... } [OneInstancePerCluster] public class MyLocalGrain : Orleans.Grain, IMyGrain { ... } 如果grain类没有指定这些属性中的任何一个，则默认为 [OneInstancePerCluster] 或 [全球照明] 如果配置参数 默认为UseGlobalSingleInstances 设置为true。 全局单实例Grain协议 当访问全局单实例(GSI)grains，并且不知道存在激活时，在激活新实例之前执行特殊GSI激活协议。特别地，请求被发送到当前 多群集配置 检查他们是否已经激活了这种Grains。如果所有响应均为负，则在此群集中创建新激活。否则，将使用远程激活(并在本地目录中缓存对它的引用)。 每个集群Grain一个实例的协议 对于每个集群Grain的一个实例，没有集群间通信。它们只需在每个集群中独立使用标准的orleans机制。在orleans框架本身中，以下grain类用 [OneInstancePerCluster] 属性： 管理grain ，请 grains数据库成员表 ，和 Grain 是的。 可疑激活 如果GSI协议在3次重试(或配置参数指定的任何数目)后没有从所有集群接收到结论性响应 GlobalSingleInstanceNumberEntries全局 ，它乐观地创建了一个新的本地“可疑”激活，支持可用性而不是一致性。 可疑的激活可能是重复的(因为某些在GSI协议激活期间没有响应的远程集群可能仍然激活了此grains)。因此，每隔30秒(或配置参数指定的任何间隔)定期 GlobalSingleInstanceRetryInterval )对于所有可疑的激活，再次运行gsi协议。这确保一旦恢复集群之间的通信，就可以检测并删除重复的激活。"
  },
  "Documentation/deployment/docker_deployment.html": {
    "href": "Documentation/deployment/docker_deployment.html",
    "title": "Docker Deployment | Microsoft Orleans 中文文档",
    "keywords": "Docker部署 注意 ：即使你非常熟悉Docker和/或Orleans，就像任何其他Orleans文档一样，我建议你读到最后，以避免你可能面临的问题，我们已经解决了。 注意 ：本文及其示例是正在进行的工作。任何反馈，公关或建议都是非常欢迎的。 将Orleans解决方案部署到Docker 考虑到Docker Orchestrator和集群堆栈的设计方式，将Orleans部署到Docker可能会很棘手。最复杂的是要理解 覆盖网络 来自Docker Swarm和Kubernets的网络模型。 Docker容器和网络模型的设计主要是运行无状态和不可变的容器。因此，启动运行node.js或nginx应用程序的集群非常容易。但是，如果您尝试使用更精细的东西，比如真正的集群或分布式应用程序(比如基于Orleans的应用程序)，那么您最终将无法设置它。这是可能的，但不像基于web的应用程序那么简单。 Docker集群包括将多个主机组合成一个资源池，使用 容器编排器 是的。 Docker 提供 蜂群 作为容器编排的选项 谷歌 有 库伯内特斯 (又名 K8S型 )中。还有其他的编曲者像 直流/操作系统 ， 介子 ，等等，但在本文中，我们将讨论swarm和k8s，因为它们使用得更广泛。 同样的grain接口和实现在Orleans的任何地方都已经得到支持，也将在docker容器上运行，因此不需要特别考虑就可以在docker容器中运行您的应用程序。 这个 Orleans码头工人 示例提供了如何运行两个控制台应用程序的工作示例。一个作为Orleans客户端，另一个作为silos，详细信息如下所述。 这里讨论的概念既可以用于.NET Core，也可以用于.NET 4.6.1版本的Orleans，但是为了说明Docker和.NET Core的跨平台特性，考虑到您正在使用.NET Core，我们将重点讨论这个示例。本文将提供特定于平台(windows/linux/osx)的详细信息。 预备知识 本文假设您安装了以下先决条件： 码头工人 -Docker4x为主要支持的平台提供了易于使用的安装程序。它包含Docker引擎和Docker Swarm。 库伯内特斯(K8S) -谷歌提供的容器编排。它包含安装指南 迷你库贝 (K8S的本地部署)和 库贝克特 以及它所有的依赖关系。 .NET核心 -.net的跨平台风格 Visual Studio代码(VScode) -你想用什么就用什么。vscode是跨平台的，所以我们使用它来确保它可以在所有平台上工作。安装vscode后，请安装 C扩展 是的。 注意 ：如果您不打算使用kubernetes，则不需要安装它。Docker4x安装程序已经包含Swarm，因此无需额外安装即可使用。 Windows用户注意事项 ：在Windows上，Docker安装程序将在安装过程中启用Hyper-V。由于本文及其示例使用的是.NET Core，因此使用的容器映像基于 Windows服务器NanoServer 是的。如果您不打算使用.net core并将目标锁定为.net 4.6.1full framework，则使用的映像应该是 Windows服务器核心 以及Orleans的1.4+版本(仅支持.NET完整框架)。 创建Orleans解决方案 下面的说明演示如何使用 点网 工具。 注意 ：请根据您的平台中的适当情况调整命令。另外，目录结构只是一个建议。请根据您的需要调整它。 mkdir Orleans-Docker cd Orleans-Docker dotnet new sln mkdir -p src/OrleansSilo mkdir -p src/OrleansClient mkdir -p src/OrleansGrains mkdir -p src/OrleansGrainInterfaces dotnet new console -o src/OrleansSilo --framework netcoreapp1.1 dotnet new console -o src/OrleansClient --framework netcoreapp1.1 dotnet new classlib -o src/OrleansGrains --framework netstandard1.5 dotnet new classlib -o src/OrleansGrainInterfaces --framework netstandard1.5 dotnet sln add src/OrleansSilo/OrleansSilo.csproj dotnet sln add src/OrleansClient/OrleansClient.csproj dotnet sln add src/OrleansGrains/OrleansGrains.csproj dotnet sln add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansClient/OrleansClient.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansGrains/OrleansGrains.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrains/OrleansGrains.csproj 到目前为止，我们所做的只是创建解决方案结构、项目和在项目之间添加引用的样板代码。没有什么不同于常规的Orleans项目。 在撰写本文时，Orleans 2.0(这是唯一支持.NET Core和跨平台的版本)已经进入了技术预览版，因此它的nuget托管在myget feed中，而不是发布到nuget.org官方feed。为了安装preview nuget，我们将使用 点网 cli强制myget提供源提要和版本： dotnet add src/OrleansClient/OrleansClient.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrains/OrleansGrains.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.OrleansRuntime -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet restore 好了，现在您已经拥有了运行一个简单的Orleans应用程序的所有基本依赖项。请注意，到目前为止，您的常规Orleans申请没有任何变化。现在，让我们添加一些代码，这样我们就可以用它做些什么了。 实现您的Orleans应用程序 假设你正在使用 甚小码 ，从解决方案目录中运行 代码。 是的。将在中打开目录的 甚小码 并加载解决方案。 这是我们刚才创建的解决方案结构。 我们还添加了 程序.cs ， Orleans鞋类包装 ， 冰谷 和 迎宾粮 分别指向接口和Grain项目的文件，以下是这些文件的代码： igreetinggrain.cs 以下内容： using System; using System.Threading.Tasks; using Orleans; namespace OrleansGrainInterfaces { public interface IGreetingGrain : IGrainWithGuidKey { Task<string> SayHello(string name); } } GreetingGrain.cs 以下内容： using System; using System.Threading.Tasks; using OrleansGrainInterfaces; namespace OrleansGrains { public class GreetingGrain : Grain, IGreetingGrain { public Task<string> SayHello(string name) { return Task.FromResult($\"Hello from Orleans, {name}\"); } } } OrleanshostWrapper.cs 以下内容： using System; using System.Net; using Orleans.Runtime; using Orleans.Runtime.Configuration; using Orleans.Runtime.Host; namespace OrleansSilo { public class OrleansHostWrapper { private readonly SiloHost siloHost; public OrleansHostWrapper(ClusterConfiguration config) { siloHost = new SiloHost(Dns.GetHostName(), config); siloHost.LoadOrleansConfig(); } public int Run() { if (siloHost == null) { return 1; } try { siloHost.InitializeOrleansSilo(); if (siloHost.StartOrleansSilo()) { Console.WriteLine($\"Successfully started Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); return 0; } else { throw new OrleansException($\"Failed to start Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); } } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } public int Stop() { if (siloHost != null) { try { siloHost.StopOrleansSilo(); siloHost.Dispose(); Console.WriteLine($\"Orleans silo '{siloHost.Name}' shutdown.\"); } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } return 0; } } } 程序.cs (silos)： using System; using System.Collections.Generic; using System.Linq; using System.Net; using Orleans.Runtime.Configuration; namespace OrleansSilo { public class Program { private static OrleansHostWrapper hostWrapper; static int Main(string[] args) { int exitCode = InitializeOrleans(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); exitCode += ShutdownSilo(); return exitCode; } private static int InitializeOrleans() { var config = new ClusterConfiguration(); config.Globals.DataConnectionString = \"[AZURE STORAGE CONNECTION STRING HERE]\"; config.Globals.DeploymentId = \"Orleans-Docker\"; config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable; config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable; config.Defaults.PropagateActivityId = true; config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any, 10400); config.Defaults.Port = 10300; var ips = Dns.GetHostAddressesAsync(Dns.GetHostName()).Result; config.Defaults.HostNameOrIPAddress = ips.FirstOrDefault()?.ToString(); hostWrapper = new OrleansHostWrapper(config); return hostWrapper.Run(); } private static int ShutdownSilo() { if (hostWrapper != null) { return hostWrapper.Stop(); } return 0; } } } 程序.cs (客户)： using System; using System.Net; using System.Threading; using System.Threading.Tasks; using Orleans; using Orleans.Runtime.Configuration; using OrleansGrainInterfaces; namespace OrleansClient { class Program { private static IClusterClient client; private static bool running; static void Main(string[] args) { Task.Run(() => InitializeOrleans()); Console.ReadLine(); running = false; } static async Task InitializeOrleans() { var config = new ClientConfiguration(); config.DeploymentId = \"Orleans-Docker\"; config.PropagateActivityId = true; var hostEntry = await Dns.GetHostEntryAsync(\"orleans-silo\"); var ip = hostEntry.AddressList[0]; config.Gateways.Add(new IPEndPoint(ip, 10400)); Console.WriteLine(\"Initializing...\"); client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); running = true; Console.WriteLine(\"Initialized!\"); var grain = client.GetGrain<IGreetingGrain>(Guid.Empty); while(running) { var response = await grain.SayHello(\"Gutemberg\"); Console.WriteLine($\"[{DateTime.UtcNow}] - {response}\"); await Task.Delay(1000); } client.Dispose(); } } } 我们不在这里详细讨论grain实现，因为它超出了本文的范围。请检查其他相关文件。这些文件本质上是一个最小的Orleans应用程序，我们将从它开始，继续本文的其余部分。 注意 ：在本文中，我们使用 奥利安萨祖鲁提尔 会员资格提供商，但您可以使用Orleans已经支持的任何其他服务。 停靠文件 为了创建容器，Docker使用图像。有关如何创建自己的详细信息，可以查看 Docker文档 是的。在本文中，我们将使用 Microsoft图像 是的。基于目标和开发平台，您需要选择适当的映像。在本文中，我们使用 微软/dotnet:1.1.2-sdk 这是一个基于linux的图像。你可以用 microsoft/dotnet:1.1.2-sdk-nanoserver 以windows为例。选一个适合你需要的。 Windows用户注意事项 ：如前所述，为了跨平台，我们在本文中使用.NET Core和Orleans Technical Preview 2.0。如果要在Windows上使用Docker和完全发布的Orleans 1.4+，则需要使用基于Windows Server Core的映像，因为基于NanoServer和Linux的映像仅支持.NET Core。 Dockerfile.debug 以下内容： FROM microsoft/dotnet:1.1.2-sdk ENV NUGET_XMLDOC_MODE skip WORKDIR /vsdbg RUN apt-get update \\ && apt-get install -y --no-install-recommends \\ unzip \\ && rm -rf /var/lib/apt/lists/* \\ && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg WORKDIR /app ENTRYPOINT [\"tail\", \"-f\", \"/dev/null\"] 这个dockerfile实质上是下载并安装vsdbg调试器，并启动一个空容器，使其永远保持活动状态，这样我们在调试时就不需要拆下/拆下。 现在，对于生产，映像更小，因为它只包含.NET核心运行时，而不包含整个sdk，dockerfile更简单一些： 停靠文件 以下内容： FROM microsoft/dotnet:1.1.2-runtime WORKDIR /app ENTRYPOINT [\"dotnet\", \"OrleansSilo.dll\"] COPY . /app Docker合成 这个 docker-compose.yml文件 文件，本质上定义(在项目内)一组服务及其在服务级别上的依赖关系。每个服务包含给定容器的一个或多个实例，该实例基于您在DockerFile上选择的图像。更多关于 Docker合成 可以在上找到 Docker编写文档 是的。 对于Orleans部署，一个常见的用例是 docker-compose.yml文件 其中包含两个服务。一个给Orleanssilos，另一个给Orleans客户。客户端将依赖于silos，这意味着，它只能在silos服务启动后启动。另一种情况是添加一个存储/数据库服务/容器，例如sql server，它应该首先在客户端和silos之前启动，因此两个服务都应该依赖于它。 注意 ：在你进一步阅读(并最终疯狂阅读)之前，请注意 凹痕 事项 在里面 Docker合成 文件夹。所以如果你有什么问题就要注意了。 以下是我们将如何描述我们为本文提供的服务： docker-compose.override.yml文件 (调试)： version: '3.1' services: orleans-client: image: orleans-client:debug build: context: ./src/OrleansClient/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansClient/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro depends_on: - orleans-silo orleans-silo: image: orleans-silo:debug build: context: ./src/OrleansSilo/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansSilo/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro docker-compose.yml文件 (生产)： version: '3.1' services: orleans-client: image: orleans-client depends_on: - orleans-silo orleans-silo: image: orleans-silo 注意，在生产中，我们没有映射本地目录，也没有 生成： 行动。原因是在生产中，图像应该被构建并推送到您自己的Docker注册表中。 把所有的东西放在一起 现在我们有了运行您的Orleans应用程序所需的所有移动部件，我们将把它们放在一起，以便在Docker中运行我们的Orleans解决方案(最后！)是的。 注意 ：应在解决方案目录中执行以下命令。 首先，让我们确保从我们的解决方案还原所有的nuget包。你只需要做一次。只有在更改项目上的任何包依赖项时，才需要再次执行此操作。 #dotnet还原 现在，让我们使用 点网 像往常一样使用cli并将其发布到输出目录： #dotnet发布-o./bin/publishoutput 注意 ：我们正在使用 出版 这里不是构建，而是为了避免我们在Orleans装载dynamicaly的汇编出现问题。我们仍在寻找更好的解决办法。 随着应用程序的构建和发布，您需要构建Dockerfile映像。每个项目只需要执行一次此步骤，并且只有在更改dockerfile、docker compose或由于任何原因清理本地映像注册表时，才应再次执行此步骤。 #Docker合成生成 两种图像中使用的所有图像 停靠文件 和 docker-compose.yml文件 从注册表中提取并缓存在开发计算机上。你的形象已经建立，你都准备好了。 现在让我们运行它！ # docker-compose up -d Creating network \"orleansdocker_default\" with the default driver Creating orleansdocker_orleans-silo_1 ... Creating orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-client_1 ... Creating orleansdocker_orleans-client_1 ... done # 现在如果你运行 Docker撰写PS ，您将看到2个容器正在运行 Orleans道克 项目： # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up Windows用户注意事项 ：如果您在Windows上，并且容器使用Windows映像作为基础，则 命令 列将显示powershell相对于 尾 在*nix系统上，这样容器将保持相同的方式。 既然你已经准备好了容器，你不需要每次启动Orleans应用程序时都停止它。您只需要集成您的ide来调试以前映射到您的 docker-compose.yml文件 是的。 缩放比例 运行compose项目后，可以使用 Docker合成比例 命令： # docker-compose scale orleans-silo=15 Starting orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-silo_2 ... Creating orleansdocker_orleans-silo_3 ... Creating orleansdocker_orleans-silo_4 ... Creating orleansdocker_orleans-silo_5 ... Creating orleansdocker_orleans-silo_6 ... Creating orleansdocker_orleans-silo_7 ... Creating orleansdocker_orleans-silo_8 ... Creating orleansdocker_orleans-silo_9 ... Creating orleansdocker_orleans-silo_10 ... Creating orleansdocker_orleans-silo_11 ... Creating orleansdocker_orleans-silo_12 ... Creating orleansdocker_orleans-silo_13 ... Creating orleansdocker_orleans-silo_14 ... Creating orleansdocker_orleans-silo_15 ... Creating orleansdocker_orleans-silo_6 Creating orleansdocker_orleans-silo_5 Creating orleansdocker_orleans-silo_3 Creating orleansdocker_orleans-silo_2 Creating orleansdocker_orleans-silo_4 Creating orleansdocker_orleans-silo_9 Creating orleansdocker_orleans-silo_7 Creating orleansdocker_orleans-silo_8 Creating orleansdocker_orleans-silo_10 Creating orleansdocker_orleans-silo_11 Creating orleansdocker_orleans-silo_15 Creating orleansdocker_orleans-silo_12 Creating orleansdocker_orleans-silo_14 Creating orleansdocker_orleans-silo_13 几秒钟后，您将看到服务扩展到您请求的特定实例数。 # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up orleansdocker_orleans-silo_10 tail -f /dev/null Up orleansdocker_orleans-silo_11 tail -f /dev/null Up orleansdocker_orleans-silo_12 tail -f /dev/null Up orleansdocker_orleans-silo_13 tail -f /dev/null Up orleansdocker_orleans-silo_14 tail -f /dev/null Up orleansdocker_orleans-silo_15 tail -f /dev/null Up orleansdocker_orleans-silo_2 tail -f /dev/null Up orleansdocker_orleans-silo_3 tail -f /dev/null Up orleansdocker_orleans-silo_4 tail -f /dev/null Up orleansdocker_orleans-silo_5 tail -f /dev/null Up orleansdocker_orleans-silo_6 tail -f /dev/null Up orleansdocker_orleans-silo_7 tail -f /dev/null Up orleansdocker_orleans-silo_8 tail -f /dev/null Up orleansdocker_orleans-silo_9 tail -f /dev/null Up 注意 ：的 命令 关于这些例子的专栏显示了 尾 命令，因为我们正在使用调试器容器。如果我们在制作的话 dotnet OrleansSilo.dll 例如。 码头群 Docker集群堆栈被调用 蜂群 你可以通过阅读它找到更多 此处为文档 是的。 在 蜂群 群集，你没有任何额外的工作。当你跑的时候 Docker组合-D 在一个 蜂群 节点，它将根据配置的规则调度容器。这同样适用于其他基于swarm的服务，如 Docker数据中心 ， 天青ACS (在群模式下) AWS ECS集装箱服务 等等。你要做的就是部署你的 蜂群 在部署之前群集 停靠 Orleans申请。 注意 ：如果您使用的Docker引擎具有Swarm模式，并且已经支持 堆栈 ， 部署 和 组成 v3，部署解决方案的更好方法是 docker stack deploy-c docker-compose.yml<name> . 请记住，它需要在Docker引擎上提供V3组合文件支持，而大多数托管服务(如Azure和AWS)仍然使用V2和更旧的引擎。 谷歌Kubernetes(K8S) 如果你打算使用 库伯内特斯 要托管Orleans，可以在 OrleansContrib\\Orleans.Clustering.Kubernetes 在那里，您可以找到关于如何使用提供者无缝地在Kubernetes托管Orleans的文档和示例。 [奖励主题]在容器中调试Orleans 好吧，既然你知道如何从头开始在一个容器中运行Orleans，那么利用Docker中最重要的原则之一就很好了。容器是不可变的。而且它们在开发中应该(几乎)具有与生产中相同的映像、依赖项和运行时。这确保了良好的旧声明 “它在我的机器上工作！” 再也不会发生了。要做到这一点，你需要有一种发展的方式 里面 容器和其中包含一个调试器，该调试器附加到容器内的应用程序。 有多种方法可以使用多种工具实现这一点。在评估了几个之后，在撰写本文时，我最终选择了一个看起来更简单、在应用程序中侵入性更小的。 正如本文前面提到的，我们使用 甚小码 为了开发这个示例，下面是如何将调试器附加到容器中的orleans应用程序。 首先，在你的 .vscode代码 解决方案中的目录： tasks.json任务 以下内容： { \"version\": \"0.1.0\", \"command\": \"dotnet\", \"isShellCommand\": true, \"args\": [], \"tasks\": [ { \"taskName\": \"publish\", \"args\": [ \"${workspaceRoot}/Orleans-Docker.sln\", \"-c\", \"Debug\", \"-o\", \"./bin/PublishOutput\" ], \"isBuildCommand\": true, \"problemMatcher\": \"$msCompile\" } ] } 这个文件实际上告诉 甚小码 无论何时构建项目，它都将实际执行 出版 命令，就像我们之前手动执行的那样。 launch.json启动 以下内容： { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Silo\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansSilo.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansSilo\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-silo_1 /vsdbg/vsdbg --interpreter=vscode\" ] } }, { \"name\": \"Client\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansClient.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansClient\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-client_1 /vsdbg/vsdbg --interpreter=vscode\" ] } } ] } 现在你可以从 甚小码 (将发布)并启动silos和客户端。它将发送一个 Docker执行官 运行命令 Docker合成 服务实例/容器来启动应用程序的调试器。将调试器附加到容器，并将其用作本地运行的Orleans应用程序。现在的区别是它在容器中，完成后，只需将容器发布到注册表并在生产中的Docker主机上拉取它。"
  },
  "Documentation/deployment/troubleshooting_deployments.html": {
    "href": "Documentation/deployment/troubleshooting_deployments.html",
    "title": "排除部署故障 | Microsoft Orleans 中文文档",
    "keywords": "部署疑难解答 此页面提供了一些常规指南，用于解决部署到azure云服务时出现的任何问题。这些都是非常常见的问题需要注意。一定要检查日志以获取更多信息。 获取silounavailableexception 首先，在尝试初始化客户端之前，请检查以确保实际启动了silos。有时，silos需要很长时间才能启动，因此尝试多次初始化客户端是有益的。如果它仍然抛出异常，那么silos可能还有另一个问题。 检查silos配置并确保silos正确启动。 常见的连接字符串问题 在部署到azure时使用本地连接字符串-网站将无法连接 为silos和前端(web和worker角色)使用不同的连接字符串-网站将无法初始化客户端，因为它无法连接到silos 可以在azure门户中检查连接字符串配置。如果连接字符串设置不正确，日志可能无法正确显示。 不正确地修改配置文件 请确保在serviceDefinition.csdef文件中配置了正确的终结点，否则部署将无法工作。它将给出错误，说明它无法获取端点信息。 丢失的日志 确保连接字符串设置正确。 很可能Web角色中的web.config文件或工作角色中的app.config文件修改不正确。这些文件中的不正确版本可能导致部署问题。处理更新时要小心。 版本问题 确保解决方案中的每个项目都使用相同版本的Orleans。不这样做会导致工人角色的回收。查看日志以获取更多信息。visual studio在部署历史记录中提供了一些silos启动错误消息。 角色不断循环 检查所有适当的Orleans组件是否在解决方案中，并且 复制本地 设置为 真的 . 检查日志以查看初始化时是否存在未处理的异常。 确保连接字符串正确。 有关详细信息，请查看azure云服务疑难解答页面。 如何检查日志 使用visual studio中的云资源管理器导航到存储帐户中相应的存储表或blob。 Wadlogstable是查看日志的良好起点。 您可能只记录了错误。如果还需要信息日志，则需要修改配置以设置日志严重性级别。 编程配置： 当创建 群集配置 对象，设置 config.defaults.defaulttracelevel=严重性。信息 是的。 当创建 客户端配置 对象，设置 config.defaulttracelevel=严重性。信息 是的。 声明性配置： 添加 <tracing defaulttracelevel=“info”/> 致 orleansconfiguration.xml文件 和/或 客户端配置.xml 文件夹。 在 诊断.wadcfgx 文件中的web和worker角色，请确保设置 scheduledTransferLogLevelFilter 中的属性 原木 元素到 问询处 ，因为这是跟踪筛选的附加层，它定义将哪些跟踪发送到 瓦德洛斯泰布尔 在azure存储中。 你可以在 配置指南 是的。 与asp.net的兼容性 包含在asp.net中的razor视图引擎使用与orleans相同的代码生成程序集( Microsoft.code分析 和 微软代码分析.csharp )中。这可能会在运行时出现版本兼容性问题。 若要解决此问题，请尝试升级 Microsoft.codedom.providers.dotnetCompilerPlatform (这是ASP.NET用于包含上述程序集的NuGet包)到最新版本，并设置绑定重定向，如下所示： <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "Documentation/deployment/troubleshooting_azure_cloud_services_deployments.html": {
    "href": "Documentation/deployment/troubleshooting_azure_cloud_services_deployments.html",
    "title": "排除部署故障 | Microsoft Orleans 中文文档",
    "keywords": "部署疑难解答 此页面提供了一些常规指南，用于解决部署到azure云服务时出现的任何问题。这些都是非常常见的问题需要注意。一定要检查日志以获取更多信息。 获取silounavailableexception 在尝试初始化客户端之前，首先检查以确保实际启动了silos。有时，silos需要很长时间才能启动，因此尝试多次初始化客户端是有益的。如果它仍然抛出异常，那么silos可能还有另一个问题。 检查silos配置并确保silos正确启动。 常见的连接字符串问题 在部署到azure时使用本地连接字符串-网站将无法连接 为silos和前端(web和worker角色)使用不同的连接字符串-网站将无法初始化客户端，因为它无法连接到silos 可以在azure门户中检查连接字符串配置。如果连接字符串设置不正确，日志可能无法正确显示。 不正确地修改配置文件 请确保在serviceDefinition.csdef文件中配置了正确的终结点，否则部署将无法工作。它将给出错误，说明它无法获取端点信息。 丢失的日志 确保连接字符串设置正确。 很可能Web角色中的web.config文件或工作角色中的app.config文件修改不正确。这些文件中的不正确版本可能导致部署问题。处理更新时要小心。 版本问题 确保解决方案中的每个项目都使用相同版本的Orleans。不这样做会导致工人角色的回收。查看日志以获取更多信息。visual studio在部署历史记录中提供了一些silos启动错误消息。 角色不断循环 检查所有适当的orleans程序集是否在解决方案中，并将copy local设置为true。 检查日志以查看初始化时是否存在未处理的异常。 确保连接字符串正确。 有关详细信息，请查看azure云服务疑难解答页面。 如何检查日志 使用visual studio中的云资源管理器导航到存储帐户中相应的存储表或blob。Wadlogstable是查看日志的良好起点。 您可能只记录了错误。如果还需要信息日志，则需要修改配置以设置日志严重性级别。 编程配置： 当创建 群集配置 对象，设置 config.defaults.defaulttracelevel=严重性。信息 是的。 当创建 客户端配置 对象，设置 config.defaulttracelevel=严重性。信息 是的。 声明性配置： 添加 <tracing defaulttracelevel=“info”/> 致 orleansconfiguration.xml文件 和/或 客户端配置.xml 文件夹。 在 诊断.wadcfgx 文件中的web和worker角色，请确保设置 scheduledTransferLogLevelFilter 中的属性 原木 元素到 问询处 ，因为这是跟踪筛选的附加层，它定义将哪些跟踪发送到 瓦德洛斯泰布尔 在azure存储中。 您可以在《配置指南》中找到有关此的更多信息。 与asp.net的兼容性 包含在asp.net中的razor视图引擎使用与orleans相同的代码生成程序集( Microsoft.code分析 和 微软代码分析.csharp )中。这可能会在运行时出现版本兼容性问题。 若要解决此问题，请尝试升级 Microsoft.codedom.providers.dotnetCompilerPlatform (这是ASP.NET用于包含上述程序集的NuGet包)到最新版本，并设置绑定重定向，如下所示： <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "Documentation/deployment/handling_failures.html": {
    "href": "Documentation/deployment/handling_failures.html",
    "title": "Handling Failures | Microsoft Orleans 中文文档",
    "keywords": "处理故障 注： 本文件中提供的以下所有指导都是作为示例和思考的食粮。您不应该将它们视为解决问题的规范性解决方案，因为故障处理是一个相当特定于应用程序的主题。这些模式和其他模式只有在充分了解正在处理的具体案例的情况下才有用。 在分布式系统编程中，最困难的是处理故障。actor模型及其工作方式使处理不同类型的故障变得更加容易，但是作为开发人员，您负责处理故障可能性并以适当的方式处理它们。 故障类型 当你在编码你的Grains，所有的调用都是异步的，有可能通过网络。由于以下原因之一，每个Grains调用都可能失败。 Grains是在silos上激活的，由于网络分区崩溃或其他原因，silos目前不可用。如果silos尚未声明为已死亡，则您的请求可能会超时。 grain方法调用可以抛出异常，表示它失败，无法继续其工作。 粒子的激活不存在，不能创建，因为 OnActivateAsync 方法引发异常或被死锁。 网络故障不允许您在超时前与grain通信。 其他潜在原因 故障检测 获取对Grains的引用总是成功的，并且是一个本地操作。然而，方法调用可能会失败，当它们失败时，您会得到一个异常。您可以在需要的任何级别捕获异常，它们甚至可以跨Silo传播。 从失败中恢复 在Orleans，恢复工作的一部分是自动的，如果一个grain不再可访问，Orleans将在下一个方法调用中重新激活它。需要处理并确保在应用程序上下文中正确无误的是状态。一个Grains的状态可以部分更新，或者操作可能是一些应该跨多个Grains执行的部分操作。 当你看到一个Grains操作失败后，你可以做以下一个或多个操作。 只需重试您的操作，特别是如果它不涉及任何状态更改，这可能是半个完成。这是目前为止最典型的案例。 尝试通过调用一个方法来修复/重置部分更改的状态，该方法将状态重置为最后一个已知的正确状态，或者通过调用 读状态异步 是的。 重置所有相关激活的状态，以确保所有激活都处于干净状态。 使用 过程经理 或数据库事务，以确保完全完成或不做任何更改以避免部分更新状态。 根据应用程序的不同，重试逻辑可能遵循简单或复杂的模式，您可能需要执行其他操作，如通知外部系统和其他操作，但通常，您要么必须重试操作，重新启动所涉及的Grain/Grain，要么停止响应，直到不可用的内容变为可用。 如果您有一个负责数据库保存的grain，而数据库不可用，那么您只需使任何请求失败，直到数据库重新联机。如果可以根据用户的意愿重试您的操作，例如在注释grains中保存注释失败，则可以在用户按下重试按钮时重试(直到达到一定次数，以避免网络饱和)。如何做到这一点的具体细节取决于应用程序，但可能的策略是相同的。 策略参数与策略选择 如上一节所述，您选择的策略取决于应用程序和上下文。策略通常具有必须在应用程序级别决定的参数。例如，如果没有其他进程依赖于一个动作，那么您可能决定重试该动作最多每分钟5次，直到它最终完成为止。但在处理来自该用户的任何其他请求之前，必须先处理该用户的登录Grain请求。如果登录操作不起作用，则无法继续。 有个向导 在azure文档中 关于云的良好模式和实践，在大多数情况下也适用于Orleans。 一个相当复杂的例子 因为在OrleansGrains是自动激活和停用的，你不能处理它们的生命周期，你通常只处理确保Grains状态是正确的，行动是正确的开始和结束相互关系。了解grains和它们执行的动作之间的依赖关系是理解如何在任何复杂系统中处理故障的重要一步。如果你需要储存Grains之间的关系，你可以简单地这样做，这也是一个广泛遵循的做法。 举个例子，假设我们有一个 游戏管理器 起止粮 游戏 Grains和添加剂 玩家 去看比赛。如果我的 游戏管理器 Grains没有做它关于开始一个游戏的动作，属于它的相关游戏应该没有做它的 开始() 经理也可以通过编排来完成这项工作。在Orleans管理内存是自动的，系统会处理它，你只需要确保游戏开始，并且只有当经理能做到 开始() 也。您可以通过以顺序方式调用相关的方法，或者通过并行执行这些方法，并在其中任何一个方法失败时重置所有相关grains的状态来实现这一点。 如果其中一个游戏收到一个调用，它将自动重新激活，因此，如果您需要管理者管理游戏Grains，那么所有与管理相关的对游戏的调用都应该通过 游戏管理器 是的。如果你需要在Grains之间进行配器，Orleans不会为你“自动”解决，你需要做你的配器。但事实上，你没有处理创建/销毁Grains的问题，这意味着你不需要担心资源管理。你不需要回答这些问题： 我应该在哪里创建我的监督树？ 我应该注册哪些Grains才能按名称寻址？ 谷粒x还活着所以我可以给它发个信息吗？ … 所以，游戏开始的例子可以总结如下： 游戏管理器 问 游戏 开始的Grains 游戏 Grains加上 玩家 Grains自身 游戏 问 玩家 为自己添加游戏的Grains 游戏 将其状态设置为启动。 游戏管理器 将游戏添加到其游戏列表中。 现在，如果一个玩家未能将游戏添加到自身中，则不需要杀死所有玩家和游戏并重新开始。您只需重置将游戏添加到自己的其他玩家的状态，重置 游戏 和 游戏管理器 (如果需要的话)，重做你的工作或宣布失败。如果您可以在以后将游戏添加到玩家中，则可以在提醒或其他游戏访问(如 完成() 游戏方法。"
  },
  "Documentation/deployment/azure_web_apps_with_azure_cloud_services.html": {
    "href": "Documentation/deployment/azure_web_apps_with_azure_cloud_services.html",
    "title": "使用Azure Web Apps和Azure Cloud Services | Microsoft Orleans 中文文档",
    "keywords": "将azure web应用与azure云服务一起使用 如果你想从 azure web应用 而不是托管在同一个云服务中的web角色。 要使其安全工作，您需要将azure web应用和托管silos的工作角色都分配给 azure虚拟网络 是的。 首先，我们将设置azure web应用程序，您可以跟随 本指南 它将创建虚拟网络并将其分配给azure web应用程序。 现在我们可以通过修改 服务配置 文件。 <NetworkConfiguration> <VirtualNetworkSite name=\"virtual-network-name\" /> <AddressAssignments> <InstanceAddress roleName=\"role-name\"> <Subnets> <Subnet name=\"subnet-name\" /> </Subnets> </InstanceAddress> </AddressAssignments> </NetworkConfiguration> 还要确保已配置silos终结点。 <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> 现在您可以从web应用连接到集群的其余部分。 潜在问题 如果Web应用无法连接到silos： 确保你至少有 两个角色 ，或者在你的azure云服务中一个角色的两个实例，或者 内部终结点 不能生成防火墙规则。 检查Web应用程序和silos是否使用相同的 棒状的 和 服务ID 是的。 确保网络安全组设置为允许内部虚拟网络连接。如果您没有一个，您可以创建和分配一个很容易使用以下 PowerShell 以下内容： New-AzureNetworkSecurityGroup -Name \"Default\" -Location \"North Europe\" Get-AzureNetworkSecurityGroup -Name \"Default\" | Set-AzureNetworkSecurityGroupToSubnet -VirtualNetworkName \"virtual-network-name\" -SubnetName \"subnet-name\""
  },
  "Documentation/deployment/consul_deployment.html": {
    "href": "Documentation/deployment/consul_deployment.html",
    "title": "Using Consul as a Membership Provider | Microsoft Orleans 中文文档",
    "keywords": "使用consul作为成员资格提供程序 领事介绍 领事 是一个分布式、高可用和数据中心感知的服务发现平台，包括简单的服务注册、运行状况检查、故障检测和密钥/值存储。它是在数据中心的每个节点都运行一个consu代理的前提下构建的，consun代理可以充当服务器，也可以作为客户端，通过一个可伸缩的八卦协议进行通信。 consul有一个非常详细的概述，包括与类似解决方案的比较 在这里 是的。 执政官写的是go 开源 ；编译的下载可用于 Mac OS X、FreeBSD、Linux、solaris和Windows 为什么选择领事？ 作为 Orleans会员服务商 ，当您需要提供 内部解决方案 这并不要求潜在客户拥有现有的基础设施。 和 一家合作的it提供商。consul是一个非常轻量级的单一可执行文件，没有依赖关系，因此可以很容易地构建到您自己的中间件解决方案中。当consul已经是您发现、检查和维护微服务的解决方案时，完全集成orleans成员关系以简化操作是有意义的。因此，我们在consul(也称为“orleans custom system store”)中实现了一个成员表，它与orleans的 群集管理 是的。 设立领事 有很多关于 IO领事 关于建立一个稳定的领事集群，在这里重复是没有意义的；但是为了您的方便，我们提供了这个指南，这样您可以很快让Orleans运行一个独立的领事代理。 1)创建一个文件夹以将consul安装到其中，例如c:\\ consul 2)创建子文件夹：C:\\Cuxel\\Data(如果不存在，Cuxl将不创建此文件) 三) 下载 并将consul.exe解压到c:\\ consul\\ 4)在C:\\ consul打开命令提示符\\ 5)进入 consun.exe代理-服务器-引导-数据目录“C:\\ consun\\data”-客户端=0.0.0.0 代理人 指示consul运行托管服务的代理进程。如果不这样做，consul进程将尝试使用rpc来配置正在运行的代理。 -服务器 将代理定义为服务器而不是客户端(consul 客户 是托管所有服务和数据的代理，但没有投票权来决定，并且不能成为群集的领导者 -自举 第一个(而且只有第一个！)必须引导群集中的节点，使其承担群集领导地位。 -数据目录[路径] 指定存储所有consun数据的路径，包括cluster membership表 -客户端=0.0.0.0 通知领事在哪个IP上打开服务。 还有许多其他参数，以及使用json配置文件的选项。有关选项的完整列表，请参阅consul文档。 6)通过打开 服务 浏览器中的终结点。 Orleans的结构 服务器 “自定义”成员资格提供程序orleansconfiguration.xml配置文件当前存在一个已知问题，无法正确解析该文件。因此，在启动silos之前，必须在XML中提供一个占位符SystemStore，然后在代码中配置提供程序。 orleansconfiguration.xml文件 <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"None\" DataConnectionString=\"http://localhost:8500\" DeploymentId=\"MyOrleansDeployment\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"22222\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> 代码 public void Start(ClusterConfiguration config) { _siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); _siloHost.Config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.Custom; _siloHost.Config.Globals.MembershipTableAssembly = \"OrleansConsulUtils\"; _siloHost.Config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.Disabled; _siloHost.InitializeOrleansSilo(); var startedok = _siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", _siloHost.Name, _siloHost.Type)); Log.Information(\"Orleans Silo is running.\\n\"); } 或者，您可以完全用代码配置silos。 顾客 客户端配置要简单得多 客户端配置.xml <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"Custom\" CustomGatewayProviderAssemblyName=\"OrleansConsulUtils\" DataConnectionString=\"http://192.168.1.26:8500\" DeploymentId=\"MyOrleansDeployment\" /> </ClientConfiguration> 客户端sdk 如果您有兴趣使用领事馆为您自己的服务发现有 客户SDK 最流行的语言。 实施细节 成员资格表提供程序使用 领事钥匙/价值商店 cas的功能。当每个silos启动时，它会注册两个KV条目，一个包含silos的详细信息，另一个保存silos上次报告它处于活动状态时的信息(后者是指诊断“I am alive”条目，而不是指直接在silos之间发送且未写入表中的故障检测Hearbeats)。根据orleans的需要，对表的所有写操作都由cas执行，以提供并发控制。 群集管理协议 是的。silos运行后，您可以在Web浏览器中查看这些条目 在这里 ，将显示如下内容： [ \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753\", \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753/iamalive\" ] 您会注意到这些键的前缀是 “Orleans/” 这是在提供者中硬编码的，旨在避免与consul的其他用户发生密钥空间冲突。每个键都可以通过附加它们的键名来读取 (当然没有引用) 致 领事KV根 是的。这样做将为您提供以下信息： [ { \"LockIndex\": 0, \"Key\": \"orleans/MyOrleansDeployment/192.168.1.26:22222@191780753\", \"Flags\": 0, \"Value\": \"[BASE64 UTF8 Encoded String]\", \"CreateIndex\": 10, \"ModifyIndex\": 12 } ] 解码字符串将提供实际的Orleans成员资格数据： http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress ] { \"Hostname\": \"[YOUR_MACHINE_NAME]\", \"ProxyPort\": 22222, \"StartTime\": \"2016-01-29T16:25:54.9538838Z\", \"Status\": 3, \"SuspectingSilos\": [] } http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress]/IAmAlive \"2016-01-29T16:35:58.9193803Z\" 当客户端连接时，他们通过使用uri在一个http get中读取集群中所有silos的kvs http://192.168.1.26:8500/v1/kv/orleans/myorleansdeployment/？递归 是的。 限制 Orleans扩展成员协议(表版本和ETag) consul kv currently目前不支持原子更新。因此，orleans consul成员资格提供者只实现了orleans基本成员资格协议，如前所述 在这里 不支持扩展成员身份协议。这个扩展的协议被引入作为一个额外的，但不是必需的，silos连通性验证和作为尚未实现的功能的基础。如果您的基础设施配置正确，您将不会因缺乏支持而受到任何不利影响。 多个数据中心 consun中的键值对当前未在consun数据中心之间复制。有一个 单独项目 为了解决这个问题，但它还没有被证明支持Orleans。 在Windows上运行时 当consul在windows上启动时，它会记录以下消息： ==> WARNING: Windows is not recommended as a Consul server. Do not use in production. 这仅仅是因为在windows环境中运行时缺乏对测试的关注，而不是因为任何实际的已知问题。阅读 此处讨论 在决定领事是否适合你之前。 未来的潜在增强 1)证明consun-kv复制项目能够在多个consun数据中心之间的广域网环境中支持一个orleans集群。 2)在领事馆执行提醒表。 3)实现扩展成员协议。consul背后的团队确实计划实现原子操作，一旦此功能可用，就可以消除提供者中的限制。"
  },
  "Documentation/deployment/service_fabric_hosting.html": {
    "href": "Documentation/deployment/service_fabric_hosting.html",
    "title": "Service Fabric Hosting | Microsoft Orleans 中文文档",
    "keywords": "服务结构宿主 Orleans可以使用 Microsoft.Orleans.hosting.ServiceFabric 包裹。silos应该作为未分区的无状态服务托管，因为Orleans使用细Grain的动态分布来管理Grains本身的分布。其他托管选项(分区的、有状态的)当前未经测试且不受支持。 一个演示在服务结构上托管的示例位于 示例/2.0/ServiceFabric 是的。 托管支持在 Microsoft.Orleans.hosting.ServiceFabric 包裹。它允许Orleanssilos作为服务结构运行 图像通信侦听器 是的。silos生命周期遵循典型的通信侦听器生命周期：它通过 ICommunicationListener.OpenAsync 方法，并通过 ICommunicationListener.CloseAsync 方法或通过 ICommunication侦听器。中止 方法。 OrleansCommunication侦听器 提供 图像通信侦听器 实施。推荐的方法是使用 orleansServiceListener.createStateless(操作<statelessServiceContext，isiloHostBuilder>configure) 在 Orleans.Hosting.ServiceFabric 命名空间。 每次打开通信侦听器时， 配置 委托传递给 创建无状态 调用以配置新silos。 示例：配置服务结构宿主 下面的示例演示了一个服务结构 无状态服务 类，该类托管Orleanssilos。完整的样本可以在 示例/2.0/ServiceFabric Orleans仓库的目录。 /// <summary> /// An instance of this class is created for each service instance by the Service Fabric runtime. /// </summary> internal sealed class StatelessCalculatorService : StatelessService { public StatelessCalculatorService(StatelessServiceContext context) : base(context) { } /// <summary> /// Optional override to create listeners (e.g., TCP, HTTP) for this service replica to handle /// client or user requests. /// </summary> /// <returns>A collection of listeners.</returns> protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners() { // Listeners can be opened and closed multiple times over the lifetime of a service instance. // A new Orleans silo will be both created and initialized each time the listener is opened // and will be shutdown when the listener is closed. var listener = OrleansServiceListener.CreateStateless( (fabricServiceContext, builder) => { builder.Configure<ClusterOptions>(options => { // The service id is unique for the entire service over its lifetime. This is // used to identify persistent state such as reminders and grain state. options.ServiceId = fabricServiceContext.ServiceName.ToString(); // The cluster id identifies a deployed cluster. Since Service Fabric uses rolling // upgrades, the cluster id can be kept constant. This is used to identify which // silos belong to a particular cluster. options.ClusterId = \"development\"; }); // Configure clustering. Other clustering providers are available, but for the purpose // of this sample we will use Azure Storage. // TODO: Pick a clustering provider and configure it here. builder.UseAzureStorageClustering( options => options.ConnectionString = \"UseDevelopmentStorage=true\"); // Optional: configure logging. builder.ConfigureLogging(logging => logging.AddDebug()); builder.AddStartupTask<StartupTask>(); // Service Fabric manages port allocations, so update the configuration using those // ports. // Gather configuration from Service Fabric. var activation = fabricServiceContext.CodePackageActivationContext; var endpoints = activation.GetEndpoints(); // These endpoint names correspond to TCP endpoints specified in ServiceManifest.xml var siloEndpoint = endpoints[\"OrleansSiloEndpoint\"]; var gatewayEndpoint = endpoints[\"OrleansProxyEndpoint\"]; var hostname = fabricServiceContext.NodeContext.IPAddressOrFQDN; builder.ConfigureEndpoints(hostname, siloEndpoint.Port, gatewayEndpoint.Port); // Add your application assemblies. builder.ConfigureApplicationParts(parts => { parts.AddApplicationPart(typeof(CalculatorGrain).Assembly).WithReferences(); // Alternative: add all loadable assemblies in the current base path // (see AppDomain.BaseDirectory). parts.AddFromApplicationBaseDirectory(); }); }); return new[] { listener }; } /// <summary> /// This is the main entry point for your service instance. /// </summary> /// <param name=\"cancellationToken\"> /// Canceled when Service Fabric needs to shut down this service instance. /// </param> protected override async Task RunAsync(CancellationToken cancellationToken) { while (true) { cancellationToken.ThrowIfCancellationRequested(); await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken); } } }"
  },
  "Documentation/tutorials_and_samples/MathGrains.html": {
    "href": "Documentation/tutorials_and_samples/MathGrains.html",
    "title": "MathGrains | Microsoft Orleans 中文文档",
    "keywords": "MathGrains 将功能封装到专用Grain中的计算器。"
  },
  "Documentation/implementation/load_balancing.html": {
    "href": "Documentation/implementation/load_balancing.html",
    "title": "Load Balancing | Microsoft Orleans 中文文档",
    "keywords": "负载均衡 从广义上讲，负载平衡是Orleans运行时的支柱之一 。Orleans运行时会尝试使所有内容保持平衡，因为平衡可以最大程度地利用资源并避免出现热点，从而提高性能，并有助于提高弹性。Orleans的负载平衡适用于多个地方。以下是运行时进行平衡的地方的非详尽列表： 默认的演员存储策略是随机的 -新的激活随机分布在各个孤岛中。这样可以在大多数情况下平衡存储并防止出现热点。 更高级 ActivationCountPlacement 尝试使所有silos上的激活次数相等，从而导致各个silos上的激活分布更加均匀。这对于弹性尤其重要。 Grains目录服务 在分布式哈希表的顶部构建，该哈希表本质上是平衡的。目录服务将Grains映射到激活，每个silos都拥有全局映射表的一部分，并且该表以平衡的方式在所有silos中进行全局分区。为此，我们将一致的哈希与虚拟存储桶一起使用。 客户端连接到所有 网关 并平衡地分散他们的要求。 提醒服务 是分布式分区运行时服务。就像粮仓目录中一样，哪个silos的分配负责服务哪个提醒，并通过一致的哈希在所有silos之间进行平衡。 silos中对性能至关重要的组件进行了分区，并且它们之间的工作是本地平衡的 。这样，孤岛运行时可以充分利用所有可用的CPU内核，而不会造成孤岛瓶颈。这适用于所有本地资源：将工作分配给线程，套接字，调度责任，队列等。 StreamQueueBalance 平衡了从持久化队列中跨集群中各个孤岛提取事件的责任。 另请注意 从广义上讲，平衡并不一定意味着失去局域性 。一个可以保持平衡，并且仍然保持良好的位置。例如，当平衡意味着分片/分区时，您可以对某个逻辑任务进行分区，同时仍保持每个分区内的局部性。这适用于本地和分布式平衡。 请参阅此演示文稿 Orleans的平衡技术 更多细节。"
  },
  "Documentation/implementation/streams_implementation.html": {
    "href": "Documentation/implementation/streams_implementation.html",
    "title": "Streams Implementation Details | Microsoft Orleans 中文文档",
    "keywords": "Orleans流实施细节 本节提供了Orleans Stream实施的高级概述。它描述了在应用程序级别上不可见的概念和细节。如果仅计划使用流，则不必阅读本节。 术语 ： 我们用“队列”一词来指代任何可以吸收流事件并允许提取事件或提供基于推送的机制来使用事件的持久存储技术。通常，为了提供可伸缩性，这些技术提供了分片/分区队列。例如，Azure队列允许创建多个队列，事件中心具有多个中心，Kafka主题，... 持久流 所有Orleans持久流提供者共享一个共同的实现 PersistentStreamProvider 。该通用流提供者需要配置有特定于技术的 IQueueAdapterFactory 。 例如，出于测试目的，我们有队列适配器，它们生成自己的测试数据，而不是从队列中读取数据。下面的代码显示了我们如何配置持久流提供程序以使用我们的自定义(生成器)队列适配器。它通过使用用于创建适配器的工厂功能配置持久流提供程序来实现。 hostBuilder.AddPersistentStreams(StreamProviderName, GeneratorAdapterFactory.Create); 当流生产者生成新的流项目并调用时 stream.OnNext() ，Orleans Streaming Runtime在上调用适当的方法 IQueueAdapter 该流提供程序将条目直接排队到适当的队列中。 牵引剂 持久流提供者的核心是拉动代理。拉动代理程序从一组持久队列中拉出事件，然后将事件以消耗它们的方式传递给应用程序代码。可以将拉动代理视为一种分布式“微服务”，即一种分区的，高度可用的弹性分布式组件。拉动代理在托管应用程序Grain的相同silos中运行，并由Orleans Streaming Runtime完全管理。 StreamQueueMapper和StreamQueueBalancer 牵引剂的参数设置为 IStreamQueueMapper 和 IStreamQueueBalancer 。 IStreamQueueMapper 提供所有队列的列表，还负责将流映射到队列。这样，持久流提供者的生产者方就知道将消息放入哪个队列中。 IStreamQueueBalancer 表示队列在Orleanssilos和特工之间平衡的方式。目标是以平衡的方式为代理分配队列，以防止瓶颈并支持弹性。将新的silos添加到Orleans集群后，新旧silos之间的队列会自动重新平衡。StreamQueueBalancer允许自定义该过程。Orleans具有许多内置的StreamQueueBalancers，以支持不同的平衡方案(队列数量大而少)和不同的环境(Azure，Prem，静态)。 使用上面的测试生成器示例，以下代码显示了如何配置队列映射器和队列平衡器。 hostBuilder .AddPersistentStreams(StreamProviderName, GeneratorAdapterFactory.Create, providerConfigurator=>providerConfigurator .Configure<HashRingStreamQueueMapperOptions>(ob=>ob.Configure( options=>{ options.TotalQueueCount = 8; })) .UseDynamicClusterConfigDeploymentBalancer() ); 上面的代码将GeneratorAdapter配置为使用具有8个队列的队列映射器，并使用 DynamicClusterConfigDeploymentBalancer 。 拉协议 每个silos都运行一组拉动代理，每个代理都从一个队列中拉出。拉动代理程序本身由内部运行时组件(称为 SystemTarget 。SystemTargets本质上是运行时Grain，受单线程并发性的影响，可以使用常规的Grain消息传递，并且轻巧。与Grains相反，SystemTarget不是虚拟的：它们是由运行时显式创建的，并且位置不透明。通过将拉动代理实现为SystemTargets，Orleans Streaming Runtime可以依赖于内置的Orleans功能并可以扩展到大量队列，因为创建新的拉动代理与创建新的Grains一样便宜。 每个拉动代理都运行一个定期计时器，该定时从队列中拉出(通过调用 IQueueAdapterReceiver ) GetQueueMessagesAsync() 方法。返回的消息放在内部的每个代理的数据结构中，称为 IQueueCache 。检查每个消息以找出其目标流。代理使用Pub Sub来查找订阅此流的流使用者列表。检索到使用者列表后，代理会将其存储在本地(在其pub-sub缓存中)，因此无需在每条消息上都与Pub Sub进行协商。代理还订阅pub-sub，以接收有关订阅该流的任何新使用者的通知。代理与pub-sub保证之间的这种握手 强大的流订阅语义 ： 消费者订阅了流之后，它将看到订阅后生成的所有事件 。另外，使用 StreamSequenceToken 允许其过去订阅。 队列缓存 IQueueCache 是内部的每个代理程序数据结构，该结构允许将新事件从队列中分离出来并将它们传递给使用者。它还允许将传递到不同流和不同消费者的耦合解耦。 想象这样一种情况，其中一个流有3个流使用者，其中一个很慢。如果不注意，这种缓慢的使用者可能会影响代理的进度，减慢该流的其他使用者的消耗，甚至减慢其他流的事件的出队和传递。为了避免这种情况并允许代理中的最大并行度，我们使用 IQueueCache 。 IQueueCache 缓冲流事件，并为代理提供一种以自己的节奏将事件传递给每个使用者的方式。每个消费者的交付都是通过内部组件实现的 IQueueCacheCursor ，它跟踪每个消费者的进度。这样，每个使用者就可以按照自己的节奏接收事件：快速的使用者在从队列中出队后就可以尽快接收事件，而较慢的使用者则在以后接收事件。一旦消息传递给所有使用者，就可以从缓存中将其删除。 背压 Orleans流运行时中的背压在两个地方适用： 将流事件从队列带到代理 和 将事件从代理传递到流消费者 。 后者由内置的Orleans消息传递机制提供。每个流事件都通过标准的OrleansGrains消息传递一次从代理传递到消费者。也就是说，代理将一个事件(或数量有限的事件)发送给每个单独的流使用者，并等待此访问。在解决或破坏上一个事件的任务之前，下一个事件将不会开始传递。这样一来，我们自然会将每次消费者的投放速度限制为一次只发送一条消息。 关于将流事件从队列传递到代理，Orleans Streaming提供了一种新的特殊背压机制。由于代理将事件的出队从队列中解耦并传递给使用者，因此单个缓慢的使用者可能会落后很多，以至于 IQueueCache 将填满。阻止 IQueueCache 为了避免无限期增长，我们限制了它的大小(大小限制是可配置的)。但是，代理永远不会丢弃未交付的事件。相反，当缓存开始填满时，代理会减慢事件从队列中出队的速度。这样，我们可以通过调整从队列中消耗的速率(“背压”)来“摆脱”缓慢的交付周期，然后稍后恢复为快速的消耗速率。要检测“缓慢投放”的山谷 IQueueCache 使用高速缓存存储区的内部数据结构来跟踪将事件交付给各个流使用者的进度。这导致了一个非常敏感和自我调整的系统。"
  },
  "Documentation/implementation/scheduler.html": {
    "href": "Documentation/implementation/scheduler.html",
    "title": "Scheduler | Microsoft Orleans 中文文档",
    "keywords": "排程器 Orleans Scheduler是Orleans运行时中的一个组件，负责执行应用程序代码和部分运行时代码，以确保 单线程执行语义 。它实现了自定义的TPL任务计划程序。 Orleans任务计划程序是一个2级层次的计划程序。在第一层是全球 OrleansTaskScheduler 负责执行系统活动。在第二级，每个Grains活化都有自己的 ActivationTaskScheduler ，它提供了单线程执行语义。 从高层次上讲，执行路径如下： 请求到达正确的silos，并找到目标激活。 请求在其ActivationTaskScheduler上转换为一个任务，排队等待该激活执行。 通过标准TaskScheduler机制，作为谷类方法执行的一部分而创建的任何后续Task都会自然地排队到同一ActivationTaskScheduler中。 每个ActivationTaskScheduler都有一个排队等待执行的任务队列。 Orleans Scheduler具有一组由所有激活调度程序共同使用的工作线程。这些线程定期扫描所有调度程序队列以执行工作。 线程接受一个队列(每个队列一次由一个线程接受)并开始按FIFO顺序在该队列中执行Tasks。 一次将一个线程排入队列，然后依次执行Tasks的线程的组合提供了单线程执行语义。 工作项目： Orleans使用工作项的概念来指定调度程序的入口点。最初，每个新请求都作为工作项入队，该工作项仅包装该请求的第一个任务的执行。工作项只是提供有关调度活动的更多上下文信息(调用方，活动的名称，日志记录)，有时还需要代表该调度活动进行一些额外的工作(Invoke工作项中的调用后活动)。当前有以下工作项类型：1.调用工作项–这是最常用的工作项类型。它表示应用程序请求的执行。2.请求/响应工作项–执行系统请求(对SystemTarget的请求)。3. TaskWorkItem –代表排队到最高OrleansTaskScheduler的任务。只是为了方便数据结构而使用它而不是直接任务(下面有更多详细信息)。4. WorkItemGroup –共享同一调度程序的工作项组。用于为每个ActivationTaskScheduler包装任务队列。5. ClosureWorkItem –封装在排队到系统上下文的闭包(任意lambda)周围的包装器。 调度上下文： 调度上下文是一个标签，只是一个不透明的对象，代表调度目标–激活数据，系统目标或系统空上下文。 高级原则： 任务总是排队到正确的调度程序 1.1任务永远不会从一个调度程序转移到另一个调度程序。 1.2我们绝不会代表其他任务创建任务来执行它们。 1.3工作项包装在Task中(也就是说，为了执行工作项，我们创建了一个Task，其lambda函数将仅运行工作项lambda)。通过始终执行任务，我们确保通过适当的任务计划程序执行任何活动。 使用base.TryExecute(而不是RunSynchronously)在计划了队列的调度程序上执行任务 ATS，WorkItem组和调度上下文之间存在一对一的映射： 3.1激活任务计划程序(ATS)是自定义的TPL计划程序。我们保持ATS稀薄，并将所有数据存储在WorkItemGroup中。ATS指向其WorkItemGroup。 3.2 WorkItem组是激活任务的实际持有人(数据对象)。任务存储在列表中 -ATS的所有任务的队列。WorkItemGroup指向其ATS。 数据流以及任务和工作项的执行： 入口点始终是排队到OrleansTaskScheduler中的工作项。它可以是“调用/请求/响应/关闭工作项”之一。 根据Task.Start的上下文包装到Task中，并放入正确的ActivationTaskScheduler中。 排队到其ActivationTaskScheduler的任务被放入WorkItemGroup队列。 将任务放入WorkItemGroup队列时，WorkItemGroup确保将其显示在OrleansTaskScheduler全局RunQueue中。RunQueue是可运行的WorkItemGroups的全局队列，这些队列中至少有一个Task已排队，因此可以执行。 辅助线程扫描OrleansTaskScheduler的RunQueue，该队列保存WorkItemGroups并调用WorkItemGroups.Execute。 WorkItemGroups.Execute扫描其任务队列，并通过ActivationTaskScheduler.RunTask(Task)执行它们 6.1 ActivationTaskScheduler.RunTask(Task)调用base.TryExecute。 6.2通过TPL直接排队到调度程序的任务将立即执行。 6.3包装工作项的任务将调用workItem.Execute，它将执行Closure工作项委托。 低层设计–工作项目： 在OrleansTaskScheduler中排队工作项是如何在Orleans运行时中开始每个请求的整个执行链的。这是我们进入调度程序的入口。 工作项首先提交给OrleansTaskScheduler(因为这是呈现给系统其余部分的接口)。 2.1这样只能提交关闭/调用/恢复工作项目。 2.2无法将TaskWorkItem直接提交给OrleansTaskScheduler(有关处理TaskWorkItem的更多信息，请参见下文)。 每个工作项都必须包装到Task中，并通过Task.Start排队到正确的调度程序中。 3.1这将确保在执行此workItem期间隐式创建的任何Task上正确设置TaskScheduler.Current。 3.2包装是通过WrapWorkItemAsTask创建一个Task来完成的，该Task将执行工作项，并通过Task.Start(scheduler)将其排队到正确的调度程序中。 3.3空上下文的工作项将排队到OrleansTaskScheduler。 3.4非空上下文的工作项将排队到ActivationTaskScheduler中。 低层设计–排队任务： 任务直接排队到正确的调度程序中 1.1任务由TPL通过受保护的重写void QueueTask(任务任务)隐式排队。 1.2具有非空上下文的任务始终排队到ActivationTaskScheduler中 1.3具有空上下文的任务始终排队到OrleansTaskScheduler 将任务排队到ActivationTaskScheduler： 2.1我们绝不会将一个任务包装在另一个任务中。任务被直接添加到工作项组队列中 向OrleansTaskScheduler排队任务： 3.1当Task排入OrleansTaskScheduler时，我们将其包装到TaskWorkItem中，并将其放入此计划程序的工作项队列中。 3.2这仅是数据结构问题，无任何内在因素： 3.3 OrleansTaskScheduler通常保存工作项组以安排它们，因此其RunQueue具有BlockingCollection 。 3.4由于空上下文的任务也排队到OrleansTaskScheduler中，因此我们重复使用相同的数据结构，因此必须将每个Task包装在TaskWorkItem中。 3.5我们应该能够通过调整RunQueue数据结构完全摆脱这种包装。这可以稍微简化代码，但通常不重要。而且，将来无论如何我们都应该离开null上下文，所以无论如何这个问题都将消失 内联任务： 由于任务总是排队在正确的调度程序上，因此从理论上讲，内联任何任务应该总是安全的。"
  },
  "Documentation/implementation/messaging_delivery_guarantees.html": {
    "href": "Documentation/implementation/messaging_delivery_guarantees.html",
    "title": "Messaging Delivery Guarantees | Microsoft Orleans 中文文档",
    "keywords": "消息传递保证 Orleans消息传递保证是 最多一次 ， 默认。可选地，如果配置为在超时后重试，则Orleans提供至少一次传送。 更详细地： Orleans中的每条消息都有自动超时(可以配置确切的超时)。如果答复未按时到达，则返回的Task会中断，并出现超时异常。 可以将Orleans配置为在超时后自动重试。默认情况下，它不会自动重试。 当然，应用程序代码也可以选择在超时时重试。 如果将Orleans系统配置为不执行自动重试(默认设置)，并且应用程序未重新发送， Orleans最多提供一次消息传递 。一条消息将被发送一次或完全不发送。 它永远不会被交付两次。 在具有重试功能的系统中(通过运行时或应用程序)，消息可能多次到达。Orleans目前不采取任何措施来持久存储哪些消息已经到达并禁止第二次发送。(我们相信这会非常昂贵。)因此，在重试系统中，Orleans最多不能保证一次交货。 如果您无限期地重试 ， 消息最终将到达 ，因此提供了至少一次的交货保证。注意，“将最终到达”是运行时需要保证的。即使您继续重试，它也不是免费的。Orleans提供最终交付方式，因为Grains永远不会进入任何永久性失效状态，而失效的Grains最终将在另一个silos中重新激活。 所以总结一下 ：在不重试的系统中，Orleans保证最多发送一次消息。在无限次重试的系统中，Orleans保证至少一次(并且不保证最多一次)。 注意 ： 在里面 Orleans技术报告 我们无意中只提到了第二个选项，即自动重试。我们忘记提及默认情况下不重试，Orleans最多提供一次交付。"
  },
  "Documentation/implementation/index.html": {
    "href": "Documentation/implementation/index.html",
    "title": "Implementation Details | Microsoft Orleans 中文文档",
    "keywords": "实施细节概述 Orleans生命周期 Orleans的某些行为非常复杂，因此需要有序地启动和关闭。为了解决这个问题，引入了通用组件生命周期模式。 消息传递保证 Orleans消息传递保证是 最多一次 ， 默认。(可选)如果配置为在超时后重试，则Orleans提供至少一次交付。 排程器 Orleans Scheduler是Orleans运行时中的一个组件，负责执行应用程序代码和部分运行时代码，以确保单线程执行语义。 集群管理 Orleans通过内置的成员资格协议(有时称为“silos成员资格”)提供集群管理。该协议的目标是让所有孤岛(Orleans服务器)就当前活动的孤岛集达成共识，检测出故障的孤岛，并允许新的孤岛加入集群。 流实施 本节提供了Orleans Stream实施的高级概述。它描述了在应用程序级别上不可见的概念和细节。 负载均衡 从广义上讲，负载平衡是Orleans运行时的支柱之一。 单元测试 本节说明如何对Grains进行单元测试，以确保其行为正确。"
  },
  "Documentation/implementation/cluster_management.html": {
    "href": "Documentation/implementation/cluster_management.html",
    "title": "Cluster Management in Orleans | Microsoft Orleans 中文文档",
    "keywords": "Orleans的集群管理 Orleans通过一个内置的成员协议提供集群管理，我们有时将其称为 silos成员资格 . 为了让新Orleans的所有服务器都加入到silos(silos)的协议中，目前还没有达成一致，即允许新Orleans的silos加入到silos中。 协议依赖于一个外部服务来提供 成员资格表 . 成员资格表 是一个平面的非SQL类型的持久表，我们有两个用途。首先，它被用作一个集合点，供各自为政的人互相寻找，而Orleans的客户则用来寻找silos。其次，它用于存储当前的成员资格视图(活动silos列表)，并帮助协调成员资格视图上的协议。我们目前有6个 成员资格表 ：基于 Azure表存储 ，SQL server， 阿帕奇动物园管理员 , IO领事 , AWS发电机B ，以及内存仿真以进行开发。除了 成员资格表 每个silos都参与完全分布式的对等成员身份协议，该协议检测出故障的silos，并就“设置活动silos”达成一致。我们首先在下面描述Orleans成员协议的内部实现，然后描述 成员资格表 . 基本成员协议： 在启动时，每个silos都将自己写入一个著名的 成员资格表 (通过配置传递)。silos标识的组合( ip地址：端口：epoch )和服务部署id用作表中的唯一键。Epoch就是这个silos开始时的计时单位 ip地址：端口：epoch 保证在给定的Orleans部署中是独一无二的。 silos通过应用程序ping相互直接监视(“你还活着吗” 心跳 ). ping作为直接消息从silos发送到silos，通过silos通信的同一个TCP套接字。这样，ping与实际的网络问题和服务器运行状况完全相关。每一个silos都会发出另一个silos的声音。一个silos通过计算其他silos标识上的一致散列值来挑选要ping的对象，形成一个包含所有标识的虚拟环，并在该环上选择X个后继silo(这是一种著名的分布式技术，称为 一致哈希 在许多分布式哈希表中被广泛使用，比如 弦式DHT ). 如果silosS没有从受监视的服务器P获得Y ping响应，它会通过将其带有时间戳的怀疑写入P的行中来怀疑它 成员资格表 . 如果P在K秒内有超过Z个怀疑，那么S会将P写入P的行中，并向所有silos广播一个重新读取成员表的请求(无论如何，它们都会定期执行)。 更多详情： 5.1怀疑被写入 成员资格表 ，在对应于P的行中的一个特殊列中。当S怀疑P时，它写下：“at time TTT S successed P”。 5.2一次怀疑不足以宣告P死亡。您需要在一个可配置的时间窗口T(通常为3分钟)内，从不同的silos中得到Z个怀疑，才能将P声明为dead。使用由 成员资格表 . 5.3可疑silosS显示P行。 5.4如果S是最后一个嫌疑犯(如嫌疑栏中所述，在时间段T内已经有Z-1嫌疑犯)，S决定宣布P死亡。在本例中，S将自己添加到suspencers列表中，并在P的Status列中写入P is Dead。 5.5否则，如果S不是最后一个suspencers，则S只将自己添加到suspencers列中。 5.6在任何一种情况下，回写都使用读取的版本号或etag，因此对此行的更新是序列化的。如果由于版本/etag不匹配而导致写入失败，S将重试(再次读取并尝试写入，除非P已标记为dead)。 5.7在较高的层次上，“读取、本地修改、回写”序列是一个事务。但是，我们没有使用存储事务来实现这一点。“事务”代码在服务器上本地执行，我们使用 成员资格表 以确保隔离和原子性。 每个silos定期读取整个成员表以进行部署。通过这种方式，silos了解到新的silos加入以及其他silos被宣布死亡。 配置 ：我们提供了一个默认配置，它是在我们在Azure中的生产使用过程中手动调整的。目前的默认值是：每个silos由另外3个silos监视，2个怀疑足以宣布一个silos失效，怀疑仅从最后3分钟开始(否则它们就过时了)。每10秒发送一次ping，您需要错过3次ping才能怀疑一个silos。 实施完美故障检测 –理论上，如果一个silos与其他silos失去通信，而silos进程本身仍在运行，则该silos将被宣布为死机。为了解决这个问题，一旦silos在表中被声明为dead，每个人都认为它已经死了，即使它实际上没有死(只是暂时分区或者心跳消息丢失)。每个人都停止与它交流，一旦它知道它死了(通过从表中读取它自己的新状态)，它就会自杀并关闭进程。因此，必须有一个适当的基础设施来重新启动silos作为一个新的进程(在启动时会生成一个新的epoch编号)。当它托管在Azure中时，会自动发生这种情况。如果没有，就需要另一个基础设施。例如，配置为在发生故障时自动重新启动的Windows服务。 优化以减少定期表读取的频率，并加快所有silos学习新的连接silos和死silos . 每当任何silos成功地向表中写入任何内容(怀疑、新联接，…)时，它也会广播到所有其他silos—“现在就去重新读取表”。silos不会告诉其他人它在表中写了什么(因为这些信息可能已经过时/错误)，它只是告诉他们重新读取表。这样我们就可以很快地了解成员身份的变化，而不需要等待整个周期性的读取周期。我们仍然需要定期读取，以防“重新读取表”消息丢失。 基本成员协议的属性和常见问题解答： 可以处理任何数量的失败 –我们的算法可以处理任何数量的失败(即f<=n)，包括完全重启集群。这与“传统”形成鲜明对比 帕克索斯 基于解决方案，需要法定人数，通常是多数。我们已经看到在生产情况下，一半以上的silos都关闭了。我们的系统仍然正常运行，而基于Paxos的会员制将无法取得进展。 去餐桌的交通非常少 -实际的ping直接在服务器之间进行，而不是发送到表中。这将产生大量的流量，而且从故障检测的角度来看是不够准确的-如果一个silos无法到达表，它将无法写入它的“我是活着的”心跳，其他人会杀死他。 可调精度与完整性 – 一般来说，完美和准确的故障检测是不可能的 . 人们通常希望能够在准确性和完整性之间进行权衡(不想将一个真正活着的silos声明为死silos)和完整性(希望尽快声明一个实际上已经死了的silos)。可配置的声明死亡和错过ping的投票允许交易这两个。 比例尺 -基本协议可以处理数千个甚至可能是数万个服务器。这与传统的 帕克索斯 基于解决方案，如组通信协议，已知其规模不会超过10个。 诊断学 -该表也非常便于诊断和故障排除。系统管理员可以立即在表中找到活动的silos的当前列表，以及查看所有被杀死的silos和怀疑的历史。这在诊断问题时特别有用。 为什么我们需要可靠的持久存储来实现 成员资格表 ? -我们为 成员资格表 有两个目的。首先，它被用作一个集合点，供各自为政的人互相寻找，而Orleans的客户则用来寻找silos。第二，我们使用可靠的存储来帮助我们协调成员观点上的协议。当我们以对等的方式在silos之间直接执行故障检测时，我们将成员资格视图存储在一个可靠的存储器中，并使用该存储器提供的并发控制机制来达成谁活着谁死的协议。这样，在某种意义上，我们的协议将分布式共识的难题外包给了云。因为我们充分利用了底层云平台的力量，真正将其作为“平台即服务”。 如果一段时间内无法访问该表，会发生什么情况？ (存储服务关闭、不可用或存在通信问题)–在这种情况下，我们的协议不会错误地宣布silos死机。目前运行的silos将继续工作，没有任何问题。但是，我们不能声明一个silos死机(如果我们通过丢失的ping检测到一些silos死机，我们将无法将此事实写入表中)，也无法允许新的silos加入。所以完整性会受到影响，但是准确性不会——从表中进行分区永远不会导致我们错误地宣布思洛死了。另外，在部分网络分区的情况下(如果一些silos可以访问表，而另一些silos不能访问表)，我们可能会将一个死silos声明为死silos，但在所有其他silos了解到它之前，还需要一些时间。所以检测可以延迟，但我们绝不会因为表格不可用而误杀他人。 直接IAmAlive写入表仅用于诊断 -除了在silos之间发送的心跳信号外，每个silos还定期更新表中其行中的“我还活着”列。“我还活着”一栏只供使用 用于手动故障排除和诊断 并且不被成员协议本身使用。它通常以较低的频率编写(每5分钟一次)，它是系统管理员检查集群活动性或轻松找出silos上次活动的时间的非常有用的工具。 完全订购成员资格视图的扩展： 上面描述的基本成员协议后来被扩展为支持完全有序的成员关系视图。我们将简要描述这个扩展的原因以及它是如何实现的。扩展在上述设计中没有任何改变，只是添加了一个附加属性，即所有成员配置都是全局完全有序的。 为什么完全订购成员视图是有用的？ 这允许序列化新silos到集群的连接。这样，当一个新的silos加入集群时，它就可以验证与其他已经启动的silos的双向连接。如果一些已加入的silos没有应答(可能表明新silos存在网络连接问题)，则不允许新silos加入。这可以确保至少在一个silos启动时，集群中所有silos之间都有完整的连接(这是实现的)。 silos中的更高级别协议(如分布式grain directory)可以利用成员关系视图被排序的事实，并使用这些信息来执行更智能的重复激活解析。特别是，当directory发现在成员身份不断变化时创建了2个激活，它可能会决定停用基于现在过时的成员身份信息创建的旧激活(目前尚未实现)。 扩展成员协议： 为了实现此功能，我们利用了 成员资格表 .. 我们向跟踪表更改的表添加成员身份版本行。 当silo S想为silo P写怀疑或死亡声明时： 3.1s读取最新的表格内容。如果P已经死了，什么也不做。否则， 3.2在同一事务中，将更改写入P的行，并增加版本号并将其写回表中。 3.3两次写入都使用ETag进行调节。 3.4如果事务因P行或版本行上的eTag不匹配而中止，请重试。 所有对表的写入都会修改和增加版本行。这样，所有对表的写入都被序列化(通过将更新序列化到version行)，并且由于silos只增加版本号，所以写入操作也完全按递增顺序排列。 扩展成员协议的可扩展性： 在协议的扩展版本中，所有写操作都通过一行进行序列化。这可能会损害集群managemenet协议的可伸缩性，因为它增加了并发表写入之间发生冲突的风险。为了部分缓解这个问题，silos通过使用指数回退来重试它们对表的所有写入操作。我们已经观察到扩展的协议在Azure中有多达200个silos的生产环境中能够顺利地工作。然而，我们确实认为该协议在扩展到一千个silos之外可能存在问题。在这样的大型设置中，对版本行的更新很容易被禁用，基本上保留了集群managemenet协议的其余部分，并放弃了total ordering属性。还请注意，这里我们指的是集群管理协议的可伸缩性，而不是Orleans的其他地方。我们相信Orleans运行时的其他部分(消息传递、分布式目录、grain托管、客户端到网关连接)的可扩展性远远超过了数百个Silo。 成员表： 如前所述， 成员资格表 它被用作一个集合点，供思洛寻找彼此和Orleans客户查找思洛，还帮助协调成员关系视图上的协议。我们目前有6个 成员资格表 ：基于Azure Table、SQL server、Apache ZooKeeper、Consult IO、AWS DynamoDB和内存仿真进行开发。的接口 成员资格表 在中定义 IMembershipTable . Azure表存储 -在这个实现中，我们使用Azure部署ID作为分区键和silos标识( ip地址：端口：epoch )作为行键。它们一起保证每个silos都有一个唯一的密钥。对于并发控制，我们使用基于 Azure表ETag . 每次从表中读取时，我们为每个读取行存储etag，并在尝试回写时使用该etag。每次写入时，Azure表服务都会自动分配和检查etag。对于多行事务，我们利用 Azure表提供的批处理事务 ，它保证在具有相同分区键的行上序列化事务。 SQL Server—在此实现中，配置的部署ID用于区分部署以及哪些silos属于哪些部署。silos标识定义为 部署ID，ip，端口，epoch 在适当的表和列中。关系后端使用乐观并发控制和事务，类似于在Azure表实现上使用etag的过程。关系实现期望数据库引擎生成所使用的ETag。对于SQL Server，在SQL Server 2000上，生成的ETag是通过调用 新ID() . 在SQL Server 2005及更高版本上 行版本 被使用。Orleans读写关系etag是不透明的 变量二进制(16) 标记并将它们存储在内存中作为 基准64 编码字符串。Orleans支持使用UNION ALL(对于Oracle包括DUAL)的多行插入，UNION ALL当前用于插入统计数据。SQL Server的具体实现和基本原理请参见 创建或清理马厩_sql服务器.sql . 阿帕奇动物园管理员 -在这个实现中，我们使用配置的部署ID作为根节点和silos标识( ip:端口@epoch )作为其子节点。它们共同保证了每个silos的唯一路径。对于并发控制，我们使用基于 节点版本 . 每次从部署根节点读取时，都会存储每个读取子思洛节点的版本，并在尝试回写时使用该版本。每当一个节点的数据发生变化时，ZooKeeper服务就会自动地增加版本号。对于多行事务，我们使用 多方法 ，它保证在具有相同父部署ID节点的silos节点上可序列化事务。 IO领事 -我们用过 执政官的钥匙/价值商店 推动membershop表。参考 执政官部署 更多细节。 AWS发电机B -在这个实现中，我们使用集群部署ID作为分区键和silos标识( ip端口生成 )作为使记录统一的RangeKey。乐观并发由 ETag 属性通过在DynamoDB上进行条件写入来实现。实现逻辑与Azure表存储非常相似。我们只实现了基本成员协议(而不是扩展协议)。 内存模拟开发设置。我们使用一种特殊的系统grains，叫做 成员资格表 ，以便实现。这些Grains存放在指定的主silos中，该silos仅用于 开发设置 . 在任何实际生产使用情况下，主silos 不是必需的 . 配置： 成员协议通过 活泼 元素 全球 分段 Orleans配置.xml 文件。默认值在Azure的生产使用年限中进行了调整，我们相信它们代表了良好的默认设置。一般来说，没有必要改变它们。 配置元素示例： <Liveness ProbeTimeout = \"5s\" TableRefreshTimeout =\"10s DeathVoteExpirationTimeout =\"80s\" NumMissedProbesLimit = \"3\" NumProbedSilos=\"3\" NumVotesForDeathDeclaration=\"2\" /> 实现了4种类型的活跃度。活动协议的类型通过 系统存储类型 属性 系统存储 元素 全球 分段 Orleans配置.xml 文件。 成员资格表 -成员表存储在主silos上的一个Grains中。这是一个 仅开发设置 . 可定制 -成员表存储在Azure表中。 SQL服务器 -成员表存储在关系数据库中。 动物园管理员 -成员表存储在ZooKeeper中 合奏 . 执政官 -配置为自定义系统存储 MembershipTableAssembly=“orleansConsultils” . 参考 执政官部署 更多细节。 发电机B -配置为自定义系统存储 MembershipTableAssembly=“OrleansAWSUtils” . 对于所有活动类型，公共配置变量在中定义 全球化。活力 要素： 问题时间 -我要给他们的“发射室”发送信号。默认值为10秒。 表刷新超时 -从成员资格表获取更新的秒数。默认值为60秒。 死亡呼气超时 -成员表中死亡投票的过期时间(秒)。默认值为120秒 努米塞德普斯里米 t-从一个silos丢失的“我还活着”心跳信号消息的数量，或者导致怀疑该silos已死亡的未应答探测的数量。默认值为3。 纽普罗贝斯洛斯 -每个silos探测活跃度的silos数量。默认值为3。 NumVotesForDeath声明 -宣布某个silos死亡所需的未过期投票数(最多应为numissedprobeslimit)。默认值为2。 闲言碎语 -是否使用八卦优化来加速活跃度信息的传播。默认值为true。 IAmAliveTablePublishTimeout -定期在成员资格表中写入此silos处于活动状态的秒数。仅用于诊断。默认值为5分钟。 NumMissedTableIAmAliveLimit -表中从silos中丢失的导致记录警告的“我还活着”更新的数量。不影响活动协议。默认值为2。 MaxJoinAttemptTime -在放弃之前尝试加入一个silos群的秒数。默认值为5分钟。 预期群集大小 -群集的预期大小。不必很准确，可以高估。用于优化要写入Azure表的重试的指数退避算法。默认值为20。 设计原理： 一个很自然的问题是为什么不完全依赖 阿帕奇动物园管理员 对于集群成员身份实现，可能会使用 具有短暂节点的群成员关系 ? 为什么我们要费心实施我们自己的会员协议？主要有三个原因： (一) 在云中部署/托管 -Zookeeper不是一个托管服务(至少在撰写本文的2015年7月，当然，当我们在2011年夏天首次实现该协议时，没有任何一个主流云提供商将Zookeeper作为托管服务运行)。这意味着在云环境中，Orleans的客户必须部署/运行/管理自己的ZK集群实例。这只是又一个不必要的负担，我们不想强迫我们的客户。通过使用Azure表，我们依赖于托管的托管服务，这使我们的客户的生活更加简单。 基本上，在云计算中，将云用作平台，而不是基础设施。 另一方面，在本地运行和管理自己的服务器时，依赖ZK作为 成员资格表 是一个可行的选择。 (二) 直接故障检测 -当将ZK的组成员资格用于临时节点时，将在Orleans服务器(ZK客户端)和ZK服务器之间执行故障检测。这可能不一定与Orleans服务器之间的实际网络问题相关。 我们希望故障检测能够准确地反映集群内通信的状态。 具体来说，在我们的设计中，如果Orleanssilos不能与 成员资格表 它不被认为是死的，可以继续工作。与此相反，如果我们将ZK组成员资格用于临时节点，那么与ZK服务器的断开连接可能会导致Orleans silo(ZK client)被声明为dead，而实际上它可能是活动的并且完全正常工作。 (三) 便携性和灵活性 -作为Orleans哲学的一部分，我们不想强迫任何特定的技术，而是要有一个灵活的设计，在这种设计中，不同的组件可以很容易地用不同的实现进行切换。这正是紫色 成员资格表 抽象服务。 致谢： 我们要感谢 亚历克斯·科根 本协议的第一版的设计与实现。这项工作是2011年夏天微软研究所暑期实习的一部分。基于ZooKeeper的实现 成员资格表 是由谁完成的 夏伊·哈佐 SQL的实现 成员资格表 是由谁完成的 维科·伊娃 AWS DynamoDB的实现 成员资格表 是由谁完成的 古腾堡里贝罗 并以consur为基础实现 成员资格表 是由谁完成的 保罗·诺斯 ."
  },
  "Documentation/clusters_and_clients/silo_lifecycle.html": {
    "href": "Documentation/clusters_and_clients/silo_lifecycle.html",
    "title": "Silo Lifecycle | Microsoft Orleans 中文文档",
    "keywords": "silos生命周期 概述 Orleanssilos使用可观察的生命周期(参见 Orleans生命周期 )用于Orleans系统和应用层组件的有序启动和关闭。 阶段 Orleanssilos和集群客户端使用一组公共的服务生命周期阶段。 public static class ServiceLifecycleStage { public const int First = int.MinValue; public const int RuntimeInitialize = 2000; public const int RuntimeServices = 4000; public const int RuntimeStorageServices = 6000; public const int RuntimeGrainServices = 8000; public const int ApplicationServices = 10000; public const int BecomeActive = Active-1; public const int Active = 20000; public const int Last = int.MaxValue; } 服务生命周期的第一阶段 运行时初始化-初始化运行时环境。silos初始化线程。 runtime services-启动运行时服务。silo初始化网络和各种代理。 RuntimeStorageServices-初始化运行时存储。 runtimegrainservices-启动grains的运行时服务。这包括Grains类型管理、成员服务和Grains目录。 应用服务–应用层服务。 变为活动-silos加入群集。 活动—silos在群集中处于活动状态，并准备接受工作负载。 服务生命周期的最后阶段 登录中 由于控制权倒置，参与者加入生命周期，而不是具有一些集中的初始化步骤集的生命周期，因此代码中并不总是清楚启动/关闭顺序是什么。为了帮助解决这个问题，在silos启动之前添加了日志记录，以报告每个阶段参与的组件。这些日志记录在 Orleans.Runtime.SiloLifecycleSubject 记录员。例如： 信息，orleans.runtime.silolifecyclesubject，“阶段2000:orleans.statistics.perfcounterevironmentstatistics，orleans.runtime.insideruntimeclient，orleans.runtime.silo” 信息，orleans.runtime.silolifecyclesubject，“stage 4000:orleans.runtime.silo” 信息，orleans.runtime.silolifecyclesubject，“阶段10000:orleans.runtime.versions.grainversionstore，orleans.storage.azuretablegrainstorage-default，orleans.storage.azuretablegrainstorage pubstore” 此外，对每个组件的定时和错误信息也进行了类似的逐级记录。例如： 信息，orleans.runtime.silolifecyclesubject，“生命周期观察者orleans.runtime.insideruntimeclient在2000阶段启动，耗时33毫秒。” 信息，orleans.runtime.silolifecyclesubject，“生命周期观察者orleans.statistics.perfcounterenvironmentstatistics开始于2000阶段，耗时17毫秒。” silos生命周期参与 应用程序逻辑可以通过在silos的服务容器中注册参与服务来参与silos的生命周期。服务必须注册为ILifecycleParticipant 是的。 public interface ISiloLifecycle : ILifecycleObservable { } public interface ILifecycleParticipant<TLifecycleObservable> where TLifecycleObservable : ILifecycleObservable { void Participate(TLifecycleObservable lifecycle); } silos启动时，所有参与者( 循环参与人<Isilifecycle> )在容器中，将有机会通过调用 参与(…) 行为。一旦所有人都有机会参与，silos的可观测生命周期将依次开始所有阶段。 例子 随着silo生命周期的引入，用于允许应用程序开发人员在提供程序初始化阶段注入逻辑的引导提供程序不再是必需的，因为应用程序逻辑现在可以在silo启动的任何阶段注入。尽管如此，我们还是添加了一个“启动任务”fa_ade来帮助使用引导提供程序的开发人员进行转换。作为如何开发参与silos生命周期的组件的示例，我们将查看启动任务fa_ade。 启动任务只需要继承自 循环参与人<Isilifecycle> 并在指定阶段将应用程序逻辑订阅到silos生命周期。 class StartupTask : ILifecycleParticipant<ISiloLifecycle> { private readonly IServiceProvider serviceProvider; private readonly Func<IServiceProvider, CancellationToken, Task> startupTask; private readonly int stage; public StartupTask( IServiceProvider serviceProvider, Func<IServiceProvider, CancellationToken, Task> startupTask, int stage) { this.serviceProvider = serviceProvider; this.startupTask = startupTask; this.stage = stage; } public void Participate(ISiloLifecycle lifecycle) { lifecycle.Subscribe<StartupTask>( this.stage, cancellation => this.startupTask(this.serviceProvider, cancellation)); } } 从上面的实现中，我们可以看到在startuptask的 参与(…) 调用它订阅配置阶段的silos生命周期，传递应用程序回调，而不是它自己的初始化逻辑。 需要在给定阶段初始化的组件将提供自己的回调，但模式是相同的。 现在我们有了一个startuptask，它将确保在配置阶段调用应用程序的钩子，我们需要确保startuptask参与Silo生命周期。为此，我们只需要在容器中注册它。 我们使用silohost构建器上的扩展函数来实现这一点。 public static ISiloHostBuilder AddStartupTask( this ISiloHostBuilder builder, Func<IServiceProvider, CancellationToken, Task> startupTask, int stage = ServiceLifecycleStage.Active) { builder.ConfigureServices(services => services.AddTransient<ILifecycleParticipant<ISiloLifecycle>>(sp => new StartupTask( sp, startupTask, stage))); return builder; } 通过在silos的服务容器中将startuptask注册为标记接口 循环参与人<Isilifecycle> ，这向silos发出信号，表明此组件需要参与silos的生命周期。"
  },
  "Documentation/clusters_and_clients/powershell_client.html": {
    "href": "Documentation/clusters_and_clients/powershell_client.html",
    "title": "PowerShell Client Module | Microsoft Orleans 中文文档",
    "keywords": "powershell客户端模块 Orleans Powershell客户端模块是一组 powershell cmdlet 那包裹着 grains客户端 在一组方便的命令中，不仅可以与 管理grain 但是任何 伊格拉因 就像普通的Orleans应用程序可以通过使用powershell脚本一样。 这些cmdlet通过利用powershell脚本，从开始维护任务、测试、监视或任何其他类型的自动化，启用一系列场景。 使用方法如下： 安装模块 来源 您可以从源代码构建 奥利恩斯普提尔斯 投射并导入： PS> Import-Module .\\projectOutputDir\\Orleans.psd1 尽管您可以这样做，但是有一种更简单有趣的方法可以通过从 powershell库 是的。 来自powershell库 现在的powershell模块很容易像nuget包一样共享，但是它们托管在 powershell库 是的。 要将其安装到特定文件夹，请运行： PS> Save-Module -Name OrleansPSUtils -Path <path> 在powershell模块路径上安装( 推荐的方法 )，只需运行： PS> Install-Module -Name OrleansPSUtils 如果您计划在 azure自动化 ，只需单击下面的按钮： 使用模块 无论您决定以何种方式安装它，要实际使用它，首先需要在当前的powershell会话中导入模块，以便通过运行以下命令使cmdlet可用： PS> Import-Module OrleansPSUtils 注意 ：如果是从源代码生成，则必须使用 .psd1段 而不是使用模块名，因为它不在 $env:psmodulepath路径 powershell运行时变量。同样，强烈建议您改为从powershell库安装。 导入模块(这意味着该模块已加载到powershell会话中)后，将有以下cmdlet可用： 启动GrainClient 停止GrainClient 获取Grains 启动GrainClient 这个模块是一个包装器 grainclient.initialize() 以及它的超载。 用法 以下内容： 启动GrainClient 与Call相同 grainclient.initialize() 它将查找已知的Orleans客户端配置文件名 启动grainclient[-configfilepath]<string>[[-timeout]<timespan>] 将使用提供的文件路径，如中所示 grainclient.initialize(文件路径) 启动grainclient[-configfile]<fileinfo>[[-timeout]<timespan>] 使用 系统文件信息 类表示配置文件，就像 grainclient.initialize(文件信息) 启动grainclient[-config]<clientconfiguration>[[-timeout]<timeSPAN>] 使用 Orleans.runtime.configuration.clientconfiguration 就像在 grainclient.initialize(配置) 启动grainclient[-gatewayaddress]<ipendpoint>[[-overrideconfig]<bool>[[-timeout]<timespan>] 采用Orleans群集网关地址终结点 注意 ：的 超时 参数是可选的，如果它被告知并且大于 System.TimeSpan.Zero系统.TimeSpan.Zero ，它将调用 orleans.grainclient.setResponseTimeout(超时) 在内部。 停止GrainClient 不接受任何参数，当调用时，如果 grains客户端 初始化将正常取消初始化。 获取Grains 包装物 grainclient.grainfactory.getgrain<t>() 以及它的超载。 强制参数是 -Grain 以及 -xxx键 对于Orleans支持的当前Grains密钥类型( 一串 ，请 指导方针 我是说， 长的 )还有 -键扩展 可以用在有复合键的Grains上。 此cmdlet返回作为上的参数传递的类型的Grain引用 -Grain 是的。 例子： 一个简单的调用示例 MyInterfacesNamespace.IMyGrain.SayHeloTo grains法： PS> Import-Module OrleansPSUtils PS> $configFilePath = Resolve-Path(\".\\ClientConfig.xml\").Path PS> Start-GrainClient -ConfigFilePath $configFilePath PS> Add-Type -Path .\\MyGrainInterfaceAssembly.dll PS> $grainInterfaceType = [MyInterfacesNamespace.IMyGrain] PS> $grainId = [System.Guid]::Parse(\"A4CF7B5D-9606-446D-ACE9-C900AC6BA3AD\") PS> $grain = Get-Grain -GrainType $grainInterfaceType -GuidKey $grainId PS> $message = $grain.SayHelloTo(\"Gutemberg\").Result PS> Write-Output $message Hello Gutemberg! PS> Stop-GrainClient 我们计划更新这个页面，因为我们在powershell上引入了更多的cmdlet，如useobservators、streams和其他orleans核心特性。我们希望这能帮助人们成为自动化的起点。一如既往，这是一项正在进行的工作，我们热爱贡献！：) 请注意，目的不是在powershell上重新实现整个客户端，而是给it和devops团队一种与grains交互的方式，而无需实现一个.net应用程序。"
  },
  "Documentation/clusters_and_clients/heterogeneous_silos.html": {
    "href": "Documentation/clusters_and_clients/heterogeneous_silos.html",
    "title": "Heterogeneous silos | Microsoft Orleans 中文文档",
    "keywords": "非均质silos 概述 在给定的集群上，silos可以支持一组不同的Grains类型： 在本例中，集群支持类型为 一 我是说， 乙 我是说， C类 ，请 丁 我是说， E类 ： grains类型 一 和 乙 可存储在silos1和2上。 grains类型 C类 可存储在silos1、2或3上。 grains类型 丁 只能放在silos3上 grains类型 E类 只能存储在silos4上。 所有的silos都应该引用集群的所有Grains类型的接口，但是Grains类应该只被将承载它们的silos引用。 客户端不知道哪个silos支持给定的Grains类型。 给定的Grains类型实现在支持它的每个silos上必须相同。以下方案无效： 在silos1和2上： public class C: Grain, IMyGrainInterface { public Task SomeMethod() { … } } 在silos3上 public class C: Grain, IMyGrainInterface, IMyOtherGrainInterface { public Task SomeMethod() { … } public Task SomeOtherMethod() { … } } 配置 不需要配置，您可以在集群中的每个silos上部署不同的二进制文件。但是，如果需要，可以更改silo和客户端检查属性支持的类型更改的间隔 类型映射刷新间隔 从 类型管理选项 出于测试目的，可以使用属性 排除雨水类型 在里面 GrainClass选项 ，这是要在silos上排除的类型的列表名称。 限制 如果受支持的Grain类型集发生更改，则不会通知已连接的客户端。在前面的示例中： 如果silo 4离开集群，客户端仍将尝试调用类型为grain的 E类 是的。它将在运行时失败，并带有orleansexception。 如果客户端是在silos4加入群集之前连接到群集的，则客户端将无法调用类型为 E类 是的。它会失败的 不支持无状态grains：集群中的所有silos必须支持同一组无状态grains。"
  },
  "Documentation/resources/documentation_guidelines.html": {
    "href": "Documentation/resources/documentation_guidelines.html",
    "title": "Documentation Guidelines | Microsoft Orleans 中文文档",
    "keywords": "文件编制指南 Orleans文档是内置的 降价 . 我们使用一些简单的约定来确保整个文档集中的样式一致。 这些标准正在引入。如果您对这些指导原则有异议，请提出问题或请求。如果发现文档不符合指导原则，请进行修复并提交请求。另外，如果你使用的是Windows10，你可以去商店找到免费的降价编辑器，比如 这 结构 语言 文件将遵循美国英语拼写。桌面工具，如 http://markdownpad.com 和 Visual Studio代码 有拼写检查功能。 段落结构 每句话都应该写在一行，每行只能写一句话。这使得合并更改更容易，并有助于识别冗长的语言。Markdown中的段落只是一行或多行连续文本，后跟一行或多行空白行。 标题 标题应该用来组织文件。避免使用其他强调功能，如ALLCAPS， 斜体字 或 大胆的 确定一个新的话题。使用标头不仅更加一致，而且允许链接到标头。 页脚 在页面的末尾，链接到文档中的下一个逻辑页面很有帮助。如果该页是子节中的最后一页，则链接回索引页是有用的。 风格 代码格式 示例代码块的格式应为后面紧跟着语言的三个反勾号格式。 [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> { ... } 将呈现为 [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> ... { ... } 内联代码应该用一个反勾号标记(`). 其中包括以下参考： 键入名称，例如。 Task<T> 变量名，例如。 游戏 名称空间，例如。 Orleans。存储。AzureTablesStorage 如果显示输出的文本(例如文本文件内容或控制台输出)，则可以使用后三勾号而不指定语言，也可以缩进内容。例如： 1 said: Welcome to my team! 0 said: Thanks! 1 said: Thanks! 0 said: Thanks! 文件名和路径 引用文件名、目录/文件夹或URI时，请使用标准斜体来格式化。这可以通过在字符串周围加上一个星号来完成( * )或者一个下划线( _ ) 示例： 奥尔勒ansRuntimeInterfaces.dll C： \\二进制文件 ../src/Grains.cs 桌子 标记支撑 表格数据 . 可以使用表来构造数据，以便读者可以轻松地使用这些数据。 后缀 单位 女士 毫秒 s 秒 米 分钟 链接 引用另一个概念时，请提供指向该概念的链接。页面中的正向和反向引用可以通过页眉进行链接。e、 g.链接回 结构 指向其他文档的链接既可以链接到页面，也可以链接到页面中的子节/页眉。外部链接应作为完整链接公开。例如 https://github.com/dotnet/roslyn 贡献 Orleans文档作为降价文件管理在托管在上的Git存储库中 gh pages分部的GitHub . 见 GitHub页面 有关如何使用 gh页面 “项目现场”文件的分支约定。"
  },
  "Documentation/resources/orleans_thinking_big_and_small.html": {
    "href": "Documentation/resources/orleans_thinking_big_and_small.html",
    "title": "Orleans - Thinking Big and Small | Microsoft Orleans 中文文档",
    "keywords": "TL; DR：您不需要数百台服务器即可从Orleans中受益。一把就足够了。 正如我们刚刚宣布Orleans计划的公开预览( 现在可用：“Orleans”项目的预览–大规模的云服务 )，// build /上的一些最初的问题和讨论都围绕着Orleans编程模型适合哪种类型的服务。我听到有人说Orleans适用于超大规模系统。尽管从技术上讲是正确的，但他们对我来说并不完整，并迫使我写这篇文章。 适用范围 Orleans适用性的一个极端是单机应用。有些人将角色隔离和安全并发视为足够大的好处，因此值得以传递消息为代价。这不是我们在构建Orleans时进行优化的用例，而是一种合法的使用模式，只是在云环境中不是很有趣。 在另一端，我们发现了跨越数千台服务器的大规模部署。我们在数百台服务器的部署上对Orleans进行了测试，我相信它可以在数千台服务器上正常运行，即使需要进行一些配置调整也是如此。但是，我个人对多少个产品实际上需要跨数千个服务器的单个云服务持怀疑态度，而不是运行多个相互关联的服务，而每个服务实例都部署在数十个或数百个服务器上，因此我个人对此持怀疑态度。 分布式系统–同样的问题，无论大小 当系统从一台服务器移动到多台服务器时，开发人员将面临几乎相同的挑战，而不论其规模是3-5、30-50还是300-500服务器系统。他们现在必须处理计算的分布，它们之间的协调，可伸缩性，容错和重新配置，诊断等。现在，他们正在构建一个分布式系统，这从来都不容易。建立有状态的分布式系统更加困难。 Orleans旨在通过提供一组易于使用的抽象来帮助构建此类系统，这些抽象可大大简化开发人员的生活并帮助他们避免常见的分布式系统陷阱。分布式运行时旨在执行大多数繁重的工作。在构建不同规模的服务时，开发人员同样可以从Orleans的这些功能中受益，因为Orleans解决的问题实际上是相同的。Grain的抽象简化了有关系统的推理，同时鼓励对状态进行细Grain的划分以实现可伸缩性。虚拟角色功能有助于资源管理和容错。自动传播异常会最大程度地减少错误处理代码，而不会丢失故障。分布式运行时负责服务器故障，消息传递，路由，单线程执行和其他系统级别的保证。您不需要数百台服务器即可开始提高开发人员的工作效率。 弹性 很难为将来的系统预测负载，而且通常根本不可能。每个初创企业都梦想有一天会被斩首，这对企业来说是福气，也是对系统的诅咒。或者您的CMO可能非常喜欢您的BI数据，以至于她突然想将其存储在5秒内而不是30分钟内。为可能永远不会实现的高负载而建造是昂贵的。Orleans模型通过鼓励以可扩展的方式设计系统来帮助解决弹性问题，这样您就可以从小规模部署开始，并在不更改应用程序代码的情况下从小规模部署或扩大规模(如果需要)。 底线 从单服务器设置转移到分布式系统(无论是2台或3台服务器还是数千台服务器)，您应该都能从Orleans中受益。如果您认为可能需要一天的时间横向扩展或容错，您甚至可以开始与Orleans一起构建单服务器解决方案。这样做的好处是您的代码无需更改。只需添加更多服务器，您的grain就会遍布他们。 -谢尔盖·拜科夫(Sergey Bykov)"
  },
  "Documentation/resources/links.html": {
    "href": "Documentation/resources/links.html",
    "title": "Links | Microsoft Orleans 中文文档",
    "keywords": "链接 由Orleans队 Orleans建筑：原理与方法I 第142集：Microsoft研究项目Orleans简化了可伸缩云服务的开发 Orleans：大大小小的思考 现在可用：“Orleans”项目的预览–大规模的云服务 Orleans：分布式虚拟角色的可编程性和可伸缩性 被别人 介绍Orleans Microsoft Orleans v2.0-面向初学者和专家的综合指南(PowerPoint) Orleans计划初探 再看Orleans计划 Orleans计划：简介 Orleans计划简介 Orleans简介 Orleans专案：不同于Erlang，专为众多开发人员设计 您可能要使用Microsoft Orleans项目的两个原因 Hatay Tuna和Christian Martinez-Orleans的应用演员模型 与Orleans演员编程：有什么不同？ Orleans–为#azure构建的“云原生”运行时 Orleans计划-演员模型框架 通过Erlang色眼镜了解Microsoft Orleans 在企业应用程序中使用代号“ Orleans” 除了介绍 Grains，Grains和更多Grains 在物联网世界中细Grain的OrleansGrains 可监控的Grains 汇总结果在Orleans 使用Orleans创建RESTful服务 与Orleans一起解决分发，高吞吐量和低延迟问题–专为#Azure构建的“云原生”运行时 在#ProjectOrleans中仅偶尔保存一次状态 使用Orleans构建可扩展的云应用程序 物联网世界中的Orleans Orleans预览和光环4 在Halo中使用“Orleans”项目 Orleans与跳出思维 John Azariah和Mahesh Krishnan-不变性，状态和规模-Azure中的功能，分布式应用程序 最后编辑：2018年6月5日"
  },
  "Documentation/resources/nuget_packages.html": {
    "href": "Documentation/resources/nuget_packages.html",
    "title": "Orleans NuGet Packages | Microsoft Orleans 中文文档",
    "keywords": "OrleansNuGet软件包 关键套餐 在大多数情况下，您需要使用5个关键的NuGet软件包： 微软Orleans核心抽象 PM> Install-Package Microsoft.Orleans.Core.Abstractions 包含Orleans.Core.Abstractions.dll，该文件定义开发应用程序代码(grains接口和类)所需的Orleans公共类型。任何Orleans项目都需要直接或间接引用此软件包。将其添加到定义grain接口和类的项目中。 Microsoft Orleans构建时代码生成 Microsoft.Orleans.OrleansCodeGenerator.Build 。 PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build 出现在Orleans1.2.0中。为Grains接口和实施项目提供时间支持。将其添加到您的grain接口和实现项目中，以启用grain引用和序列化器的代码生成。 Microsoft.Orleans.CodeGenerator.MSBuild 。 PM> Install-Package Microsoft.Orleans.CodeGenerator.MSBuild 出现在 Orleans2.1.0 。替代 Microsoft.Orleans.OrleansCodeGenerator.Build 包。利用Roslyn进行代码分析，以避免加载应用程序二进制文件并改善对增量构建的支持，这将缩短构建时间。 Microsoft Orleans服务器库 PM> Install-Package Microsoft.Orleans.Server 一个易于构建和启动silos的元软件包。包括以下软件包： 微软Orleans核心抽象 微软Orleans核心 Microsoft.Orleans.OrleansRuntime Microsoft.Orleans.OrleansProviders Microsoft Orleans客户库 PM> Install-Package Microsoft.Orleans.Client 一个用于轻松构建和启动Orleans客户(前端)的元软件包。包括以下软件包： 微软Orleans核心抽象 微软Orleans核心 Microsoft.Orleans.OrleansProviders 微软Orleans核心库 PM> Install-Package Microsoft.Orleans.Core 包含应用程序代码和Orleans客户(前端)使用的大多数Orleans公共类型的实现。引用它以构建使用Orleans类型但不处理托管或孤岛的库和客户端应用程序。包含在Microsoft.Orleans.Client和Microsoft.Orleans.Server元软件包中，并且大多数其他软件包直接或间接地对其进行引用。 代管 微软Orleans运行时 PM> Install-Package Microsoft.Orleans.OrleansRuntime 用于配置和启动silos的库。在您的silos主机项目中引用它。包含在Microsoft.Orleans.Server元软件包中。 Microsoft Orleans运行时抽象 PM> Install-Package Microsoft.Orleans.Runtime.Abstractions 包含Microsoft.Orleans.OrleansRuntime中实现的类型的接口和抽象。 Microsoft Orleans在Azure云服务上托管 PM> Install-Package Microsoft.Orleans.Hosting.AzureCloudServices 包含用于将silos和Orleans客户端托管为Azure云服务的帮助程序类(工作人员角色和Web角色)。 Microsoft Orleans Service Fabric托管支持 PM> Install-Package Microsoft.Orleans.Hosting.ServiceFabric 包含用于将silos作为无状态Service Fabric服务托管的帮助程序类。 集群提供商 以下软件包包括用于在各种存储技术中持久存储集群成员数据的插件。 Microsoft Orleans群集提供者，用于Azure表存储 PM> Install-Package Microsoft.Orleans.Clustering.AzureStorage 包括用于使用Azure表存储群集成员资格数据的插件。 Microsoft Orleans ADO.NET提供程序的群集提供程序 PM> Install-Package Microsoft.Orleans.Clustering.AdoNet 包括用于使用ADO.NET在支持的数据库之一中存储集群成员资格数据的插件。 Microsoft Orleans领事实用程序 PM> Install-Package Microsoft.Orleans.OrleansConsulUtils 包括用于使用Consul存储集群成员数据的插件。 Microsoft Orleans ZooKeeper实用程序 PM> Install-Package Microsoft.Orleans.OrleansZooKeeperUtils 包括用于使用ZooKeeper存储集群成员数据的插件。 适用于AWS DynamoDB的Microsoft Orleans群集提供程序 PM> Install-Package Microsoft.Orleans.Clustering.DynamoDB 包括用于使用AWS DynamoDB存储集群成员数据的插件。 提醒提供者 以下软件包包括用于在各种存储技术中持久保存提醒的插件。 Microsoft Orleans提醒Azure表存储 PM> Install-Package Microsoft.Orleans.Reminders.AzureStorage 包括用于使用Azure表存储提醒的插件。 Microsoft Orleans提醒ADO.NET提供程序 PM> Install-Package Microsoft.Orleans.Reminders.AdoNet 包括用于使用ADO.NET在一个受支持的数据库之一中存储提醒的插件。 Microsoft Orleans提醒提供者，适用于AWS DynamoDB PM> Install-Package Microsoft.Orleans.Reminders.DynamoDB 包括用于使用AWS DynamoDB存储提醒的插件。 grain储存供应商 以下软件包包括用于在各种存储技术中保持grains状态的插件。 Microsoft Orleans Persistence Azure存储 PM> Install-Package Microsoft.Orleans.Persistence.AzureStorage 包括用于使用Azure表或Azure Blob存储Grain状态的插件。 Microsoft Orleans Persistence ADO.NET提供程序 PM> Install-Package Microsoft.Orleans.Persistence.AdoNet 包括用于使用ADO.NET在支持的数据库之一中存储grains状态的插件。 MicrosoftOrleans持久化DynamoDB PM> Install-Package Microsoft.Orleans.Persistence.DynamoDB 包括用于使用AWS DynamoDB存储Grain状态的插件。 流提供者 以下软件包包括用于传递流事件的插件。 Microsoft Orleans ServiceBus实用程序 PM> Install-Package Microsoft.Orleans.OrleansServiceBus 包括Azure事件中心的流提供程序。 Microsoft Orleans流式Azure存储 PM> Install-Package Microsoft.Orleans.Streaming.AzureStorage 包括Azure队列的流提供程序。 Microsoft Orleans Streaming AWS SQS PM> Install-Package Microsoft.Orleans.Streaming.SQS 包括AWS SQS服务的流提供程序。 Microsoft Orleans Google Cloud Platform实用程序 PM> Install-Package Microsoft.Orleans.OrleansGCPUtils 包括GCP PubSub服务的流提供程序。 其他套餐 微软Orleans代码生成 PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator 包括运行时代码生成器。 微软Orleans事件来源 PM> Install-Package Microsoft.Orleans.EventSourcing 包含一组用于创建具有事件源状态的Grains类的基本类型。 开发与测试 微软Orleans供应商 PM> Install-Package Microsoft.Orleans.OrleansProviders 包含一组将数据保留在内存中的持久化和流提供程序。用于测试。通常，不建议将其用于生产，除非可以接受数据丢失以防止孤岛故障。 Microsoft Orleans测试主机库 PM> Install-Package Microsoft.Orleans.TestingHost 包括用于在测试项目中托管孤岛和客户端的库。 序列化器 微软Orleans债券序列化器 PM> Install-Package Microsoft.Orleans.Serialization.Bond 包括对 债券序列化器 。 Microsoft Orleans Google实用工具 PM> Install-Package Microsoft.Orleans.OrleansGoogleUtils 包括Google协议缓冲区序列化程序。 Microsoft Orleans protobuf-net序列化器 PM> Install-Package Microsoft.Orleans.ProtobufNet 包括协议缓冲区串行器的protobuf-net版本。 遥测 MicrosoftOrleans遥测消费者-性能计数器 PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.Counters Orleans Telemetry API的Windows Performance Counter实现。 Microsoft Orleans Telemetry使用者-Azure应用程序见解 PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.AI 包括用于Azure Application Insights的遥测使用者。 微软Orleans遥测消费者-NewRelic PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.NewRelic 包括NewRelic的遥测用户。 工具类 Microsoft Orleans性能计数器工具 PM> Install-Package Microsoft.Orleans.CounterControl 包括OrleansCounterControl.exe，该文件为Orleans统计信息和已部署的Grain类注册Windows性能计数器类别。需要海拔。可以作为角色启动任务的一部分在Azure中执行。 交易次数 Microsoft Orleans Transactions支持 PM> Install-Package Microsoft.Orleans.Transactions 包括对跨Grains交易(测试版)的支持。 Microsoft在Azure上进行Orleans交易 PM> Install-Package Microsoft.Orleans.Transactions.AzureStorage 包括用于在Azure表(beta)中持久保存事务日志的插件。"
  },
  "Documentation/benefits.html": {
    "href": "Documentation/benefits.html",
    "title": "Main Benefits | Microsoft Orleans 中文文档",
    "keywords": "好处 Orleans的主要好处是： 开发人员生产力 ，即使对于非专业程序员也是如此， 默认情况下透明的可伸缩性 不需要程序员的特别努力。我们在下面对这两个好处进行了扩展。 开发人员生产力 Orleans编程模型通过提供以下关键抽象、保证和系统服务，提高了专家和非专家程序员的生产率。 熟悉的面向对象编程(oop)范式 grains是用异步方法实现声明的.net grain接口的.net类。因此，在程序员看来，grains是可以直接调用其方法的远程对象。通过将方法调用转换为消息、将它们路由到正确的端点、调用目标Grain的方法以及以完全透明的方式处理失败和角落情况，这为程序员提供了熟悉的oop范例。 grains 单线程执行 运行时保证一个Grain一次不会在多个线程上执行。再加上与其他Grain的隔离，程序员永远不会在Grain级别面临并发，也不需要使用锁或其他同步机制来控制对共享数据的访问。仅此特性就使得分布式应用程序的开发对于非专家程序员来说是容易的。 透明激活 运行时仅当有要处理的消息时才激活Grains。这将创建对应用程序代码可见并由其控制的grain的引用的概念与对应用程序透明的内存中grain的物理激活的概念完全分离。在许多方面，这类似于虚拟内存，因为它决定何时“换出页”(停用)或“置入页”(激活)一个grains；应用程序可以不间断地访问逻辑创建的grains的全部“内存空间”，无论它们是否在任何特定时间点位于物理内存中。透明激活通过在硬件资源池中存储和迁移Grain实现动态、自适应的负载平衡。这个特性是对传统的actor模型的一个重大改进，其中actor生命周期是由应用程序管理的。 位置透明度 程序员用来调用grain方法或传递给其他组件的grain引用(代理对象)只包含grain的逻辑标识。Grains逻辑标识到其物理位置的转换和相应的消息路由是由orleans运行时透明完成的。应用程序代码与grain进行通信，而不注意它们的物理位置，这可能会随着时间的推移而改变，原因是失败或资源管理，或者是grain在调用时被停用。 与持久存储的透明集成 orleans允许声明性地将grain的内存状态映射到持久化存储。它同步更新，透明地确保调用方仅在成功更新持久状态后才能接收结果。扩展和/或定制现有持久存储提供程序集是直截了当的。 异常的自动传播 运行时使用异步和分布式try/catch的语义自动将未处理的错误传播到调用链上。因此，错误不会在应用程序中丢失。 这允许程序员将错误处理逻辑放在适当的位置，而无需在每个级别手动传播错误的繁琐工作。 默认情况下透明的可伸缩性 orleans编程模型旨在引导程序员在几个数量级上成功地扩展应用程序或服务。这是通过结合经验证的最佳实践和模式以及通过提供较低级别系统功能的有效实现来实现的。以下是实现可伸缩性和性能的一些关键因素： 应用状态的隐式细Grain划分 通过使用Grain作为直接可寻址的实体，程序员隐式地分解了应用程序的整体状态。虽然Orleans编程模型没有规定Grains应该有多大或多小，但在大多数情况下，拥有相对较大数量的Grains(数百万或更多)是有意义的，每个Grains代表应用程序的自然实体，如用户帐户或采购订单。由于grains是独立可寻址的，而物理位置是由运行时抽象出来的，因此Orleans在以透明和通用的方式负载均衡和热点处理方面具有极大的灵活性，而不需要应用程序开发人员关心这个问题。 适应性资源管理 Grains与其他Grains相互作用时，不会假设它们的位置。由于这种位置透明性，运行时可以动态地管理和调整可用硬件资源的分配。运行时通过针对负载和通信模式在计算集群中对Grain的存储和迁移做出细Grain的决策来实现这一点，而不会使传入的请求失败。通过创建特定Grain的多个副本，运行时可以在不更改应用程序代码的情况下提高Grain的吞吐量。 多路通信 Orleans的Grains有逻辑端点，它们之间的消息传递通过一组固定的全对所有物理连接(TCP套接字)进行多路复用。这允许运行时对于每个grain以较低的操作系统开销托管数百万个可寻址实体。此外，Grains的激活和停用不会产生注册/注销物理端点(如TCP端口或HTTP URL)或甚至关闭TCP连接的成本。 高效调度 运行时计划在每个物理处理器内核一个线程的自定义线程池中执行大量单线程Grain。使用以非阻塞、基于连续性的风格(Orleans编程模型的要求)编写的Grain代码，应用程序代码以非常高效的“协作”多线程方式运行，没有争用。这使得系统能够达到高吞吐量，并以非常高的CPU利用率(高达90%+)运行，具有极大的稳定性。系统中grains数量的增长和负载的增加不会导致额外的线程或其他操作系统原语，这一事实有助于单个节点和整个系统的可伸缩性。 显式异步 orleans编程模型使分布式应用程序的异步特性变得明确，并指导程序员编写非阻塞异步代码。结合异步消息传递和高效的调度，这使得无需显式地使用多线程就可以实现很大程度的分布式并行性和总吞吐量。"
  },
  "Documentation/Orleans-2.0.html": {
    "href": "Documentation/Orleans-2.0.html",
    "title": "Orleans 2.0 | Microsoft Orleans 中文文档",
    "keywords": "Orleans2.0 2.0是Orleans的一个主要版本，其主要目标是使其与.NET标准2.0兼容并跨平台(通过.NET Core)。作为这项工作的一部分，OrleansAPI进行了几次现代化，以使其更符合像ASP.NET这样的技术在当今的配置和托管方式。 因为它与.NET标准2.0兼容，所以Orleans 2.0可以被针对.NET核心或完整.NET框架的应用程序使用。核心团队对这个版本进行测试的重点是在.NETFramework框架上，以确保现有的应用程序可以轻松地从1.5迁移到2，并具有完全向后兼容性。 2.0中最显著的变化如下： 完全转移到利用fluid builder模式api的依赖注入的编程配置。 基于配置对象和xml文件的旧api是为了向后兼容而保留的，但不会向前移动，将来会被弃用。有关详细信息，请参见 配置 章节。 应用程序程序集的显式编程规范，它取代了Orleans运行时在silos或客户端初始化时自动扫描文件夹的功能。 orleans仍然会在指定的程序集中自动查找相关类型，如grain接口和类、序列化程序等，但它不再尝试加载在文件夹中可以找到的每个程序集。为了向后兼容，提供了用于加载文件夹中所有程序集的可选助手方法： iapplicationpartmanager.addfromapplicationbasedirectory() 是的。 见 配置 和 迁移 部分了解更多详细信息。 代码生成的彻底检查。 虽然代码生成对开发人员来说基本上是不可见的，但是在处理各种可能类型的序列化时，代码生成变得更加健壮。F组件需要特殊处理。见 代码生成 部分了解更多详细信息。 创建了 Microsoft.Orleans.Core.Abstractions nuget包并将几个类型移动/重构到其中。 grain代码很可能只需要引用这些抽象，而silo主机和客户端将引用更多的orleans包。我们计划不经常更新这个包。 添加对作用域服务的支持。 这意味着每个grain激活都有自己的作用域服务提供者，而orleans注册了一个上下文 IGrainActivationContext 可以注入 瞬变的 或 范围 获取激活特定信息和Grains激活生命周期事件访问权限的服务。这与asp.net core 2.0为每个请求创建作用域上下文的方式类似，但对于orleans，它适用于grain激活的整个生命周期。见 使用寿命和注册选项 在ASP.NET核心文档中获取有关服务生命周期的详细信息。 迁移了要使用的日志基础结构 Microsoft.Extensions.Logging (与ASP.NET Core 2.0相同的摘要)。 2.0包含了对acid分布式跨Grain事务的测试版支持。 该功能将为原型设计和开发做好准备，并将在2.0版本发布后的某个时间毕业用于生产。见 交易 更多细节。"
  },
  "blog/welcome-to-orleans-blog.html": {
    "href": "blog/welcome-to-orleans-blog.html",
    "title": "欢迎来到Orleans博客 | Microsoft Orleans 中文文档",
    "keywords": "欢迎来到Orleans博客 阿提拉·哈吉德里克。 2016年12月1日下午2:15:01 这篇文章是谢尔盖·拜科夫写的。 迟做总比不做好-我们终于为Orleans开了一个博客。具有讽刺意味的是，这个项目起源于近两年前的2008年。我们希望用一些高质量的内容来弥补错过的时间。我们计划分享我们的想法，计划，学习，技巧和诀窍，和想法，疯狂的和其他的，不容易符合文件格式。我们也希望看到来自社区成员的帖子，分享他们的经验、想法和智慧。所以，欢迎来到Orleans博客，无论是作为一个读者还是作为一个博客作者！"
  },
  "blog/de-inventing-the-wheel.html": {
    "href": "blog/de-inventing-the-wheel.html",
    "title": "发明轮子 | Microsoft Orleans 中文文档",
    "keywords": "发明轮子 朱利安·多明格斯 2017年4月12日下午2:49:11 微软Orleans项目开始于许多年前的微软研究，当时连任务类都不存在。随着项目的成熟，需要许多非核心抽象和功能来支持其增长。这些抽象在.NET中并不作为标准存在，.NETOSS还处于初级阶段。这些方面的例子包括横切关注点，如日志记录、配置和依赖注入。 随着时间的推移，出现了一些常见的抽象和模式，并且达到了只采用它们就有意义的程度。原因有很多： 开发人员已经习惯了标准的模式和抽象，所以新手不需要为了使用Orleans而学习这些非核心抽象。 标准抽象的采用程度非常高，几乎每一个第三方组件都与该抽象相关。另一方面，今天它要求Orleans社区为许多第三方组件构建集成包(即：使用Serilog、log4net或push events to ETW)，因为这些组件的所有者只会为公共抽象创建集成包，而不是为Orleans或任何其他非标准抽象创建集成包。 我们创建了定制的抽象来完成这项工作，但是在这之后我们并没有过多地关注可用性，因为它只是进入了维护模式。有时我们发现这些抽象不够好，所以我们必须做出突破性的改变(例如，我们向非静态客户端和silos的迁移需要非静态日志抽象)。 这些标准的抽象是经过深思熟虑来完成特定工作的，通常非常灵活，使用简单，并且有很多文档。我们只是站在他们的肩膀上。 删除对Orleans核心功能不重要的代码总是很好的。 我们已经开始使用 Microsoft.Extensions.DependencyInjection 支持DI的抽象，在很多地方我们不再使用穷人的对象激活(和两步初始化)方法。 随着我们的进一步发展，我们计划对一些定制抽象进行抨击，转而使用标准抽象。特别是我们已经在考虑两个即将到来的变化： 将日志抽象迁移到 Microsoft.Extensions.Logging . 修改我们的配置和启动模式，使之与ASP.NET核心的。看 dotnet/Orleans#2936 对于这个动作的初步设计。 和往常一样，我们会尽量将破坏性更改保持在最低限度，但我们不会严格防止破坏更改。有时，我们使我们的新版本与源代码兼容(这意味着开发人员不能简单地在Orleans程序集上使用绑定重定向，但是重新构建他们的代码可能仍然可以编译)，或者需要一些最小的修复。有时，突破性的改变*更大的*如果它们只会影响到一个小特性或一些通常不会在用户的整个代码库中扩展的东西(例如不影响Grain代码的扩展点)。 而且，现在似乎是一个以全新的思维看待这些抽象的恰当时机，因为这正是.NET社区在展望以下事情时所做的ASP.NET和.NET核心。"
  },
  "blog/orleans-1.4-and-2.0-tech-preview-2-for-.net-core-released.html": {
    "href": "blog/orleans-1.4-and-2.0-tech-preview-2-for-.net-core-released.html",
    "title": "面向.NET Core的Orleans 1.4和2.0 Tech Preview 2发布 | Microsoft Orleans 中文文档",
    "keywords": "面向.NET Core的Orleans 1.4和2.0 Tech Preview 2发布 朱利安·多明格斯(Julian Dominguez) 2017/3/2下午5:54:19 Orleans1.4.0 几周前，我们向NuGet.org发布了Orleans 1.4.0，其中的主要新主题是： 改进了JournaledGrain，用于事件源，并支持基于地理分布的基于日志的一致性提供程序。 具有固定存储的每仓库应用程序组件的Grain Services的抽象，其工作负载通过集群一致性环进行分区。 支持不均匀分布的可用粮仓的异构silos。 Service Fabric的群集成员资格提供程序。 当然，还有许多其他改进和错误修复，您可以在此处阅读： Orleans v1.4.0发行说明 .NET Core的Orleans 2.0 Tech Preview 2 除了我们的标准版本外，我们还在使用支持.NET Standard(和.NET Core主机)的vNext功能。与TP1相似，此新预览版本与Orleans 1.X版本并不完全完全相同，但已经接近。自上次预览以来，我们已完成了许多错误修复，并且该版本是master分支中的最新版本(比1.4.0提前了一点)。 与Orleans1.X的差异 此预发行版本中的一些显着差异或待处理事项： Orleans代码生成 仅当使用Visual Studio 2017或最新的dotnet CLI在Windows上进行构建时，构建时间代码源(Microsoft.Orleans.OrleansCodeGenerator.Build nuget程序包)才有效。 但是，运行时代码生成是跨平台工作的可行替代方法(通过引用Silo宿主和客户端项目中的Microsoft.Orleans.OrleansCodeGenerator程序包)。 .NET Standard中尚不提供BinaryFormatter(内置的.NET序列化)，它已在Orleans中用作默认的后备序列化器(通常在序列化异常时使用)。现在，我们有了一个自定义的基于IL的后备序列化器，该序列化器应快速而强大，但如果您现有的代码依赖于它，则其行为可能会有所不同 [Serializable] 。 .NET标准中不支持System.Diagnostic.Trace.CorrelationManager.ActivityId。如果您依赖于此来关联Grains调用，请考虑改用Orleans.Runtime.RequestContext.ActivityId。 Orleans2.0 TP2的生产准备就绪了吗？ 还没。大声明：我们在.NET中进行CI测试(因为我们的测试严重依赖AppDomains创建内存孤岛群集，而.NET Core不支持这些孤岛，但我们计划尽快解决)。我们已经在.NET Core(包括Windows和Linux)中进行了一些基本的手动测试，并且我们的一些贡献者正在使用它开发新的服务。获得反馈(和PR！)是此版本的主要目标之一，尚未在生产中使用。此外，即使对于已完全移植的功能，也无法保证此技术预览版与Orleans 1.4完全向后兼容。在接近稳定版本之后，我们将列出所有已知的重大更改，以防您有兴趣将应用程序从1.X升级到2.0。 从哪里获得 因为此技术预览版不如1.X版本具有完整功能或稳定性，所以我们现在仅在MyGet中发布。您可以按照以下步骤在此处配置Feed来获取NuGet软件包： https://dotnet.myget.org/gallery/orleans-ci HelloWorld示例 现在，我们的存储库中有一个非常简单的示例，您可以使用它在.NET Core(无论是Windows，Linux还是MacOS中)中试用Orleans。样本位于 https://github.com/dotnet/orleans/tree/master/Samples/HelloWorld.NetCore 。 享受它，玩弄它，并让我们知道您的想法，无论是GitHub问题，PR还是只是在我们的Gitter频道中闲逛。"
  },
  "blog/orleans-2.0-tech-preview-supporting-.net-core.html": {
    "href": "blog/orleans-2.0-tech-preview-supporting-.net-core.html",
    "title": "支持.NET Core的Orleans 2.0 Tech Preview | Microsoft Orleans 中文文档",
    "keywords": "支持.NET Core的Orleans 2.0 Tech Preview 朱利安·多明格斯(Julian Dominguez) 2016/12/5上午11:52:59 使Orleans与.NET Standard兼容已经是一个漫长的过程，但是我们终于有了一个最低限度的可行版本，可以开始在.NET Core中玩了！:) Orleans2.0技术预览版1刚刚发布到MyGet： https://dotnet.myget.org/gallery/orleans-ci (要么 https://dotnet.myget.org/F/orleans-ci/api/v3/index.json 在NuGet中配置Feed) 与Orleans1.X的差异 Orleans2.0技术预览版不具备Orleans1.X的全部功能，因为我们移植了获得体面体验所需的最低要求，并且可以说是移植难度最大/风险最高的部分。我们希望从现在开始，其余扩展的迁移速度会更快。 此预发行版本中的一些显着差异或待处理事项： Orleans代码生成 只有在安装了.NET 4.6.2的Windows上进行构建时，构建时间代码生成器(Microsoft.Orleans.OrleansCodeGenerator.Build nuget程序包)才起作用。它还需要.NET Core Preview3工具或更高版本(如果是在VS中构建，则为VS2017 RC)。 但是，运行时代码生成是跨平台工作的可行替代方法(通过引用Silo宿主和客户端项目中的Microsoft.Orleans.OrleansCodeGenerator程序包)。 为了获得可靠的群集成员身份，存储和流，目前仅迁移了Azure存储提供程序。其余的即将推出(或随时为它们贡献一个端口)。 .NET Standard中尚不提供BinaryFormatter(内置的.NET序列化)，它已在Orleans中用作默认的后备序列化器(通常在序列化异常时使用)。现在，我们有了一个自定义的基于IL的后备序列化器，该序列化器应快速而强大，但如果您现有的代码依赖于它，则其行为可能会有所不同[Serializable]。 .NET标准中不支持System.Diagnostic.Trace.CorrelationManager.ActivityId。如果您依赖于此来关联Grains调用，请考虑改用Orleans.Runtime.RequestContext.ActivityId。 准备生产了吗？ 没有。 大声明：我们在.NET中进行CI测试(因为我们的测试严重依赖AppDomains创建内存孤岛群集，而.NET Core不支持这些孤岛，但我们计划尽快解决)。我们已经在.NET Core(包括Windows和Linux)中完成了一些基本的手动测试，但是会遇到一些问题。获得反馈(和PR！)是此版本的主要目标之一，尚未在生产中使用。 此外，即使对于已完全移植的功能，也无法保证此技术预览版与Orleans 1.3完全向后兼容。一旦接近稳定版本，我们将列出所有已知的重大更改，以防您有兴趣将应用程序从1.3升级到2.0。因为此技术预览版不具备1.X发行版的全部功能，所以我们目前仅在MyGet中发行。 运行样本 我创建了一个在.NET Core中运行的小型Hello World示例应用程序，欢迎您使用它作为起点。 该示例位于此处： https://github.com/jdom/OrleansHelloWorldSample.Core 在Linux中运行Orleans的示例应用程序 享受它，玩弄它，并让我们知道您的想法，无论是GitHub问题，PR还是只是在我们的Gitter频道中闲逛。"
  },
  "blog/dmitry-vakulenko.html": {
    "href": "blog/dmitry-vakulenko.html",
    "title": "德米特里·瓦库连科(Dmitry Vakulenko) | Microsoft Orleans 中文文档",
    "keywords": "德米特里·瓦库连科(Dmitry Vakulenko) 谢尔盖·拜科夫(Sergey Bykov) 2018/11/19下午1:57:59 Dmitry Vakulenko三年前加入了Orleans开源社区，并开始提交侧重于提高Orleans代码库性能的请求。在核心团队的现任和前任成员之外，他成为了最多产的贡献者。 德米特里(Dmitry)也做出了其他改进，但他的激情始终是表现。由于增量优化的复合性质，随着时间的流逝，这些改进加起来达到了惊人的总和。我们的保守估计是，德米特里的贡献使Orleans的表现提高了约2.6倍。 Dmitry的最新贡献是重新实现了Scheduler。调度程序是Orleans运行时的“心脏”，负责高效处理传入的请求，同时确保成千上万的Grains激活中的每一个都以单线程执行。Dmitry贡献的Scheduler的新版本比原始版本快30％，但更简单，调试更友好。它成为2.1.0版本的关键功能。 经过数月的等待签证，德米特里终于计划在10月15日作为微软的全职员工加入核心团队。后来我们得知他在那日期前三天去世了。 对于我们和Orleans周围的整个开源社区来说，这都是一个巨大的悲剧，并且是巨大的损失。我们失去了一位非常有才华的工程师，他在他的职业生涯中还处于早期阶段，并且为他开辟了所有道路。我们失去了与我们合作多年的同事和朋友，并期待着更加紧密的合作。 我们非常感谢德米特里(Dmitry)所做的一切。仍然很难相信他已经不在我们身边了。他会被记住，他是一个聪明的人，一个脾气暴躁的人，总是乐于接受新想法并乐于助人。谢谢你所做的一切，德米特里！"
  },
  "blog/refresh-of-orleans-2.0-tech-preview-with-orleanssqlutils-added.html": {
    "href": "blog/refresh-of-orleans-2.0-tech-preview-with-orleanssqlutils-added.html",
    "title": "添加OrleansSQLUtils刷新Orleans 2.0 Tech Preview | Microsoft Orleans 中文文档",
    "keywords": "添加OrleansSQLUtils刷新Orleans 2.0 Tech Preview 谢尔盖·拜科夫(Sergey Bykov) 2016/12/15下午2:45:47 我们发布了2.0版技术预览版的更新，其中添加了 Microsoft.Orleans.OrleansSqlUtils 包。这样可以使用Microsoft SQL Server，MySQL，PosgreSQL和其他兼容的SQL Server进行群集成员存储和Grain状态持久化。非常感谢 Gutemberg Ribeiro 为帮助！ 您可以从MyGet获取软件包： https://dotnet.myget.org/gallery/orleans-ci (要么 https://dotnet.myget.org/F/orleans-ci/api/v3/index.json 在NuGet中配置Feed)。"
  },
  "blog/orleans-and-midori.html": {
    "href": "blog/orleans-and-midori.html",
    "title": "Orleans和米多里 | Microsoft Orleans 中文文档",
    "keywords": "Orleans和米多里 贝科夫 2016年12月11日下午10:56:13 读乔·达菲的史诗 共事15年 波斯特带来了Orleans早期的一些往事。它甚至迫使我挖掘并尝试编译2009年的代码。这是一个有趣的练习。 当我们刚开始Orleans项目时，我们会定期与Midori人会面和交谈。这是很自然的，不仅是因为问题空间有一些明显的重叠，而且因为孕育Orleans的吉姆·拉鲁斯是 奇点 米多里的起点。我们立即借用了Midori的promises库，因为我们想使用基于promise的并发来安全执行和高效的RPC。我们没有费心尝试集成代码，只是简单地获取了二进制文件并将它们签入到我们的源代码树中。我们处于早期原型阶段，还不必担心长期性。 当时，grains接口是这样的： [Eventual] public interface ISimpleGrain : IEventual { [Eventual] PVoid SetA(int a); [Eventual] PVoid SetB(int b); [Eventual] PInt32 GetAxB(); } PVoid 和 针脚32 在道德上等同于 任务和任务\\<int>在第三方物流 . 与Tasks不同，它们有许多静态方法，其中一个更简单的重载使用两个lambda：一个用于成功案例，另一个用于处理抛出的异常： public static PVoid When(PVoid target, Action fn, Action<Exception> catchFn); 一个简单的纹理方法看起来像： public PVoid SetA(int a) { this.a = a; return PVoid.DONE; } 你可以在这里看到任务完成了。完成了来自。一个简单的单元测试方法看起来相当复杂： [TestMethod] public void SimpleGrainDataFlow() { result = new ResultHandle(); Runner.Enqueue(new SimpleTodo(() => { Promise<SimpleGrainReference> clientPromise = SimpleGrainReference.GetReference(\"foo\"); PVoid.When(clientPromise, reference => { grain = reference; Assert.IsNotNull(grain); PVoid setPromise = grain.SetA(3); PVoid.When(setPromise, () => { setPromise = grain.SetB(4); PVoid.When(setPromise, () => { PInt32 intPromise = grain.GetAxB(); PVoid.When<Int32>(intPromise, x => { result.Result = x; result.Done = true; }, exc => { Assert.Fail(\"Exception thrown by GetAxB: \" + exc.Message); return PVoid.DONE; }); }, exc => { Assert.Fail(\"Exception thrown by SetB: \" + exc.Message); return PVoid.DONE; }); }, exc => { Assert.Fail(\"Exception thrown by SetA: \" + exc.Message); return PVoid.DONE; }); }, exc => { result.Exception = exc; result.Done = true; return PVoid.DONE; }); })); Assert.IsTrue(result.WaitForFinished(timeout)); Assert.IsNotNull(result.Result); Assert.AreEqual(12, result.Result); } 嵌套when是组织数据流执行管道所必需的。 跑步者 是 外国投资者 ，这是注入异步任务的方法之一( 托多 s) 变成一个 托多经理 . 托多经理 是一个单线程执行管理器，也叫增值税， 来自E语言的概念 . 增值税执行系统的初始化是几行代码： todoManager = new TodoManager(); Thread t = new Thread(todoManager.Run); t.Name = \"Unit test TodoManager\"; t.Start(); runner = new ForeignTodoRunner(todoManager); 在一个silos中，我们还使用vats来管理Grains转向的单线程执行。作为silos启动的一部分，我们将其中的N个设置为与可用CPU核心的数量相匹配： for (int i = 0; i < nTodoManagers; i++) { todoManagers[i] = new TodoManager(); for (int j = 0; j < runnerFactor; j++) todoRunners[i \\* runnerFactor + j] = new ForeignTodoRunner(todoManagers[i]); Thread t = new Thread(todoManagers[i].Run); t.Name = String.Format(\"TodoManager: {0}\", i); t.Start(); } 当时我们和迪恩·特里布尔争论说，在我们看来，在承诺上使用静态方法对大多数开发人员来说太不方便了。我们希望它们成为实例方法。几个月后，我们推出了自己的承诺AsyncCompletion和AsyncValue . 他们是任务和任务的包装 和had实例方法。这将代码压缩了不少： [TestMethod] public void SimpleGrainDataFlow() { ResultHandle result = new ResultHandle(); SimpleGrainReference grain = SimpleGrainReference.GetReference(\"foo\"); AsyncCompletion setPromise = grain.SetA(3); setPromise.ContinueWith(() => { setPromise = grain.SetB(4); setPromise.ContinueWith( () => { AsyncValue<int> intPromise = grain.GetAxB(); intPromise.ContinueWith( x => { result.Result = x; result.Done = true; }); }); }); Assert.IsTrue(result.WaitForFinished(timeout)); Assert.IsNotNull(result.Result); Assert.AreEqual(12, result.Result); } 最初，我们允许grain方法是同步的，并将grain引用作为它们的异步代理。 public class SimpleGrain : GrainBase { public void SetA(int a) public void SetB(int b) public int GetAxB() } public class SimpleGrainReference : GrainReference { public AsyncCompletion SetA(int a) public AsyncCompletion SetB(int b) public AsyncValue<int> GetAxB() } 我们很快意识到这是个坏主意，于是改用Grains的方法退货 异步完成 / 异步值<T> . 我们反复考虑，最终放弃了一些其他的坏主意。我们支持Grains类的属性。异步设置器是一个问题，一般来说，异步属性具有相当的误导性，与显式getter方法相比没有任何好处。我们最初支持Grains上的.NET事件。由于.NET中+=和-=操作基本上是同步的，所以不得不废弃它们。 为什么我们不简单地使用 Task / Task<T> 而不是 异步完成 / 异步值<T> ? 为了保证单线程执行，我们需要拦截每个调度和连续调用。 Task 是一个密封类，因此我们无法将其子类化以重写所需的键方法。我们也没有一个定制的TPL调度程序。 在我们转而使用我们自己的承诺之后，我们失去了使用Midori的一些高级功能的机会。例如，他们支持三方承诺切换协议。如果节点A调用了节点B并持有该调用的允诺，但作为处理请求的一部分，B向C发出了对最终值的调用，则B可以传递对A持有的允诺的引用，这样C就可以直接响应A，而不是额外跳回B。在性能和复杂性之间的折衷中，我们选择优先考虑简单性。 我们从与Midori人交谈中得到的另一个教训是，在他们的代码库中，一些最难跟踪的bug的来源是交错执行。尽管vat只有一个线程来执行所有的turns(在屈服点之间同步的代码段)，但它以任意顺序执行属于不同请求的turns是完全合法的。 假设您的组件正在处理一个请求，并且需要调用另一个组件，例如，在其中进行IO调用。您发出那个IO调用，收到完成或返回值的承诺，并使用 什么时候？ 或 继续 调用。这里的陷阱是，当IO调用完成并且计划的延续开始执行时，很容易假设组件的状态自发出IO调用以来没有改变。事实上，组件可能在异步等待IO调用时接收并处理了许多其他请求，而处理这些请求可能会以不明显的方式改变组件的状态。Midori团队非常资深。当时，他们中的大多数是校长和合伙人级别的工程师和建筑师。我们想知道，如果穿插对这种才干和经验的人来说是如此的危险，那对我们这样的凡人来说肯定更糟。这导致后来决定让Orleans的Grains在默认情况下不可再入。 大约在同一时间，Niklas Gustafsson参与了这个项目 大师 后来改名为 阿克苏姆 . 我们在Axum上有一个实习生原型(早期的Orleans应用程序之一)来比较编程体验和2009年春季基于promise的应用程序。我们得出的结论是，对于开发人员来说，promises模型更容易实现。与此同时，尼格拉斯提出了一个建议和一个原型，在他说服了安德斯·赫兹伯格和其他人之后，最终成为了 异步 /awaitC中的关键字#. 到现在，它传播到了更多的语言。 在发布了带有async和await的.net4.5之后，我们最终放弃了 异步完成 / 异步值<T> 赞成 Task / Task<T> 利用等待的力量。这是另一个折衷方案，它让我们重写了几次调度程序(不是一个小任务)，并放弃了我们承诺中的一些好特性。例如，在我们可以轻松检测到grain代码是否试图通过调用 结果 或 等等() 在一个未解决的承诺上 InvalidOperationException异常 表示在silos的协作多任务环境中不允许这样做。我们不能再这样了。但我们获得了今天更干净的编程模型： public interface ISimpleGrain : IGrainWithIntegerKey { Task SetA(int a); Task SetB(int b); Task<int> GetAxB(); } [Fact, TestCategory(\"BVT\"), TestCategory(\"Functional\")] public async Task SimpleGrainDataFlow() { var grain = GrainFactory.GetGrain<ISimpleGrain>(GetRandomGrainId()); Task setAPromise = grain.SetA(3); Task setBPromise = grain.SetB(4); await Task.WhenAll(setAPromise, setBPromise); var x = await grain.GetAxB(); Assert.Equal(12, x); } Midori是一个非常有意义的有趣实验，试图构建一个具有异步性和自上而下隔离的“安全构建”操作系统。从成功、失败和错失的机会来判断这些努力总是很困难的。有一点很清楚，Midori确实影响了Orleans关于异步和并发的早期思考和设计，并帮助引导了它的初始原型。"
  },
  "blog/announcing-orleans-2.0-tech-preview-3.html": {
    "href": "blog/announcing-orleans-2.0-tech-preview-3.html",
    "title": "宣布Orleans2.0技术预览版3 | Microsoft Orleans 中文文档",
    "keywords": "宣布Orleans2.0技术预览版3 朱利安·多明格斯(Julian Dominguez) 2017/9/13下午1:17:21 我们刚刚发布了Orleans2.0技术预览版火车的重大更新。新的二进制文件现在面向.NET Standard 2.0，因此它们与Orleans的.NET版本几乎完全相同。这意味着当前状态不仅对使用.NET Core编写新应用程序的人起作用，而且对于具有已在.NET Framework中运行的应用程序的人来说，也是一种升级途径。 我们完成了吗？ 对于我们团队来说，这是一个激动人心的里程碑，因为它使2.0版本更加接近。在发布之前，我们还需要为此版本做一些剩余的事情，例如： 为.NET Core应用启用生成时代码生成器(.NET Core仍然仅支持运行时代码生成器) 迁移到 Microsoft.Extensions.Logging 对于我们所有的日志记录 充实silos生成器API 通过仅扫描最终用户定义的程序集来改善启动 重组 我们的某些类型具有一个我们不经常版本化的Abstractions项目 拥有交易功能的初始版本 为通常序列化并持久存储的类型提供一定程度的向后兼容性 和其他一些小事 我该如何尝试？ 我们刚刚将软件包发布到MyGet： https://dotnet.myget.org/gallery/orleans-ci 请按照链接获取有关如何配置NuGet以便从该供稿下载程序包的说明。 请帮助我们 我们计划开始更频繁地开始向MyGet提要发布更新的软件包，因此请尝试预览，如果有问题，请告知我们，以便我们可以对其进行修复并在不久后以您的方式发送更新。 Orleans2.0 TP3的生产准备就绪了吗？ 还没。大声明：我们在.NET中进行CI测试(因为我们的测试严重依赖AppDomains创建内存孤岛群集，而.NET Core不支持这些孤岛，但我们计划尽快解决)。我们已经在.NET Core(包括Windows和Linux)中进行了一些基本的手动测试，并且我们的一些贡献者正在使用它开发新的服务。获得反馈(和PR！)是此版本的主要目标之一，尚未在生产中使用。此外，即使对于已完全移植的功能，也无法保证此技术预览版与Orleans 1.5完全向后兼容。在接近稳定版本之后，我们将列出所有已知的重大更改，以防您有兴趣将应用程序从1.X升级到2.0。 笔记 如果您使用的是较早的技术预览，请注意程序集加载发生了一些变化，我们希望继续进行更改。同时，请注意，在.NET Core中，可能需要发布应用程序，以便所有要扫描的程序集都在同一文件夹中(您可以通过调用` dotnet发布 `在您的silos主机上)。"
  },
  "blog/announcing-orleans-2.1.html": {
    "href": "blog/announcing-orleans-2.1.html",
    "title": "宣布Orleans2.1 | Microsoft Orleans 中文文档",
    "keywords": "宣布Orleans2.1 鲁本·邦德 2018/10/1下午7:17:59 今天，我们宣布了Orleans2.1。此版本包括对2.0的重大性能改进，对分布式事务支持的重大更新，新的代码生成器以及用于共同托管方案的新功能，以及较小的修复和改进。阅读 在这里发布说明 。 新调度程序 从Orleans2.1开始，我们有一个 重写核心调度程序 利用 .NET Core的ThreadPool的性能改进 。新的调度程序使用具有本地队列相似性的工作窃取队列来减少争用并提高吞吐量和延迟。这些改进适用于所有平台/框架。社区成员报告说他们的服务具有显着的响应能力和吞吐量改进，而我们的测试表明吞吐量提高了30％。这种新的调度程序在低负载期间的CPU使用率也要低得多，这有利于共同托管方案并改善CPU性能分析体验。特别感谢 德米特罗·瓦库连科(Dmytro Vakulenko) 从社区推动这项工作从理论到实验和完成。 分布式交易 Orleans起源于Microsoft Research，我们将继续与MSR和产品团队合作，将可扩展的分布式事务等功能引入生产环境。分布式事务支持最初是在Orleans2.0中作为实验性功能引入的，而在2.1中，我们将使用新的完全分散的事务管理器来刷新发行版。除了对交易管理器进行了改进之外，整个交易系统仍在继续进行大量投资，以准备生产代码并在Orleans的未来版本中稳定发布。我们认为分布式事务在2.1中具有“候选发布”质量。从Sergey的演讲中了解Orleans的分布式交易， 分布式事务已死，分布式事务万岁！来自J On the Beach 2018 。阅读有关交易，面向参与者的数据库系统以及其他主题的研究论文。 OrleansMicrosoft Research网站 。 直接客户 Orleans2.1引入了一种与Grains进行交互并与ASP.NET或gRPC等框架进行互操作的新方法。该功能称为 直接客户 并且它允许以一种方式共同托管客户端和孤岛，从而使客户端不仅可以与其连接的孤岛，而且可以与整个集群进行更有效的通信。启用直接客户端后， ICluster客户端 和 IGrain工厂 可以从silos容器中解析出来，并用于创建可以调用的Grains引用。这些调用使用本地silos对群集和grains位置的了解来避免不必要的复制，序列化和网络跃点。另外，由于此功能与silos本身具有相同的内部结构，因此在线程间传递Grains引用时，它提供了无缝的体验。在Orleans2.1中，我们将直接客户作为选择加入的功能。通过调用启用它 ISiloHostBuilder.EnableDirectClient() 在silos配置期间。 新代码生成器 此版本包括一个新的代码生成包， Microsoft.Orleans.CodeGenerator.MSBuild ，是现有软件包的替代品， Microsoft.Orleans.OrleansCodeGenerator.Build 。新的代码生成器利用Roslyn进行代码分析，以避免加载应用程序二进制文件。结果，它避免了因相互依赖的版本冲突和目标框架不同而导致的问题。如果您遇到问题，请通过打开一个问题告知我们 的GitHub 。新的代码生成器还改善了对增量构建的支持，这将缩短构建时间。 其他改进 Grains方法可以返回 ValueTask <T> - 谢谢 @kutensky 删除了每次访问计时器分配 ，减少.NET Timer队列争用 修正 对于 Silo关闭行为-谢谢 @yevhen 用于报告和 调查中 配置Grains收集 空闲时间使用 [CollectionAgeLimit(分钟= x)] - 谢谢 @aRajeshKumar .NET Core 2.1的已知问题 用户 孙忠峰报告了问题 在启用TieredCompilation的.NET Core 2.1上运行Orleans。我们将此归结为 CoreCLR中的JIT问题 ，CoreCLR团队迅速对其进行了诊断和修复。.NET Core 2.1默认情况下未启用TieredCompilation，并且此修复程序是 预计不会出现在.NET Core 2.1中，但将包含在.NET Core 2.2中 。 如果您在.NET Core 2.1上运行Orleans，请不要启用TieredCompilation。 我们要感谢社区中为该版本做出贡献并帮助测试预发行版本的每个人。"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Debugging.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Debugging.html",
    "title": "Debugging and Symbols | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Debugging An Orleans-based application can be easily debugged during development by attaching a debugger to the silo host process or to the client process . For fast development iterations, it is convenient to use a single process that combines a silos and a client, such as a console application project that gets created by the Orleans Dev/Test Host project template that is part of the Microsoft Orleans Tools extension for Visual Studio. Similarly, debugger can be attached to the Worker/Web Role instance process when running inside the Azure Compute Emulator. In production, it is rarely a good idea to stop a silo at a breakpoint because the frozen silo will soon get voted dead by the cluster membership protocol and will not be able to communicate with other silos in the cluster. Hence, in productions tracing is the primary 'debugging' mechanism. Source Link Starting with the 2.0.0-beta1 release we added Source Link support to our Symbols. It means that if a project consumes the Orleans NuGet packages, when debugging the application code, they can step into the Orleans source code. In Steve Gordon's blog post , you can see what steps are needed to configure it. Symbols Starting with 1.3.0 release, symbols for Orleans binaries are published to Microsoft symbol servers. Make sure you enable Microsoft Symbol Servers in Visual Studio in Tools/Options/Debugging/Symbols for debugging Orleans code. Prior to 1.3.0, symbols were published to https://nuget.smbsrc.net/ symbol server. Add it to the list of symbol servers in Visual Studio in Tools/Options/Debugging/Symbols. Make sure there is a trailing slash in the URL. Visual Studio 2015 has a bug with parsing it. Sources You can download zipped sources for specific releases of Orleans from the Releases page . However, due to the LF/CR differences between Windows and Unix (default for GitHub), debugger may complain about a mismatch of the sources and symbols. The workaround is to check out the corresponding version tag on a Windows machine to get sources with the matching LF/CR ending."
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Grain.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Grain.html",
    "title": "Developing a Grain | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Please read about Grains before reading this article. Setup Before you write code to implement a grain class, create a new Class Library project targeting .NET 4.6.1 or higher in Visual Studio and add the Microsoft.Orleans.OrleansCodeGenerator.Build NuGet package to it. PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build Grain Interfaces and Classes Grains interact with each other and get called from outside by invoking methods declared as part of the respective grain interfaces. A grain class implements one or more previously declared grain interfaces. All methods of a grain interface must return a Task (for void methods) or a Task<T> (for methods returning values of type T ). The following is an excerpt from the Presence Service sample: //an example of a Grain Interface public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } //an example of a Grain class implementing a Grain Interface public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGame() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGame(IGameGrain game) { currentGame = game; Console.WriteLine( \"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGame(IGameGrain game) { currentGame = null; Console.WriteLine( \"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } } Returning Values from Grain Methods A grain method that returns a value of type T is defined in a grain interface as returning a Task<T> . For grain methods not marked with the async keyword, when the return value is available, it is usually returned via the following statement: public Task<SomeType> GrainMethod1() { ... return Task.FromResult(<variable or constant with result>); } A grain method that returns no value, effectively a void method, is defined in a grain interface as returning a Task . The returned Task indicates asynchronous execution and completion of the method. For grain methods not marked with the async keyword, when a \"void\" method completes its execution, it needs to return the special value of Task.CompletedTask : public Task GrainMethod2() { ... return Task.CompletedTask; } A grain method marked as async returns the value directly: public async Task<SomeType> GrainMethod3() { ... return <variable or constant with result>; } A \"void\" grain methods marked as async that returns no value simply returns at the end of their execution: public async Task GrainMethod4() { ... return; } If a grain method receives the return value from another asynchronous method call, to a grain or not, and doesn't need to perform error handling of that call, it can simply return the Task it receives from that asynchronous call as its return value: public Task<SomeType> GrainMethod5() { ... Task<SomeType> task = CallToAnotherGrain(); return task; } Similarly, a \"void\" grain method can return a Task returned to it by another call instead of awaiting it. public Task GrainMethod6() { ... Task task = CallToAsyncAPI(); return task; } Grain Reference A Grain Reference is a proxy object that implements the same grain interface as the corresponding grain class. It encapsulates a logical identity (type and unique key) of the target grain. A grain reference is what is used for making calls to the target grain. Each grain reference is for a single grain (a single instance of the grain class), but one can create multiple independent references for the same grain. Since a grain reference represents a logical identity of the target grain, it is independent from the physical location of the grain, and stays valid even after a complete restart of the system. Developers can use grain references like any other .NET object. It can be passed to a method, used as a method return value, etc., and even saved to persistent storage. A grain reference can be obtained by passing the identity of a grain to the GrainFactory.GetGrain<T>(key) method, where T is the grain interface and key is the unique key of the grain within the type. The following are examples of how to obtain a grain reference of the IPlayerGrain interface defined above. From inside a grain class: //construct the grain reference of a specific player IPlayerGrain player = GrainFactory.GetGrain<IPlayerGrain>(playerId); From Orleans Client code. Prior to 1.5.0: IPlayerGrain player = GrainClient.GrainFactory.GetGrain<IPlayerGrain>(playerId); Since 1.5.0: IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Grain Method Invocation The Orleans programming model is based on the Asynchronous Programming with Async and Await . Using the grain reference from the previous example, here's how one performs a grain method invocation: //Invoking a grain method asynchronously Task joinGameTask = player.JoinGame(this); //The await keyword effectively makes the remainder of the method execute asynchronously at a later point (upon completion of the Task being awaited) without blocking the thread. await joinGameTask; //The next line will execute later, after joinGameTask is completed. players.Add(playerId); It is possible to join two or more Tasks ; the join operation creates a new Task that is resolved when all of its constituent Task s are completed. This is a useful pattern when a grain needs to start multiple computations and wait for all of them to complete before proceeding. For example, a front-end grain that generates a web page made of many parts might make multiple back-end calls, one for each part, and receive a Task for each result. The grain would then await the join of all of these Tasks ; when the join Task is resolved, the individual Task s have been completed, and all the data required to format the web page has been received. Example: List<Task> tasks = new List<Task>(); Message notification = CreateNewMessage(text); foreach (ISubscriber subscriber in subscribers) { tasks.Add(subscriber.Notify(notification)); } // WhenAll joins a collection of tasks, and returns a joined Task that will be resolved when all of the individual notification Tasks are resolved. Task joinedTask = Task.WhenAll(tasks); await joinedTask; // Execution of the rest of the method will continue asynchronously after joinedTask is resolve. Virtual methods A grain class can optionally override OnActivateAsync and OnDeactivateAsync virtual methods that get invoked by the Orleans runtime upon activation and deactivation of each grain of the class. This gives the grain code a chance to perform additional initialization and cleanup operations. An exception thrown by OnActivateAsync fails the activation process. While OnActivateAsync , if overridden, is always called as part of the grain activation process, OnDeactivateAsync is not guaranteed to get called in all situations, for example, in case of a server failure or other abnormal events. Because of that, applications should not rely on OnDeactivateAsync for performing critical operations, such as persistence of state changes, and only use it for best effort operations. Next Developing a Client"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Grains.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Grains.html",
    "title": "Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grains Grains are the key primitives of the Orleans programming model. Grains are the building blocks of an Orleans application, they are atomic units of isolation, distribution, and persistence. Grains are objects that represent application entities. Just like in the classic Object Oriented Programming, a grain encapsulates state of an entity and encodes its behavior in the code logic. Grains can hold references to each other and interact by invoking each other’s methods exposed via interfaces. Orleans aims to greatly simplify building a scalable application and eliminate most of the concurrency challenges By not sharing data between grains instances except via message passing. By providing the single-threaded execution guarantee to each individual grain. A typical grain encapsulates state and behavior of a single entity (e.g. a specific user or a device or a session). Grain Identity An individual grain is a uniquely addressable instance of a grain type (class). Each grain has a unique identity, also referred to as a grain key, within its type. Grain identity within its type can be a long integer, a GUID, a string, or a combination of a long+string or GUID+string. Accessing a Grain A grain class implements one or more grain interfaces, formal code contracts for interacting with grains of that type. To invoke a grain, a caller needs to know the grain interface that the grain class implements that includes the method that the caller wants to call and the unique identity (key) of the target grain. For example, here's how a user profile grain can be called to update user's address if email is used as a user identity. var user = grainFactory.GetGrain<IUserProfile>(userEmail); await user.UpdateAddress(newAddress); A call to GetGrain is an inexpensive local operation of constructing a grain reference with an embedded identity and type of the target grain. Note that there is no need to create or instantiate the target grain. We make a call to it to update user's address as if the user's grain is already instantiated for us. This is one of the biggest advantages of the Orleans programming model - we never need to create, instantiate or delete grains. We can write our code as if all possible grains, for example millions of user profiles, are always in memory waiting for us to call them. Behind the scenes, the Orleans runtime performs all the heavy lifting of managing resources to transparently bring grains to memory when needed. Behind the Scenes - Grain Lifecycle Grains live in execution containers called silos. Silos form a cluster that combines resources of multiple physical or virtual machines. When there is work (request) for a grain, Orleans ensures there is an instance of the grain on one of the Silos in the cluster. If there is no instance of the grain on any silo, the Orleans runtime creates one. This process is called Activation. In case a grain is using Grain Persistence , the runtime automatically reads the state from the backing store upon activation. Once activated on a silo, a grain processes incoming requests (method calls) from other grains or from outside of the cluster (usually from frontend web servers). In the course of processing a request a grain may call other grains or some external services. If a grain stops receiving requests and stays idle, after a configurable period of inactivity Orleans removes the grain from memory (deactivates it) to free up resources for other grains. If and when there's a new request for that grain, Orleans will activate it again, potentially on a different silo, so the caller gets the impression that the grain stayed in memory the whole time. A grain goes through the lifecycle from existing only as its persisted state (if it has any) in storage to being instantiated in memory to being removed from memory. Orleans controls the process of activating and deactivating grains transparently. When coding a grain, a developer assumes all grains are always activated. The sequence of key events in grain lifecycle looks like this. Another grain or a client makes a call to a method of the grain (via a grain reference) The grain gets activated (if it is not already activated somewhere in the cluster) and an instance of the grain class, called a grain activation, is created Constructor of the grain is executed leveraging Dependency Injection if applicable If Declarative Persistence is used, the grain state is read from storage If overridden, OnActivateAsync is called The grain processes incoming requests The grain remains idle for some time Silo runtime decides to deactivate the grain Silo runtime calls OnDeactivateAsync , if overridden Silo runtime removes the grain from memory Upon a graceful shutdown of a silo, all grain activations it holds get deactivated. Any requests waiting to be processed in grains' queues get forwarded to other silos in the cluster, where new activations of deactivated grains get created on an as-needed basis. If a silo shuts down or dies ungracefully, other silos in the cluster detect the failure, and start creating new activations of grains lost on the failed silo, as new requests for those grains arrive. Note that detection of a silo failure takes some time (configurable), and hence the process of reactivating lost grains isn't instantaneous. Grain Execution A grain activation performs work in chunks and finishes each chunk before it moves on to the next. Chunks of work include method invocations in response to requests from other grains or external clients, and closures scheduled on completion of a previous chunk. The basic unit of execution corresponding to a chunk of work is known as a turn. While Orleans may execute many turns belonging to different activations in parallel, each activation will always execute its turns one at a time. This means that there is no need to use locks or other synchronization methods to guard against data races and other multi-threading hazards. Next Next we look at how to implement a grain class. Developing a Grain"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Running-the-Application.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Running-the-Application.html",
    "title": "Running the Application | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Application As was illustrated in the previous topic , a typical Orleans application consists of a cluster of server processes (silos) where grains live, and a set of client processes, usually web servers, that receive external requests, turn them into grain method calls, and return results back. Hence, the first thing one needs to do to run an Orleans application is to start a cluster of silos. For testing purposes, a cluster can consist of a single silo. For a reliable production deployment, we obviously want more than one silos in a cluster for fault tolerance and scale. Once the cluster is running, we can start one or more client processes that connect to the cluster and can send requests to the grains. Clients connect to a special TCP endpoint on silos - gateway. By default, every silo in a cluster has a client gateway enabled. So clients can connect to all silos in parallel for better performance and resilience. Configuring and Starting a Silo A silo is configured programmatically via a ClusterConfiguration object. It can be instantiated and populated directly, load settings from a file, or created with several available helper methods for different deployment environments. For local testing, the easiest way to go is to use ClusterConfiguration.LocalhostPrimarySilo() helper method. The configuration object is then passed to a new instance of SiloHost class, that can be initialized and started after that. You can create an empty console application project targeting .NET Framework 4.6.1 or higher for hosting a silo. Add the Microsoft.Orleans.Server NuGet meta-package to the project. PM> Install-Package Microsoft.Orleans.Server Here is an example of how a local silo can be started: var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"Test Silo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Press Enter to close.\"); // wait here Console.ReadLine(); // shut the silo down after we are done. silo.ShutdownOrleansSilo(); Configuring and Connecting a Client Client for connecting to a cluster of silos and sending requests to grains is configured programmatically via a ClientConfiguration object and a ClientBuilder . ClientConfiguration object can be instantiated and populated directly, load settings from a file, or created with several available helper methods for different deployment environments. For local testing, the easiest way to go is to use ClientConfiguration.LocalhostSilo() helper method. The configuration object is then passed to a new instance of ClientBuilder class. ClientBuilder exposes more methods for configuring additional client features. After that Build method of the ClientBuilder object is called to get an implementation of IClusterClient interface. Finally, we call Connect() method on the returned object to connect to the cluster. You can create an empty console application project targeting .NET Framework 4.6.1 or higher for running a client or reuse the console application project you created for hosting a silo. Add the Microsoft.Orleans.Client NuGet meta-package to the project. PM> Install-Package Microsoft.Orleans.Client Here is an example of how a client can connect to a local silo: var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder().UseConfiguration(config). var client = builder.Build(); await client.Connect(); Production Configurations The configuration examples we used here are for testing silos and clients running on the same machine as localhost . In production, silos and clients usually run on different servers and are configured with one of the reliable cluster configuration options. You can find more about that in the Configuration Guide and in the description of Cluster Management . Next Debugging"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.html",
    "title": "Typical Configurations | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Typical Configurations Below are examples of typical configurations that can be used for development and production deployments. Local Development For local development, where there is only one silo running locally on the programmer’s machine, the configuration is already included in the Orleans Dev/Test Host project template of Microsoft Orleans Tools for Visual Studio . The local silo that can be started by running a project created with the Orleans Dev/Test Host template is configured as follows in DevTestServerConfiguration.xml. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"localhost\" Port=\"11111\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Silo configuration via code is as follows. var config = ClusterConfiguration.LocalhostPrimarySilo(11111, 30000); To connect to the local silo, the client needs to be configured to localhost and can only connect from the same machine. The Orleans client that can be started by running a project created with the Orleans Dev/Test Host template is configured as follows in DevTestClientConfiguration.xml <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"localhost\" Port=\"30000\"/> </ClientConfiguration> Client configuration via code is as follows. var config = ClientConfiguration.LocalhostSilo(30000); Reliable Production Deployment Using Azure For a reliable production deployment using Azure, you need to use the Azure Table option for cluster membership. This configuration is typical of deployments to either on-premise servers or Azure virtual machine instances. The format of the DataConnection string is \"DefaultEndpointsProtocol=https;AccountName= ;AccountKey= \" <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"<your deployment ID>\" DataConnectionString=\"<<see comment above>>\" /> <Liveness LivenessType =\"AzureTable\" /> </Globals> <Defaults> <Networking Address=\"\" Port=\"11111\" /> <ProxyingGateway Address=\"\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Clients need to be configured to use Azure Table for discovering the gateways, the addresses of the Orleans servers are not statically known to the clients. <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"target deployment ID\" DataConnectionString=\"<<see comment above>>\" /> </ClientConfiguration> Reliable Production Deployment Using ZooKeeper For a reliable production deployment using ZooKeeper, you need to use the ZooKeeper option for cluster membership. This configuration is typical of deployments to on-premise servers. The format of the DataConnection string is documented in the ZooKeeper Programmer's Guide . A minimum of 5 ZooKeeper servers is recommended . <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"<your deployment ID>\" DataConnectionString=\"<<see comment above>>\"/> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Clients need to be configured to use ZooKeeper for discovering the gateways, the addresses of the Orleans servers are not statically known to the clients. ﻿<?xml version=\"1.0\" encoding=\"utf-8\" ?> <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"target deployment ID\" DataConnectionString=\"<<see comment above>>\"/> </ClientConfiguration> Reliable Production Deployment Using SQL Server For a reliable production deployment using SQL server, a SQL server connection string needs to be supplied. Silo configuration via code is as follows, and includes logging configuration. var connectionString = @\"Data Source=MSSQLDBServer;Initial Catalog=Orleans;Integrated Security=True; Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; var config = new ClusterConfiguration{ Globals = { DataConnectionString = connectionString, DeploymentId = \"<your deployment ID>\", LivenessType = GlobalConfiguration.LivenessProviderType.SqlServer, LivenessEnabled = true, ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.SqlServer }, Defaults = { Port = 11111, ProxyGatewayEndpoint = new IPEndPoint(address, 30000), PropagateActivityId = true }}; var siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); Clients need to be configured to use SQL server for discovering the gateways, as with Azure and Zookeeper, the addresses of the Orleans servers are not statically known to the clients. var connectionString = @\"Data Source=MSSQLDBServer;Initial Catalog=Orleans;Integrated Security=True; Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; var config = new ClientConfiguration{ GatewayProvider = ClientConfiguration.GatewayProviderType.SqlServer, AdoInvariant = \"System.Data.SqlClient\", DataConnectionString = connectionString, DeploymentId = \"<your deployment ID>\", PropagateActivityId = true }; var client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); Unreliable Deployment on a Cluster of Dedicated Servers For testing on a cluster of dedicated servers when reliability isn’t a concern you can leverage MembershipTableGrain and avoid dependency on Azure Table. You just need to designate one of the nodes as a Primary. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"<primary node>\" Port=\"11111\" /> <Liveness LivenessType =\"MembershipTableGrain\" /> </Globals> <Defaults> <Networking Address=\" \" Port=\"11111\" /> <ProxyingGateway Address=\" \" Port=\"30000\" /> </Defaults> </OrleansConfiguration> For the client: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"node-1\" Port=\"30000\"/> <Gateway Address=\"node-2\" Port=\"30000\"/> <Gateway Address=\"node-3\" Port=\"30000\"/> </ClientConfiguration> Azure Worker Role Deployment When Orleans is deployed into an Azure Worker role, as opposed to VM instances, most of the server-side configuration is actually done in files other than the OrleansConfiguration, which looks something like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Liveness LivenessType=\"AzureTable\" /> </Globals> <Defaults> <Tracing DefaultTraceLevel=\"Info\" TraceToConsole=\"true\" TraceToFile=\"{0}-{1}.log\" /> </Defaults> </OrleansConfiguration> Some information is kept in the service configuration file, in which the worker role section looks like this: <Role name=\"OrleansAzureSilos\"> <Instances count=\"2\" /> <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"<<see earlier comment>>\" /> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"<<see earlier comment>>\" /> </ConfigurationSettings> </Role> The data connection string and the diagnostics connection string do not have to be the same. Some configuration information is kept in the service definition file. The worker role has to be configured there, too: <WorkerRole name=\"OrleansAzureSilos\" vmsize=\"Large\"> <Imports> <Import moduleName=\"Diagnostics\" /> </Imports> <ConfigurationSettings> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <LocalResources> <LocalStorage name=\"LocalStoreDirectory\" cleanOnRoleRecycle=\"false\" /> </LocalResources> <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> </WorkerRole> That's it for the worker role hosting the Orleans runtime. However, when deploying to Azure, there is typically a front end of some sort, either a web site or a web service, since making the Orleans ports public is not a good idea. Therefore, the client configuration is configuration of the web or worker role (or web site) that sits in front of Orleans. Important Note As of November 2017, there is a limitation in Azure Cloud Services which prevents firewall configuration of InternalEndpoint s if there is only 1 role in the Cloud Service. If you are connecting to your cloud service via a Virtual Network, you will have to scale your Cloud Services to two instances in order for the firewall rules to be created Assuming that the frontend is a web role, a simple ClientConfiguration file should be used: <ClientConfiguration xmlns=\"urn:orleans\"> <Tracing DefaultTraceLevel=\"Info\" TraceToConsole=\"true\" TraceToFile=\"{0}-{1}.log\" WriteTraces=\"false\"/> </ClientConfiguration> The web role needs the same connection string information as the worker role, in the service configuration file: <Role name=\"WebRole\"> <Instances count=\"2\" /> <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"<<see earlier comment>>\" /> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"<<see earlier comment>>\" /> </ConfigurationSettings> </Role> and in the service definition file: <WebRole name=\"WebRole\" vmsize=\"Large\"> <Imports> <Import moduleName=\"Diagnostics\" /> </Imports> <ConfigurationSettings> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <!-- There is additional web role data that has nothing to do with Orleans --> </WebRole>"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html",
    "title": "Client Configuration | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Client Configuration The key parameter that has to be configured for a client is the silo’s client gateway endpoint(s) to connect to. There are two ways to do that: manually configure one or more gateway endpoints or point the client to the Azure Table used by silos’ cluster membership. In the latter case the client automatically discovers what silos with client gateways enabled are available within the deployment, and adjusts its connections to the gateways as they join or leave the cluster. This option is reliable and recommended for production deployment. Fixed Gateway Configuration A fixed set of gateways is specified in the ClientConfiguration.xml with one or more Gateway nodes: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"gateway1\" Port=\"30000\"/> <Gateway Address=\"gateway2\" Port=\"30000\"/> <Gateway Address=\"gateway3\" Port=\"30000\"/> </ClientConfiguration> One gateway is generally enough. Multiple gateway connections help increase throughput and reliability of the system. Gateway Configuration Based on Cluster Membership To configure the client to automatically find gateways from the silo cluster membership table, you need to specify the Azure Table or SQL Server connection string and the target deployment ID. <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"target deployment ID\" DataConnectionString=\"Azure storage connection string\"/> </ClientConfiguration> or <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"SqlServer\" DeploymentId=\"target deployment ID\" DataConnectionString=\"SQL connection string\"/> </ClientConfiguration> or <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"target deployment ID\" DataConnectionString=\"ZooKeeper connection string\"/> </ClientConfiguration> Local Silo For the local development/test configuration that uses a local silo, the client gateway should be configured to 'localhost.' <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"localhost\" Port=\"30000\"/> </ClientConfiguration> Web Role Client in Azure When the client is a web role running inside the same Azure deployment as the silo worker roles, all gateway address information is read from the OrleansSiloInstances table when OrleansAzureClient.Initialize() is called. The Azure storage connection string used to find the correct OrleansSiloInstances table is specified in the \"DataConnectionString\" setting defined in the service configuration for the deployment & role. <ServiceConfiguration ...> <Role name=\"WebRole\"> ... <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\" /> </ConfigurationSettings> </Role> ... </ServiceConfiguration> Both the silo worker roles and web client roles need to be use the same Azure storage account in order to successfully discover each other successfully. When using OrleansAzureClient.Initialize() and OrleansSiloInstances table for gateway address discovery, no additional gateway address info in required in the client config file. Typically the ClientConfiguration.xml file will only contain some minimal debug / tracing configuration settings, although even that is not required. <ClientConfiguration xmlns=\"urn:orleans\"> <Tracing DefaultTraceLevel=\"Info\" > <TraceLevelOverride LogPrefix=\"Application\" TraceLevel=\"Info\" /> </Tracing> </ClientConfiguration> Code-based client configuration. This is a reference only example and SHOULD NOT be used AS-IS - you may need to fine-tune client parameters for your specific environment. var dataConnection = \"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\"; var config = new ClientConfiguration { // Some top level features GatewayProvider = ClientConfiguration.GatewayProviderType.AzureTable, ResponseTimeout = TimeSpan.FromSeconds(30), DeploymentId = RoleEnvironment.DeploymentId, DataConnectionString = dataConnection, PropagateActivityId = true, // Tracing DefaultTraceLevel = Severity.Info, TraceToConsole = false, TraceFilePattern = @\"Client_{0}-{1}.log\", //TraceFilePattern = \"false\", // Set it to false or none to disable file tracing, effectively it sets config.Defaults.TraceFileName = null; TraceLevelOverrides = { Tuple.Create(\"ComponentName\", Severity.Warning), } }; config.RegisterStreamProvider<AzureQueueStreamProvider>(\"AzureQueueStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" }, { \"DeploymentId\", \"orleans-streams\" }, // This will be a prefix name of your Queues - so be careful and use string that is valid for queue name { \"NumQueues\", \"4\" }, { \"GetQueueMessagesTimerPeriod\", \"100ms\" }, { \"DataConnectionString\", dataConnection } }); config.RegisterStreamProvider<SimpleMessageStreamProvider>(\"SimpleMessagingStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" } }); IClusterClient client = null; while (true) { try { // Build a client and then connect it to the cluster. client = new ClientBuilder() .UseConfiguration(config) .ConfigureServices( services => { // Services can be provided to the client here. These services are made // available via dependency injection. // ConfigureServices can be called multiple times for a single // ClientBuilder instance. }) .Build(); // Connect the client to the cluster. Once connection succeeds, the client will // maintain the connection, automatically reconnecting as necessary. await client.Connect().ConfigureAwait(false); break; } catch (Exception exception) { // If the connection attempt fails, the client instance must be disposed. client?.Dispose(); // TODO: Log the exception. // TODO: Add a counter to break up an infinite cycle (circuit breaker pattern). await Task.Delay(TimeSpan.FromSeconds(5)); } } // Use the client. // Note that clients can be shared between threads and are typically long-lived. var user client.GetGrain<IUserGrain>(\"leeroy77jenkins@battle.net\"); Console.WriteLine(await user.GetProfile());"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html",
    "title": "SQL Tables | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . SQL System Storage Any reliable production-style Orleans deployment requires using persistent storage to keep system state, specifically Orleans cluster status and the data used for the reminders functionality. In addition to out of the box support for Azure storage Orleans also provides an option to store this information in SQL server. In order to use SQL server for the system store, one needs to adjust server-side and client-side configurations. The server configuration should look like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType =\"SqlServer\" DeploymentId=\"OrleansTest\" DataConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" AdoInvariant=\"System.Data.SqlClient\" /> </Globals> </OrleansConfiguration> The client configuration should look like this: <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType =\"SqlServer\" DeploymentId=\"OrleansTest\" DataConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" AdoInvariant=\"System.Data.SqlClient\" /> </ClientConfiguration> Where the DataConnectionString is set to any valid SQL Server connection string. In order to use SQL Server as the store for system data, there’s now a script file CreateOrleansTables_*.sql (where asterisk denotes database vendor) in the Binaries\\OrleansServer folder which establishes the necessary database objects. Make sure that all servers that will be hosting Orleans silos can reach the database and has access rights to it! We’ve tripped up a few times on this seemingly trivial concern during our testing. Note that in Orleans 2.0.0 those SQL scripts have been split into per-feature pieces to match the finer grain provider model: Clustering , Persistence , Reminders , and Statistics . SQL Metrics and Statistics tables System tables can currently only be stored in Azure table or SQL server. For Metrics and Statistics tables however, we provide a generic support to host it in any persistent storage. This is provided via the notion of a StatisticsProvider . Any application can write an arbitrary provider to store statistics and metrics data in a persistent store of their choice. Orleans provides an implemention of one such provider: SQL Table Statistics Provider. In order to use SQL server for statistics and metrics tables, one needs to adjust server-side and client-side configurations. The server configuration should look like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StatisticsProviders> <Provider Type=\"Orleans.Providers.SqlServer.SqlStatisticsPublisher\" Name=\"MySQLStatsProvider\" ConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" /> </StatisticsProviders> </Globals> <Defaults> <Statistics ProviderType=\"MySQLStatsProvider\" WriteLogStatisticsToTable=\"true\"/> </Defaults> </OrleansConfiguration> The client configuration should look like this: <ClientConfiguration xmlns=\"urn:orleans\"> <StatisticsProviders> <Provider Type=\"Orleans.Providers.SqlServer.SqlStatisticsPublisher\" Name=\"SQL\" ConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" /> </StatisticsProviders> <Statistics ProviderType=\"MySQLStatsProvider\" WriteLogStatisticsToTable=\"true\"/> </ClientConfiguration>"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html",
    "title": "Server Configuration | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Server Configuration There are two key aspects of silo configuration: Connectivity: silo’s endpoints for other silos and clients Cluster membership and reliability: how silos discover each other in a deployment and detect node failures. Depending on the environment you want to run Orleans in some of these parameters may or may not be important. For example, for a single silo development environment one usually doesn’t need reliability, and all the endpoints can be localhost. The following sections detail the configuration setting for the four mentioned key aspects. Then in the scenarios section you can find the recommended combinations of the settings for the most typical deployment scenarios. Connectivity The connectivity settings define two TCP/IP endpoints: one for inter-silo communication and one for client connections, also referred to as client gateway or simply gateway. Inter-silo Endpoint <Networking Address=\" \" Port=\"11111\" /> Address: IP address or host name to use. If left empty, silo will pick the first available IPv4 address. Orleans supports IPv6 as well as IPv4. Port: TCP port to use. If left empty, silo will pick a random available port. If there is only one silo running on the machine, it is advisable to specify a port for consistency and for easy configuration of the firewall. For running multiple silos on the same machine, you can either provide each of the silos with different configuration files or leave the Port attribute empty for a random port assignment. For machines that have more than one IP address assigned to them, if you need to choose an address from a specific subnet or an IPv6 address, you can do that by adding a Subnet and PreferredFamily attributes respectively (refer to the XSD schema for exact syntax of those attributes). For local development environment, you can simply use localhost as the host name: <Networking Address=\"localhost\" Port=\"11111\" /> Client Gateway Endpoint The setting for client gateway endpoint is identical to the inter-silo endpoint except for the XML element name: <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> You have to specify a port number different from the one used for the inter-silo endpoint. It is possible to configure clients to connect to the inter-silo endpoint instead of the gateway, but that requires opening a listening socket on the client (thus requires enabling incoming connections on the client machine firewall), and in general is not advisable other than for a very limited set of scenarios. Cluster Membership and Reliability Usually, a service built on Orleans is deployed on a cluster of nodes, either on dedicated hardware or in Azure. For development and basic testing, Orleans can be deployed in a single node configuration. When deployed to a cluster of nodes, Orleans internally implements a set of protocols to discover and maintain membership of Orleans silos in the cluster, including detection of node failures and automatic reconfiguration. For reliable management of cluster membership, Orleans uses Azure Table, SQL Server or Apache ZooKeeper for synchronization of nodes. The reliable membership setup requires configuring the 'SystemStore' element settings in the silo configuration file: <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"...\" DataConnectionString=\"...\"/> or <SystemStore SystemStoreType=\"SqlServer\" DeploymentId=\"...\" DataConnectionString=\"...\"/> or <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"...\" DataConnectionString=\"...\"/> DeploymentId is a unique string that defines a particular deployment. When deploying an Orleans based service to Azure it makes most sense to use the Azure deployment ID of the worker role. For development or if it’s not possible to use Azure Table, silos can be configured to use the membership grain instead. Such a configuration is unreliable as it will not survive a failure of the primary silo that hosts the membership grain. “MembershipTableGrain” is the default value of LivenessType. <Liveness LivenessType =\"MembershipTableGrain\" /> Primary Silo In a reliable deployment, one that is configured with membership using Azure Table, SQL Server or ZooKeeper, all silos are created equal, with no notion of primary or secondary silos. That is the configuration that is recommended for production that will survive a failure of any individual node or a combination of nodes. For example, Azure periodically rolls out OS patches and that causes all of the role instances to reboot eventually. For development or a non-reliable deployment when MembershipTableGrain is used, one of the silos has to be designated as Primary and has to start and initialize before other, Secondary, silos that wait for Primary to initialize before joining the cluster. In case of a failure of the Primary node, the whole deployment stops working properly and has to be restarted. Primary is designated in the configuration file with the following setting within the Globals section. <SeedNode Address=\"<host name or IP address of the primary node>\" Port=\"11111\" /> Here is an example how to configure and launch Orleans silo hosted inside worker-role. This is a reference only example and SHOULD NOT be used AS-IS - you may need to fine-tune client parameters for your specific environment. var dataConnection = \"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\"; var config = new ClusterConfiguration { Globals = { DeploymentId = RoleEnvironment.DeploymentId, ResponseTimeout = TimeSpan.FromSeconds(30), DataConnectionString = dataConnection, LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable, ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable, }, Defaults = { PropagateActivityId = true, // Tracing DefaultTraceLevel = Severity.Info, TraceToConsole = false, TraceFilePattern = @\"Silo_{0}-{1}.log\", //TraceFilePattern = \"false\", // Set it to false or none to disable file tracing, effectively it sets config.Defaults.TraceFileName = null; TraceLevelOverrides = { Tuple.Create(\"ComponentName\", Severity.Warning), } } }; // Register bootstrap provider class config.Globals.RegisterBootstrapProvider<AutoStartBootstrapProvider>(\"MyAutoStartBootstrapProvider\"); // Add Storage Providers config.Globals.RegisterStorageProvider<MemoryStorage>(\"MemoryStore\"); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"PubSubStore\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, //{ \"UseJsonFormat\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"AzureTable\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"DataStorage\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<BlobStorageProvider>(\"BlobStorage\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"ContainerName\", \"grainstate\" }, { \"DataConnectionString\", dataConnection } }); // Add Stream Providers config.Globals.RegisterStreamProvider<AzureQueueStreamProvider>(\"AzureQueueStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" }, { \"DeploymentId\", \"orleans-streams\" }, { \"NumQueues\", \"4\" }, { \"GetQueueMessagesTimerPeriod\", \"100ms\" }, { \"DataConnectionString\", dataConnection } }); try { _orleansAzureSilo = new AzureSilo(); var ok = _orleansAzureSilo.Start(config, config.Globals.DeploymentId, config.Globals.DataConnectionString); _orleansAzureSilo.Run(); // Call will block until silo is shutdown } catch (Exception exc) { //Log \"Error when starting Silo\" }"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/index.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/index.html",
    "title": "Orleans Configuration Guide | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Configuration Guide This Configuration Guide explains the key configuration parameters and how they should be used for most typical usage scenarios. Orleans Configuration xsd file is located here . Orleans can be used in a variety of configurations that fit different usage scenarios, such as local single node deployment for development and testing, cluster of servers, multi-instance Azure worker role, etc. All of the different target scenarios are achieved by specifying particular values in the Orleans configuration XML files. This guide provides instructions for the key configuration parameters that are necessary to make Orleans run in one of the target scenarios. There are also other configuration parameters that primarily help fine tune Orleans for better performance. They are documented in the XSD schema and in general are not required even for running the system in production. Orleans is a framework for building and running high scale services. A typical deployment of an Orleans application spans a cluster of servers. The instances of the Orleans runtime, called silos, running on each of the servers need to be configured to connect to each other. In addition to that, there is always a client component that connects to the Orleans deployment, most typically a web frontend, that needs to be configured to connect to the silos. The Server Configuration and Client Configuration sections of the guide cover those aspects, respectively. The section on Typical Configurations provides a summary of a few common configurations. Important : Make sure you properly configure .NET Garbage Collection as detailed in Configuring .NET Garbage Collection ."
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html",
    "title": "Configuring .NET Garbage Collection | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Configuring .NET Garbage Collection For good performance, it is important to configure .NET garbage collection for the silo process the right way. The best combination of settings we found is to set gcServer=true and gcConcurrent=true. These are easy to set via the application config file when a silo runs as a standalone process. You can use OrleansHost.exe.config included in the Microsoft.Orleans.OrleansHost NuGet package as an example. .NET Framework <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> .NET Core // .csproj <PropertyGroup> <ServerGarbageCollection>true</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> However, this is not as easy to do if a silo runs as part of an Azure Worker Role, which by default is configured to use workstation GC. This blog post shows how to set the same configuration for an Azure Worker Role - https://blogs.msdn.microsoft.com/cclayton/2014/06/05/server-garbage-collection-mode-in-microsoft-azure/ IMPORTANT NOTE Server garbage collection is available only on multiprocessor computers . Therefore, even if you configure the Garbage Collection either via Application Configuration file (app.config or web.config) or via the scripts on the referred blog post, if the silo is running on a (virtual) machine with a single core, you will not get the benefits of gcServer=true ."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Silo-Error-Code-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Silo-Error-Code-Monitoring.html",
    "title": "Silo Error Code Monitoring | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Silo Error Code Monitoring Group Log Type Log Code Values Threshold Description Azure Problems Warning or Error 100800 - 100899 Any Error or Warning Transient problems reading or writing to Azure table store will be logged as Warning. Transient read errors will automatically be retried. A final Error log message means there is a real problem connecting to Azure table storage. Membership Connectivity Problems Warning or Error 100600 - 100699 Any Error or Warning Warning logs are an early indication of network connectivity problems and/or silo restart / migration. Ping timeouts and silo-dead votes will show up as Warning messages. Silo detesting it was voted dead will show as Error message. Grain call timeouts Warning 100157 Multiple Warnings logged in short space of time Grain-call timeout problems are generally caused by temporary network connectivity issues or silo restart / reboot problems. The system should recover after a short time (depending on Liveness config settings) at which point Timeouts should clear. Ideally, monitoring for just the bulk log code 600157 variety of these warnings should be sufficient. Silo Restart / Migration Warning 100601 or 100602 Any Warning Warning printed when silo detects it was restarted on same machine {100602) or migrated to different machine (100601) Network Socket Problems Warning or Error 101000 to 101999, 100307,100015, 100016 Any Error or Warning Socket disconnects are logged as Warning messages. Problems opening sockets or during message transmission are logged as Errors. Bulk log message compaction Any 500000 or higher Message summary based on bulk message threshold settings If multiple logs of the same log code occur within a designated time interval (the default is >5 within 1 minute) then additional log messages with that log code are suppressed and output as a \"bulk\" entry with log code equal to the original log code + 500000. So for example, multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute. Grain problems Warning or Error 101534 Any Error or Warning Detection of “stuck” requests for non-reentrant grains . The error code is reported every time a request takes longer than 5x request timeout time to execute."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html",
    "title": "Runtime Monitoring | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Runtime Monitoring [[THIS IS IN NEED OF REVIEW]] There are five ways Orleans deployment can be monitored by an external operator by utilizing the data that Orleans writes automatically to Azure storage. The tables mentioned below are desribed in more detail here . OrleansSilosTable for cluster membership - this table lists all silos in the deployment (partition key DeploymentID, row key silo id). The operator can use this table to check cluster health, watch the current set of live silos, or learn why and when a certain silo went down. Orleans' cluster membership protocol uses this table internally and updates it with significant membership events (silos goes up and down). OrleansSiloMetrics table for coarse grain performance statistics - Orleans writes a small number (about 10) of coarse-grain performance stats into this table (partition key DeplomentID, row key silo id). The table is updated automatically every X seconds (configurable) for each silo. The metrics include silo CPU, memory usage, number of grain activations on this silo, number of messages in the send/receive queue, etc. This data can be used to compare silos, check that there are no significant outliers (for example, one silo runs at much higher CPU), or simply check that in general the metrics reported by silos are in the expected range. In addition, this data can be used to decide to add new silos if the system becomes overloaded or reduce the number of silos if the system is mostly idle. OrleansSiloStatistics table - this table includes a much larger number of performance statistics (hundreds of counters) which provide a much more detailed and in-depth view of the internal silo state. This table is currently not recommended for use by external operators. It is mainly for Orleans developers to help them troubleshoot complex production problems, if they occur. The Orleans team is building tools to analyze this data automatically and provide compact recommendations to operators based on it. Such tools can also be built by anyone independently. Watching error codes in MDS - Orleans automatically writes different error messages into logger. This logger can be configured to output its data to various destinations. For example, the Halo team redirects all logs in production to MDS. They have written custom alerts in MDS to watch for specific error codes and count their occurrences, and alert them when those reach a certain threshold. The list of important error codes to watch is specified here: Silo Error Code Monitoring Client Error Code Monitoring Windows performance counters - The Orleans runtime continually updates a number of them. CounterControl.exe helps register the counters, and needs to run with elevated privileges. Obviously, the performance counters can be monitored using any of the standard monitoring tools."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Client-Error-Code-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Client-Error-Code-Monitoring.html",
    "title": "Client Error Code Monitoring | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Client Error Code Monitoring Group Log Type Log Code Values Threshold Description Azure Problems Warning or Error 100800 - 100899 Any Error or Warning Transient problems reading or writing to Azure table store will be logged as Warning. Transient read errors will automatically be retried. A final Error log message means there is a real problem connecting to Azure table storage. Gateway connectivity problems Warning or Error 100901 - 100904, 100912, 100913, 100921, 100923, 100158, 100161, 100178, , 101313 Any Error or Warning Problems connecting to gateways. No active gateways in the Azure table. Connection to active gateway lost. Grain call timeouts Warning 100157 Multiple Warnings logged in short space of time Grain-call timeout problems are generally caused by temporary network connectivity issues or silo restart / reboot problems. System should recover after a short time (depending on Liveness config settings) at which point Timeouts should clear. Ideally, monitoring for just the bulk log code 600157 variety of these warnings should be sufficient. Network Socket Problems Warning or Error 101000 to 101999, 100307, 100015, 100016 Any Error or Warning Socket disconnects are logged as Warning messages. Problems opening sockets or during message transmission are logged as Errors. Bulk log message compaction Any 500000 or higher Message summary based on bulk message threshold settings If multiple logs of the same log code occur within a designated time interval (the default is >5 within 1 minute) then additional log messages with that log code are suppressed and output as a \"bulk\" entry with log code equal to the original log code + 500000. So for example, multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute."
  },
  "1.5/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html",
    "title": "Heterogeneous silos | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Heterogeneous silos Overview On a given cluster, silos can support a different set of grain types: In this example the cluster support grain of type A , B , C , D , E : Grain types A and B can be placed on Silo 1 and 2. Grain type C can be placed on Silo 1, 2 or 3. Grain type D can be only placed on Silo 3 Grain Type E can be only placed on Silo 4. All silos should reference interfaces of all grain types of the cluster, but grain classes should only be referenced by the silos that will host them. The client does not know which silo support a given Grain Type. A given Grain Type implementation must be the same on each silo that support it. The following scenario is NOT valid: On Silo 1 and 2: public class C: Grain, IMyGrainInterface { public Task SomeMethod() { … } } On Silo 3 public class C: Grain, IMyGrainInterface, IMyOtherGrainInterface { public Task SomeMethod() { … } public Task SomeOtherMethod() { … } } Configuration No configuration is needed, you can deploy different binaries on each silo in your cluster. However, if necessary, you can change the interval that silos check for changes in types supported in ClusterConfig.Globals.TypeMapRefreshInterval . For testing purpose, you can use the property ExcludedGrainTypes in NodeConfiguration . In code based config you can find it in ClusterConfig.Defaults.ExcludedGrainTypes , which is a list names of the types you want to exclude. Limitations Connected clients will not be notified if the set of supported Grain Types changed. In the previous example: If Silo 4 leave the cluster, the client will still try to make calls to grain of type E . It will fail at runtime with a OrleansException. If the client was connected to the cluster before Silo 4 joined it, the client will not be able to make calls to grain of type E . It will fail will a ArgumentException Stateless grains is not supported: all silos in the cluster must support the same set of stateless grains."
  },
  "1.5/Documentation/Deployment-and-Operations/Docker-Deployment.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Docker-Deployment.html",
    "title": "Docker Deployment | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Docker Deployment Note : Even if you are very familiar with Docker and/or Orleans, as any other Orleans documentation, I recommend you to read it to the end in order to avoid problems you may face that we already worked around. Note : This article and its sample are a work in progress. Any feedback, PR or suggestion is very welcome. Deploying Orleans solutions to Docker Deploying Orleans to Docker can be tricky given the way Docker orchestrators and clustering stacks was designed. The most complicated thing is to understand the concept of Overlay Network from Docker Swarm and Kubernets Networking model. Docker containers and networking model were designed to run mostly stateless and immutable containers. So, spin up a cluster running node.js or nginx applications, is pretty easy. However, if you try to use something more elaborated, like a real clustered or distributed application (like Orleans-based ones) you will eventually have troubles setting it up. It is possible, but not as simples as web-based applications. Docker clustering consist of putting together multiple hosts to work as a single pool of resources managed using a Container Orchestrator . Docker Inc. provide Swarm as their option for Container Orchestration while Google has Kubernetes (aka K8s ). There are other Orchestrators like DC/OS , Mesos , etc., but in this document we will talk about Swarm and K8s as they are more widely used. The same grain interfaces and implementation which run anywhere Orleans is already supported, will run on Docker containers as well, so no special considerations are needed in order to be able to run your application in Docker containers. The Orleans-Docker sample provides a working example of how to run two console applications. One as Orleans Client and another as Silo, and the details are described below. The concepts discussed here, can be used on both .Net Core and .Net 4.6.1 flavors of Orleans but to ilustrate the cross-platform nature of Docker and .Net Core, we are going to focus on the example considering you are using .Net Core. Platform-specific (Windows/Linux/OSX) details may be provide along this article. Pre-requisites This article assume that you have the following prerequisites installed: Docker - Docker4X has a easy-to-use installer for the major supported platforms. It contains Docker engine and also Docker Swarm. Kubernetes (K8s) - Google's offer for Container Orchestration. It contains a guidance to install Minikube (a local deployment of K8s) and kubectl along with all its dependencies. .Net Core - Cross-platform flavor of .Net Visual Studio Code (VSCode) - You can use whatever IDE you want. VSCode is cross-platform so we are using it to ensure it works on all platforms. Once you installed VSCode, install the C# extension . Note : You are not required to have Kubernetes installed if you are not going to use it. Docker4X installer already includes Swarm so no extra installation is required to use it. Note for Windows Users : On Windows, Docker installer will enable Hyper-V at installation process. As this article and its examples are using .Net Core, the container images used are based on Windows Server NanoServer . If you don't plan to use .Net Core and will target .Net 4.6.1 full framework, the image used should be Windows Server Core and the 1.4+ version of Orleans (which support only .net full framework). Creating Orleans Solution The following instructions show how to create a regular Orleans solution using the new dotnet tooling. Note : Please adapt the commands to whatever appropriate in your platform. Also, the directory structure is just a suggestion. Please adapt it whatever way you want. mkdir Orleans-Docker cd Orleans-Docker dotnet new sln mkdir -p src/OrleansSilo mkdir -p src/OrleansClient mkdir -p src/OrleansGrains mkdir -p src/OrleansGrainInterfaces dotnet new console -o src/OrleansSilo --framework netcoreapp1.1 dotnet new console -o src/OrleansClient --framework netcoreapp1.1 dotnet new classlib -o src/OrleansGrains --framework netstandard1.5 dotnet new classlib -o src/OrleansGrainInterfaces --framework netstandard1.5 dotnet sln add src/OrleansSilo/OrleansSilo.csproj dotnet sln add src/OrleansClient/OrleansClient.csproj dotnet sln add src/OrleansGrains/OrleansGrains.csproj dotnet sln add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansClient/OrleansClient.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansGrains/OrleansGrains.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrains/OrleansGrains.csproj What we did so far was just boilerplate code to create the solution structure, projects, and add references between projects. Nothing different than a regular Orleans project. By the time this article was written, Orleans 2.0 (which is the only version which support .Net Core and cross-platform) is in Technology Preview so its nugets are hosted in a MyGet feed and not published to Nuget.org official feed. In order to install the preview nugets, we will use dotnet cli forcing the source feed and version from MyGet: dotnet add src/OrleansClient/OrleansClient.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrains/OrleansGrains.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.OrleansRuntime -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet restore Ok, now you have all the basic dependencies to run a simple Orleans application. Note that so far, nothing changed from your regular Orleans application. Now, lets add some code so we can do something with it. Implementing your Orleans Application Assuming that you are using VSCode , from the solution directory, run code . . That will open the directory in VSCode and load the solution. This is the solution structure we just created previously. We also added Program.cs , OrleansHostWrapper , IGreetingGrain and GreetingGrain files to the interfaces and grain projects respectively and here is the code for those files: IGreetingGrain.cs : using System; using System.Threading.Tasks; using Orleans; namespace OrleansGrainInterfaces { public interface IGreetingGrain : IGrainWithGuidKey { Task<string> SayHello(string name); } } GreetingGrain.cs : using System; using System.Threading.Tasks; using OrleansGrainInterfaces; namespace OrleansGrains { public class GreetingGrain : Grain, IGreetingGrain { public Task<string> SayHello(string name) { return Task.FromResult($\"Hello from Orleans, {name}\"); } } } OrleansHostWrapper.cs : using System; using System.Net; using Orleans.Runtime; using Orleans.Runtime.Configuration; using Orleans.Runtime.Host; namespace OrleansSilo { public class OrleansHostWrapper { private readonly SiloHost siloHost; public OrleansHostWrapper(ClusterConfiguration config) { siloHost = new SiloHost(Dns.GetHostName(), config); siloHost.LoadOrleansConfig(); } public int Run() { if (siloHost == null) { return 1; } try { siloHost.InitializeOrleansSilo(); if (siloHost.StartOrleansSilo()) { Console.WriteLine($\"Successfully started Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); return 0; } else { throw new OrleansException($\"Failed to start Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); } } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } public int Stop() { if (siloHost != null) { try { siloHost.StopOrleansSilo(); siloHost.Dispose(); Console.WriteLine($\"Orleans silo '{siloHost.Name}' shutdown.\"); } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } return 0; } } } Program.cs (Silo): using System; using System.Collections.Generic; using System.Linq; using System.Net; using Orleans.Runtime.Configuration; namespace OrleansSilo { public class Program { private static OrleansHostWrapper hostWrapper; static int Main(string[] args) { int exitCode = InitializeOrleans(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); exitCode += ShutdownSilo(); return exitCode; } private static int InitializeOrleans() { var config = new ClusterConfiguration(); config.Globals.DataConnectionString = \"[AZURE STORAGE CONNECTION STRING HERE]\"; config.Globals.DeploymentId = \"Orleans-Docker\"; config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable; config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable; config.Defaults.PropagateActivityId = true; config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any, 10400); config.Defaults.Port = 10300; var ips = Dns.GetHostAddressesAsync(Dns.GetHostName()).Result; config.Defaults.HostNameOrIPAddress = ips.FirstOrDefault()?.ToString(); hostWrapper = new OrleansHostWrapper(config); return hostWrapper.Run(); } private static int ShutdownSilo() { if (hostWrapper != null) { return hostWrapper.Stop(); } return 0; } } } Program.cs (client): using System; using System.Net; using System.Threading; using System.Threading.Tasks; using Orleans; using Orleans.Runtime.Configuration; using OrleansGrainInterfaces; namespace OrleansClient { class Program { private static IClusterClient client; private static bool running; static void Main(string[] args) { Task.Run(() => InitializeOrleans()); Console.ReadLine(); running = false; } static async Task InitializeOrleans() { var config = new ClientConfiguration(); config.DeploymentId = \"Orleans-Docker\"; config.PropagateActivityId = true; var hostEntry = await Dns.GetHostEntryAsync(\"orleans-silo\"); var ip = hostEntry.AddressList[0]; config.Gateways.Add(new IPEndPoint(ip, 10400)); Console.WriteLine(\"Initializing...\"); client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); running = true; Console.WriteLine(\"Initialized!\"); var grain = client.GetGrain<IGreetingGrain>(Guid.Empty); while(running) { var response = await grain.SayHello(\"Gutemberg\"); Console.WriteLine($\"[{DateTime.UtcNow}] - {response}\"); await Task.Delay(1000); } client.Dispose(); } } } We are not going into details about the grain implementation here since it is out of the scope of this article. Please check other documents related to it. Those files are essentially a minimal Orleans application and we will start from it to move forward with the remaining of this article. Note : In this article we are using OrleansAzureUtils membership provider but you can use any other already supported by Orleans. Dockerfile In order to create your container, Docker use images. For more details on how to create your own, you can check Docker documentation . In this article we are going to use official Microsoft images . Based on the target and development platforms, you need to pick the appropriate image. In this article, we are using microsoft/dotnet:1.1.2-sdk which is a linux-based image. You can use microsoft/dotnet:1.1.2-sdk-nanoserver for Windows for example. Pick one that suit your needs. Note for Windows users : As previously mentioned, to be cross-platform, we are using .Net Core and Orleans Technical preview 2.0 in this article. If you want to use Docker on Windows with the fully released Orleans 1.4+, you need to use the images that are based on Windows Server Core since NanoServer and Linux based images, only support .Net Core. Dockerfile.debug : FROM microsoft/dotnet:1.1.2-sdk ENV NUGET_XMLDOC_MODE skip WORKDIR /vsdbg RUN apt-get update \\ && apt-get install -y --no-install-recommends \\ unzip \\ && rm -rf /var/lib/apt/lists/* \\ && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg WORKDIR /app ENTRYPOINT [\"tail\", \"-f\", \"/dev/null\"] This dockerfile essentially download and install the VSdbg debugger and start an empty container and keep it alive forever so we don't need tear down/up while debugging. Now, for production, the image is smaller since it contains only the .Net Core runtime and not the whole SDK, and the dockerfile is a bit simpler: Dockerfile : FROM microsoft/dotnet:1.1.2-runtime WORKDIR /app ENTRYPOINT [\"dotnet\", \"OrleansSilo.dll\"] COPY . /app docker-compose The docker-compose.yml file, essentially pack up within a project a set of services and its dependencies at service level. Each service contains one or more instances of a given container, which is based on the images you selected on your Dockerfile. More details on the docker-compose you you can find on docker-compose documentation . For an Orleans deployment, a common use case is to have a docker-compose.yml which contains two services. One for Orleans Silo, and other for Orleans Client. The Client would have a dependency on the Silo and that means, it will only start after the Silo service is up. Another case is to add a storage/database service/container, like for example SQL Server, which should start first before the client and the silo, so both services should take a dependency on it. Note : Before you read further (and eventually get crazy with it), please note that identation matters in docker-compose files. So pay attention to it if you have any problem. Here is how we will describe our services for this article: docker-compose.override.yml (Debug): version: '3.1' services: orleans-client: image: orleans-client:debug build: context: ./src/OrleansClient/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansClient/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro depends_on: - orleans-silo orleans-silo: image: orleans-silo:debug build: context: ./src/OrleansSilo/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansSilo/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro docker-compose.yml (production): version: '3.1' services: orleans-client: image: orleans-client depends_on: - orleans-silo orleans-silo: image: orleans-silo Note that in production, we don't map the local directory and neither we have the build: action. The reason is that in production, the images should be already being built and pushed to your own Docker Registry. Put everything together Now we have all the moving parts required to run your Orleans Application, we are going to put it together so we can run our Orleans solution inside Docker (Finally!). Note : The following commands should be performed from the solution directory. First, lets make sure we restore all NuGet packages from our solution. You only need to do it once. You are only required to do it again if you change any package dependency on your project. # dotnet restore Now, let's build our solution using dotnet CLI as usual and publish it to an output directory: # dotnet publish -o ./bin/PublishOutput Note : We are using publish here instead of build, to avoid problems with our dynamicaly loaded assemblied in Orleans. We are still looking for a better solution for it. With the application built and published, you need to build your Dockerfile images. This step is only required to be performed once per project and should be only performed again if you change the Dockerfil, docker-compose, or for any reason you cleaned up your local image registry. # docker-compose build All the images used in both Dockerfile and docker-compose.yml are pulled from the registry and cached on your development machine. Your images are built, and you are all set to run. Now lets run it! # docker-compose up -d Creating network \"orleansdocker_default\" with the default driver Creating orleansdocker_orleans-silo_1 ... Creating orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-client_1 ... Creating orleansdocker_orleans-client_1 ... done # Now if you run a docker-compose ps , you will see 2 containers running for the orleansdocker project: # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up Note for Windows users : If you are on Windows, and your container is using a Windows image as base, the Command column will show you the Powershell relative command to a tail on *NIX systems so the container will keep up the same way. Now that you have your containers up, you don't need to stop it every time you want to start your Orleans application. All you need is to integrate your IDE to debug the application inside the container which was previously mapped in your docker-compose.yml . Scaling Once you have your compose project running, you can easily scale up or down your application using docker-compose scale command: # docker-compose scale orleans-silo=15 Starting orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-silo_2 ... Creating orleansdocker_orleans-silo_3 ... Creating orleansdocker_orleans-silo_4 ... Creating orleansdocker_orleans-silo_5 ... Creating orleansdocker_orleans-silo_6 ... Creating orleansdocker_orleans-silo_7 ... Creating orleansdocker_orleans-silo_8 ... Creating orleansdocker_orleans-silo_9 ... Creating orleansdocker_orleans-silo_10 ... Creating orleansdocker_orleans-silo_11 ... Creating orleansdocker_orleans-silo_12 ... Creating orleansdocker_orleans-silo_13 ... Creating orleansdocker_orleans-silo_14 ... Creating orleansdocker_orleans-silo_15 ... Creating orleansdocker_orleans-silo_6 Creating orleansdocker_orleans-silo_5 Creating orleansdocker_orleans-silo_3 Creating orleansdocker_orleans-silo_2 Creating orleansdocker_orleans-silo_4 Creating orleansdocker_orleans-silo_9 Creating orleansdocker_orleans-silo_7 Creating orleansdocker_orleans-silo_8 Creating orleansdocker_orleans-silo_10 Creating orleansdocker_orleans-silo_11 Creating orleansdocker_orleans-silo_15 Creating orleansdocker_orleans-silo_12 Creating orleansdocker_orleans-silo_14 Creating orleansdocker_orleans-silo_13 Few seconds later, you will see the services scaled to the specific number of instances you requested. # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up orleansdocker_orleans-silo_10 tail -f /dev/null Up orleansdocker_orleans-silo_11 tail -f /dev/null Up orleansdocker_orleans-silo_12 tail -f /dev/null Up orleansdocker_orleans-silo_13 tail -f /dev/null Up orleansdocker_orleans-silo_14 tail -f /dev/null Up orleansdocker_orleans-silo_15 tail -f /dev/null Up orleansdocker_orleans-silo_2 tail -f /dev/null Up orleansdocker_orleans-silo_3 tail -f /dev/null Up orleansdocker_orleans-silo_4 tail -f /dev/null Up orleansdocker_orleans-silo_5 tail -f /dev/null Up orleansdocker_orleans-silo_6 tail -f /dev/null Up orleansdocker_orleans-silo_7 tail -f /dev/null Up orleansdocker_orleans-silo_8 tail -f /dev/null Up orleansdocker_orleans-silo_9 tail -f /dev/null Up Note : The Command column on those examples are showing the tail command just because we are using the debugger container. If we were in production, it would be showing dotnet OrleansSilo.dll for example. Docker Swarm Docker clustering stack is called Swarm and you can find more by reading its documentation here . To run this article in a Swarm cluster, you don't have any extra work. When you run docker-compose up -d in a Swarm node, it will schedule containers based on the configured rules. The same applies to other Swarm-based services like Docker Datacenter , Azure ACS (in Swarm mode), AWS ECS Container Service and so on. All you need to do is to deploy your Swarm cluster before deploy your dockerized Orleans application. Note : If you are using a Docker engine with the Swarm mode that already have support to stack , deploy and compose v3, a better approach to deploy your solution would be docker stack deploy -c docker-compose.yml <name> . Just keep in mind that it requires v3 compose file support at your Docker engine and the majority of hosted services like Azure and AWS still use v2 and older engines. Google Kubernetes (K8s) If you plan to use Kubernetes to host Orleans, there is a community-maintained clustering provider available at OrleansContrib\\Orleans.Clustering.Kubernetes and there you can find documentation and samples on how to host Orleans in Kubernetes seamlessly using the provider. [Bonus topic] Debugging Orleans inside Containers Well, now that you know how to run Orleans in a container from scratch, would be good to leverage one of the most important principles in Docker. Containers are immutable. And they should have (almost) the same image, dependencies, and runtime in development as in production. That ensure the good old statement \"It work on my machine!\" never happen again. To make that possible, you need to have a way to develop inside the container and that includes have a debugger attached to your application inside the container. There are multiple ways to achieve that using multiple tools. After evaluate several, by the time I wrote this article, I ended up choosing one that looks more simple and is less intrusive in the application. As mentioned ealier in this article, we are using VSCode to develop the sample, so here is how to get the debugger attached to your Orleans Application inside the container. First, change two files inside your .vscode directory in your solution: tasks.json : { \"version\": \"0.1.0\", \"command\": \"dotnet\", \"isShellCommand\": true, \"args\": [], \"tasks\": [ { \"taskName\": \"publish\", \"args\": [ \"${workspaceRoot}/Orleans-Docker.sln\", \"-c\", \"Debug\", \"-o\", \"./bin/PublishOutput\" ], \"isBuildCommand\": true, \"problemMatcher\": \"$msCompile\" } ] } This file essentially tells VSCode that whenever you build the project, it will actually execute the publish command as we manually did earlier. launch.json : { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Silo\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansSilo.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansSilo\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-silo_1 /vsdbg/vsdbg --interpreter=vscode\" ] } }, { \"name\": \"Client\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansClient.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansClient\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-client_1 /vsdbg/vsdbg --interpreter=vscode\" ] } } ] } Now you can just build the solution from VSCode (which will publish) and start both the Silo and the Client. It will send a docker exec command to the running docker-compose service instance/container to start the debugger to the application and thats it. You have the debugger attached to the container and use it as if it was a locally running Orleans application. The difference now is that it is inside the container, and once you are done, you can just publish the container to your registry and pull it on your Docker hosts in production."
  },
  "1.5/Documentation/Orleans-Streams/Stream-Providers.html": {
    "href": "1.5/Documentation/Orleans-Streams/Stream-Providers.html",
    "title": "Orleans Stream Providers | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Stream Providers Streams can come in different shapes and forms. Some streams may deliver events over direct TCP links, while others deliver events via durable queues. Different stream types may use different batching strategies, different caching algorithms, or different back pressure procedures. We did not want to constrain streaming applications to only a small subset of those behavioral choices. Instead, Stream Providers are extensibility points to Orleans Streaming Runtime that allow users to implement any type of stream. This extensibility point is similar in spirit to Orleans Storage Providers . Orleans currently ships with two default stream providers: Simple Message Stream Provider and Azure Queue Stream Provider . Simple Message Stream Provider Simple Message Stream Provider, also known as the SMS provider, delivers events over TCP by utilizing regular Orleans grain messaging. Since events in SMS are delivered over unreliable TCP links, SMS does not guarantee reliable event delivery and does not automaticaly resend failed messages for SMS streams. The producer of the SMS stream has a way to know if his event was successfully received and processed or not: by default the call to stream.OnNextAsync returns a Task that represents the processing status of the stream consumer. If this Task fails, the producer can decide to send the same event again, thus achieving reliability on ther application level. Although individual stream messages delivery is best effort, SMS streams themselves are reliable. That is, the subscriber-to-producer binding performed by Pub Sub is fully reliable. Azure Queue (AQ) Stream Provider Azure Queue (AQ) Stream Provider delivers events over Azure Queues. On the producer side, AQ Stream Provider enqueues events directly into Azure Queue. On the consumer side, AQ Stream Provider manages a set of pulling agents that pull events from a set of Azure Queues and deliver them to application code that consumes them. One can think of the pulling agents as a distributed \"micro-service\" -- a partitioned, highly available, and elastic distributed component. The pulling agents run inside the same silos that host application grains. Thus, there is no need to run separate Azure worker roles to pull from the queues. The existence of pulling agents, their management, backpresure, balancing the queues between them, and handing off queues from a failed agent to another agent are fully managed by Orleans Streaming Runtime and are transparent to application code that uses streams. Queue Adapters Different stream providers that deliver events over durable queues exhibit similar behavior and are subject to a similar implementation. Therefore, we provide a generic extensible PersistentStreamProvider that allows developers to plug in different types of queues without writing a completely new stream provider from scratch. PersistentStreamProvider is parameterized with an IQueueAdapter , which abstracts specific queue implementation details and provides means to enqueue and dequeue events. All the rest is handled by the logic inside the PersistentStreamProvider . Azure Queue Provider mentioned above is also implemented this way: it is an instance of PersistentStreamProvider with AzureQueueAdapter . Next Orleans Streams Implementation Details"
  },
  "1.5/Documentation/Introduction.html": {
    "href": "1.5/Documentation/Introduction.html",
    "title": "Introduction | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Introduction Orleans is a framework that provides a straightforward approach to building distributed high-scale computing applications, without the need to learn and apply complex concurrency or other scaling patterns. Background Cloud applications and services are inherently parallel and distributed. They are also interactive and dynamic; often requiring near real time direct interactions between cloud entities. Such applications are very difficult to build today. The development process demands expert level programmers and typically requires expensive iterations of the design and the architecture, as the workload grows. Most of today’s high scale properties are built as a composition of stateless n-tier services with most of application logic residing in the middle tier. While the model allows to scale out by adding more servers to the middle tier, it is constrained by the performance and scalability of the storage layer because most requests coming to the middle tier from the frontend web servers require one or more reads from storage, and updates are even more complicated and prone to concurrency issues and conflicts due to lack of coordination between the middle tier servers. It often requires caching in the stateless layer to get acceptable performance, adding complexity and introducing cache consistency issues. The other problem with the stateless n-tier model is that it doesn't support well horizontal communications between individual application entities exposed by the middle tier, which makes it hard to implement complex business logic with multiple entities performing individual operations as part of processing a request. Orleans as a Stateful Middle Tier Orleans provides an intuitive way of building a stateful middle tier, where various business logic entities appear as sea of isolated globally addressable .NET objects (grains) of different application defined types distributed across a cluster of servers (silos). A grain type is a simple .NET class that implements one or more application defined grain interfaces. Individual grains are instances of application defined grain classes that get automatically created by the Orleans runtime on servers on an as-needed basis to handle requests for those grains. Grains naturally map to most application entities, such as users, devices, sessions, inventories, orders, etc., which makes it very easy to build business logic that is object-oriented but scales transparently across a cluster of servers. Each grain has a stable logical identity (key) within its grain type chosen by the application logic, for example, user email or device ID or inventory SKU code. Orleans guarantees single-threaded execution of each individual grain, hence protecting the application logic from perils of concurrency and races. In the world of microservices, Orleans is used as a framework for implementing a microservice that can be deployed and managed by a microservices deployment/management solution of developer's choice. Grain Lifecycle Grain can have persistent state in storage or in-memory state or a combination of both. Any grain can be called by any other grain or by a frontend (client) by using the target grain's logical identity without the need to ever create or instantiate the target grain. The Orleans programming model makes grains appear as if they are in memory the whole time. In reality, a grain goes through the lifecycle from existing only as its persisted state in storage to being instantiated in memory to being removed from memory. The Orleans runtime behind the scene instantiates (activates) grains when there's work for them to do, and removes them from memory (deactivates) to reclaim hardware resources when they are idle for too long. This grain lifecycle management work of the runtime is transparent to the application code, and liberates it from the complicated task of distributed resource management. Application logic can be written with the whole \"address space\" of grains available to it without the need to have hardware resources to keep all grains in memory at the same time, conceptually similar to how virtual memory works in operating systems. In addition, the virtual nature of grains allows Orleans to handle server failures mostly transparently to the application logic because grains that were executing on a failed server get automatically re-instantiated on other servers in the cluster once the failure is detected. Virtual Actors Implementation of Orleans is based on the Actor Model that's been around since 1970s. However, unlike actors in more traditional actor systems such as Erlang or Akka, Orleans Grains are virtual actors. The biggest difference is that physical instantiations of grains are completely abstracted away and are automatically managed by the Orleans runtime. The Virtual Actor Model is much more suitable for high-scale dynamic workloads like cloud services and is the major innovation of Orleans. You can read more details in the Technical Report on Orleans. Origin of Orleans Orleans was created at Microsoft Research and designed for use in the cloud . Since 2011, it has been used extensively in the cloud and on premises by several Microsoft product groups, most notably by game studios, such as 343 Industries and The Coalition as a platform for cloud services behind Halo 4/5 and Gears of War 4, as well as by a number of other companies. Orleans was open-sourced in January 2015, and attracted many developers that formed one of the most vibrant open source communities in the .NET ecosystem . In an active collaboration between the developer community and the Orleans team at Microsoft, features are added and improved on a daily basis. Microsoft Research continues to partner with the Orleans team to bring new major features, such as geo-distribution , indexing , and distributed transactions , that are pushing the state of the art. Orleans has become the framework of choice for building distributed systems and cloud services for many .NET developers."
  },
  "1.5/warning-banner.html": {
    "href": "1.5/warning-banner.html",
    "title": "| Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here ."
  },
  "Tutorials/Declarative-Persistence.zh.html": {
    "href": "Tutorials/Declarative-Persistence.zh.html",
    "title": "Declarative Persistence | Microsoft Orleans 中文文档",
    "keywords": "声明性持久化 在第二个教程中，我们看到了grain state是如何在客户端被关闭的情况下幸存下来的，这为许多类似缓存的场景打开了大门，在这种场景中，Orleans被视为一种“带有行为的缓存”，一种面向对象的缓存，如果你愿意的话。这已经是非常有价值的了，并且通过一个简单、熟悉的编程模型和内置的单线程执行保证来实现服务器端的可伸缩性。 但是，有时，您正在累积的某些状态属于某种形式的永久存储，因此它可以在silos关闭或从一个silos迁移到另一个silos以实现负载平衡或服务完全重新启动/关机后继续存在。我们迄今所看到的情况将不支持这种情况。 幸运的是，Orleans提供了一个简单的声明性模型，用于标识需要存储在永久位置的状态，同时将何时保存和恢复状态的决定权交给编程控制。您不需要使用声明性持久化机制，并且仍然可以直接从grain代码访问存储，但这是一种很好的方法，可以为您节省一些样板代码，并构建可跨各种存储服务移植的应用程序。 入门 我们将继续以我们的员工和经理样本为基础。 我们需要做的第一件事是让我们的员工和管理者的身份更加可预测。在这个示例中，使用 Guid.NewGuid() ，这很方便，但不允许我们在后续运行中找到它们。因此，我们将首先创建一组guid，然后将它们用作工作者标识。 修改后的客户端程序如下所示： private static async Task DoClientWork(IClusterClient client) { ... var ids = new string[] { \"42783519-d64e-44c9-9c29-399e3afaa625\", \"d694a4e0-1bc3-4c3f-a1ad-ba95103622bc\", \"9a72b0c6-33df-49db-ac05-14316edd332d\", \"6526a751-b9ac-4881-9bfb-836ecce2ca9f\", \"ae4b106f-3c96-464a-b48d-3583ed584b17\", \"b715c40f-d8d2-424d-9618-76afbc0a2a0a\", \"5ad92744-a0b1-487b-a9e7-e6b91e9a9826\", \"e23a55af-217c-4d76-8221-c2b447bf04c8\", \"2eef0ac5-540f-4421-b9a9-79d89400f7ab\" }; var e0 = client.GetGrain<IEmployee>(Guid.Parse(ids[0])); var e1 = client.GetGrain<IEmployee>(Guid.Parse(ids[1])); var e2 = client.GetGrain<IEmployee>(Guid.Parse(ids[2])); var e3 = client.GetGrain<IEmployee>(Guid.Parse(ids[3])); var e4 = client.GetGrain<IEmployee>(Guid.Parse(ids[4])); var m0 = client.GetGrain<IManager>(Guid.Parse(ids[5])); var m1 = client.GetGrain<IManager>(Guid.Parse(ids[6])); ... } 注意：如果您从Orleans1.5过渡，您会注意到客户端不再是静态的。请参考 从Orleans迁移到0.5 第页。 下一步，我们将进行一些silos配置，以便配置将允许我们访问持久存储的存储提供程序。SiloHost项目包括一个文件 程序.cs 我们可以在这里找到以下部分： var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; 如果这是托管在Azure云服务中，则可以在调用之前使用以下任一选项 建造者。建造者() 要使用Azure来保持grains状态，请执行以下操作： // Stores grains as composition of fields builder.AddAzureTableGrainStorage(option => option.ConnectionString = your_connection_string); // Stores grains as blobs builder.AddAzureBlobGrainStorage(option => option.ConnectionString = your_connection_string); 这个 记忆库 provider相当无趣，因为它实际上不提供任何永久存储；它的目的是调试持久化grains，而不能访问持久化存储。在我们的例子中，这使得很难证明持久化，所以我们将依赖于一个真正的存储提供者。 根据您是否已经设置(并希望使用)Azure存储帐户，还是希望依赖Azure存储仿真程序，您应该添加其他两行中的一行，但不能同时添加这两行。您可以使用 AddAzureTableStorage提供程序() 函数或 AddAzureBlobStorageProvider() 函数取决于您希望如何存储信息。 对于前者，您必须在安装最新版本的azuresdk之后启动Azure存储仿真器。对于后者，您必须创建一个Azure存储帐户，并在配置文件中输入名称和密钥。 启用其中一个，我们就可以处理grain代码了。 注意：在Orleans 2.0中，许多功能被拆分成更小的包，以允许更细Grain的配置和部署。这包括Azure存储提供程序。请安装 Orleans持久化 如果要将Azure用作存储提供程序，请打包。您可以通过 寻找Orleans。坚持 . 申报国 确定grains应使用持久状态需要三个步骤： 为州声明一个类， 改变Grains基类，以及 正在标识存储提供程序。 第一步，在grain实现项目中声明一个state类，只意味着标识应该持久化的参与者的信息，并创建一个看起来像持久数据记录的内容——每个状态组件都由一个带有getter和setter的属性表示。 对于员工，我们希望保持所有状态： public class EmployeeState { public int Level { get; set; } public IManager Manager { get; set; } } 对于经理来说，我们必须存储直接下属，但是 _我 在激活期间可能会继续创建引用。 public class ManagerState { public List<IEmployee> Reports { get; set; } } 然后，我们更改grain类声明以标识状态接口(例如，从 Orleans。Grains 到 Orleans。Grains<EmployeeState> )并删除我们想要持久化的变量。确保移除 水平 ，和 经理 从 雇员 类和 _报告 从 经理 班级。除此之外，我们还必须更新这些功能。 我们还添加了一个属性来标识存储提供程序： [StorageProvider(ProviderName = \"AzureStore\")] public class Employee : Orleans.Grain<EmployeeState>, Interfaces.IEmployee 和 [StorageProvider(ProviderName=\"AzureStore\")] public class Manager : Orleans.Grain<ManagerState>, IManager 在声明显而易见的风险下，存储提供程序属性的名称应该与配置silos时使用的名称相匹配。这种间接性使您能够在部署之前延迟关于在哪里存储Grain状态的选择。 考虑到这些声明性的更改，grain不应该再依赖私有字段来保持补偿级别和管理器。相反，grain基类让我们通过 State 可用于Grains的属性。 例如： public Task SetManager(IManager manager) { State.Manager = manager; return TaskDone.Done; } 控制检查点 剩下的问题是持久状态何时保存到存储提供程序。 Orleans设计人员可以做出的一个选择是在每次方法调用后都设置运行时保存状态，但结果证明这是不可取的，因为它过于保守——并非所有调用都会修改所有调用的状态，而且有些调用永远不会修改它。Orleans没有在每个方法之后使用复杂的系统来评估状态差异，而是要求grain开发人员添加必要的逻辑来确定是否需要保存状态。 使用存储提供程序保存状态很容易通过调用 base.WriteStateAsync() . 因此，最终版本的 提升() 和 设置管理器() 方法如下： public Task Promote(int newLevel) { State.Level = newLevel; return base.WriteStateAsync(); } public Task SetManager(IManager manager) { State.Manager = manager; return base.WriteStateAsync(); } 在 经理 类，只有一个方法需要修改才能写出数据， AddDirectReport() . 应该是这样的： public async Task AddDirectReport(IEmployee employee) { if (State.Reports == null) { State.Reports = new List<IEmployee>(); } State.Reports.Add(employee); await employee.SetManager(this); var data = new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }; await employee.Greeting(data); Console.WriteLine(\"{0} said: {1}\", data.From.ToString(), data.Message); await base.WriteStateAsync(); } 让我们试试这个！ 在中设置断点 员工。晋升() . 当我们第一次运行客户端代码并到达断点时，level字段应该是 0 以及newLevel参数 10 或 11 : ![](../Images/Persistence 2.PNG) 让应用程序完成(到达“点击回车…”提示符)并退出。再次运行它，并比较第二次查看状态时发生的情况： ![](../Images/Persistence 3.PNG) 只是确保。。。 值得检查一下Azure对数据的看法。使用存储资源管理器(如Azure存储资源管理器(ASE)或Visual Studio 2013中内置的服务器资源管理器)，打开存储帐户(或模拟器的开发人员存储)并找到“OrleansGrainState”表。它应该是这样的(你必须在ASE中点击'Query'： ![](../Images/Persistence 4.PNG) 如果一切正常，则纹理键应该出现在 分区键 列中，并且grains的限定类名应出现在 行键 列。 混合的东西 grains可能包含持久状态和瞬态状态的组合。任何瞬态都应该用grain类中的私有字段来表示。混合使用这两者的一个常见用途是，当持久化状态存在于内存中时，将它的某些计算版本缓存到私有字段中。例如，一堆元素可以外部表示为 列表<T> ，但在内部，作为 堆栈<T> . 如果我们 经理 同学们 _我 field只是一个缓存的值，一开始我们甚至不需要将其作为字段保存，它可以在任何需要它的时候创建，但是由于它将是一个常用的值，所以值得将它保存在一个临时字段中。 状态自动加载 如果Grains类型具有状态，则在激活时该状态将从存储中加载，然后 非激活异步 调用，以便您可以确保在初始化Grains时加载了状态。这是Orleans唯一调用来的案子 读状态异步 自动地。如果你想写州或在其他地方读，你应该自己写。通常你不需要调用 读状态异步 你自己，除非你正在做一些关于处理损坏状态或其他事情的具体事情。 使用持久化处理故障 一般来说，读写Grains的状态是一个很好的机制来处理失败和服务于它的初衷。由于不同的原因，grain调用可能会在方法的中间失败，最终导致状态更改一半。在这种情况下，从存储器中读取可以将状态返回到上一个正确的状态。或者，进入这种状态后，grain可以通过调用DeactivateOnIdle()请求立即停用，这样它的下一个请求将触发grain的重新激活，这将重新读取持久状态并重建其在内存中的副本。停用是将grains重置为其最后已知良好状态的最干净的方法，但是如果要避免重新激活过程的成本，可以重置其状态并重新运行任何初始化逻辑(例如，通过调用 非激活异步 )而不是使Grains失活。 下一个 接下来，我们将了解如何从mvcweb应用程序调用grains。 处理失败"
  },
  "Documentation/grains/grain_persistence/relational_storage.html": {
    "href": "Documentation/grains/grain_persistence/relational_storage.html",
    "title": "ADO.NET Grain Persistence | Microsoft Orleans 中文文档",
    "keywords": "ADO.NET Grains持久化 Orleans的关系存储后端代码是基于ADO.NET功能，因此与数据库供应商无关。Orleans数据存储布局已经在运行时表中解释过了。按照中的说明设置连接字符串 Orleans配置指南 . 要使Orleans代码在给定的关系数据库后端运行，需要执行以下操作： 适当的ADO.NET库必须加载到进程中。这应该像往常一样定义，例如 数据库供应商工厂 应用程序配置中的元素。 配置ADO.NET不变性 Invariant 属性。 数据库需要存在并与代码兼容。这是通过运行特定于供应商的数据库创建脚本来完成的。有关详细信息，请参阅 ADO.NET配置 . NETGrain存储提供程序允许您在关系数据库中存储Grain状态。当前支持以下数据库： SQLServer MySQL/MariaDB PostgreSQL Oracle 首先，安装基本软件包： Install-Package Microsoft.Orleans.Persistence.AdoNet 阅读 ADO.NET配置 文章获取有关配置数据库的信息，包括相应的ADO.NET不变和设置脚本。 下面是如何通过 ISiloHostBuilder 配置ADO.NET存储提供商: var siloHostBuilder = new SiloHostBuilder() .AddAdoNetGrainStorage(\"OrleansStorage\", options => { options.Invariant = \"<Invariant>\"; options.ConnectionString = \"<ConnectionString>\"; options.UseJsonFormat = true; }); 实际上，您只需要设置特定于数据库供应商的连接字符串和 Invariant (参见 ADO.NET配置 )标识供应商。您还可以选择保存数据的格式，可以是二进制(默认)、JSON或XML。虽然二进制是最紧凑的选项，但它是不透明的，您将无法读取或处理数据。JSON是推荐的选项。 您可以通过设置以下属性 AdoNetGrainStorageOptions : /// <summary> /// Options for AdoNetGrainStorage /// </summary> public class AdoNetGrainStorageOptions { /// <summary> /// Connection string for AdoNet storage. /// </summary> [Redact] public string ConnectionString { get; set; } /// <summary> /// Stage of silo lifecycle where storage should be initialized. Storage must be initialized prior to use. /// </summary> public int InitStage { get; set; } = DEFAULT_INIT_STAGE; /// <summary> /// Default init stage in silo lifecycle. /// </summary> public const int DEFAULT_INIT_STAGE = ServiceLifecycleStage.ApplicationServices; /// <summary> /// The default ADO.NET invariant used for storage if none is given. /// </summary> public const string DEFAULT_ADONET_INVARIANT = AdoNetInvariants.InvariantNameSqlServer; /// <summary> /// The invariant name for storage. /// </summary> public string Invariant { get; set; } = DEFAULT_ADONET_INVARIANT; /// <summary> /// Whether storage string payload should be formatted in JSON. /// <remarks>If neither <see cref=\"UseJsonFormat\"/> nor <see cref=\"UseXmlFormat\"/> is set to true, then BinaryFormatSerializer will be configured to format storage string payload.</remarks> /// </summary> public bool UseJsonFormat { get; set; } public bool UseFullAssemblyNames { get; set; } public bool IndentJson { get; set; } public TypeNameHandling? TypeNameHandling { get; set; } public Action<JsonSerializerSettings> ConfigureJsonSerializerSettings { get; set; } /// <summary> /// Whether storage string payload should be formatted in Xml. /// <remarks>If neither <see cref=\"UseJsonFormat\"/> nor <see cref=\"UseXmlFormat\"/> is set to true, then BinaryFormatSerializer will be configured to format storage string payload.</remarks> /// </summary> public bool UseXmlFormat { get; set; } } 这个ADO.NETpersistence具有版本数据和使用任意应用程序规则和流定义任意(反)序列化程序的功能，但目前还没有将它们公开给应用程序代码的方法。 ADO.NET持久化原理 原则ADO.NET支持的持久化存储包括： 在数据、数据格式和代码不断发展的同时，保持业务关键数据的安全性。 利用特定于供应商和存储的功能。 实际上，这意味着要坚持ADO.NET中的实现目标和一些添加的实现逻辑ADO.NET允许改变存储器中数据形状的特定存储提供程序。 除了通常的存储提供程序功能之外ADO.NET提供程序的内置功能 在往返状态下，将存储数据格式从一种格式更改为另一种格式(例如从JSON更改为二进制)。 以任意方式塑造要保存或从存储器中读取的类型。这有助于改进版本状态。 从数据库中流出数据。 两者兼而有之 1 和 2 可以应用于任意决策参数，例如 grains id , grains type , payload data . 这种情况的发生是为了选择一种格式，例如。 简单二进制编码(SBE) 和工具 IStorageDeserializer 和 IStorageSerializer . 内置序列化程序是使用此方法生成的。这个 OrleanStorageDefault(反)序列化程序 可以作为如何实现其他格式的示例。 实现序列化程序后，需要将它们添加到 StorageSerializationPicker 中的属性 AdoNetGrainStorage . 这是一个 IStorageSerializationPicker . 默认情况下 StorageSerializationPicker 将被使用。更改数据存储格式或使用序列化程序的示例可以在 关系存储测试 . 目前还没有方法将其公开给Orleans应用程序使用，因为没有方法访问所创建的框架 AdoNetGrainStorage . 设计目标 1. 允许使用任何具有ADO.NET供应商 这应该包括.NET可用的最广泛的后端集，这是本地安装的一个因素。一些提供商列在 ADO.NET数据提供程序MSDN页 ，但为了说明，并不是所有的都列出来了，比如 Teradata . 2. 即使在部署正在运行时，也要保持适当地优化查询和数据库结构的潜力 在许多情况下，服务器和数据库由与客户端有合同关系的第三方托管。由于虚拟化环境的不可预见性和不可预见性等因素，虚拟化环境下的主机性能是不可预见的。可能无法更改和重新部署Orleans二进制文件(合同原因)甚至应用程序二进制文件，但通常可以调整数据库部署。改变 标准部件 ，例如Orleans二进制文件，需要一个更长的过程来确定在给定的情况下可以提供什么。 3. 允许使用供应商和版本特定的能力 供应商在他们的产品中实现了不同的扩展和特性。当这些功能可用时，使用它们是明智的。这些功能包括 本地UPSERT 或 管道数据库 在PostgreSQL中， 多基 或 本机编译的表和存储过程 在SQL Server中–以及无数其他功能。 4. 使硬件资源优化成为可能 在设计应用程序时，通常可以预测哪些数据需要比其他数据更快地插入，哪些数据更有可能被放入 冷库 哪种更便宜(例如在SSD和HDD之间拆分数据)。例如，进一步的考虑因素是某些数据的物理位置可能更昂贵(例如SSD RAID viz HDD RAID)、更安全或使用一些其他决策属性。与…有关 第三点。 有些数据库提供特殊的分区方案，如sqlserver 分区表和索引 . 这一原则也适用于整个应用程序生命周期。考虑到Orleans本身的一个原则是高可用性系统，因此应该可以在不中断Orleans部署的情况下调整存储系统，或者可以根据数据和其他应用程序参数调整查询。变化的一个例子是布莱恩·哈里的 博客文章 : 当表很小时，查询计划是什么几乎无关紧要。当它是中等的时候，一个好的查询计划是好的。当它是巨大的(数以百万计或数十亿行)时，查询计划中的微小变化可能会杀死您。因此，我们对敏感查询进行了大量提示。 5. 对组织中使用的工具、库或部署过程没有任何假设 许多组织都熟悉某种数据库工具，例如 Dacpac 或 Red Gate . 部署数据库可能需要权限或人员(例如DBA角色中的人员)来执行此操作。通常这意味着还要有目标数据库布局和应用程序将对数据库产生的查询的粗略草图来估计负载。可能有一些流程，可能受行业标准的影响，强制要求基于脚本的部署。将查询和数据库结构放在一个外部脚本中使这成为可能。 6. 使用接口功能所需的最小集来加载ADO.NET库和功能 这是既快又较少暴露ADO.NET库的实现细节。 7. 使设计可共享 当它有意义时，例如在关系存储提供程序中，使设计易于共享。这意味着没有依赖于数据库的数据(例如。 Identity )基本上，这意味着区分行数据的信息应该只建立在数据和实际参数的基础上。 8. 使设计易于测试 理想情况下，创建一个新的后端应该像翻译一个部署脚本和向测试添加一个新的连接字符串一样简单，假设默认参数，检查是否安装了给定的数据库，然后对其运行测试。 9. 考虑到前面几点，使新后端的移植脚本和修改已部署的后端脚本尽可能透明 目标的实现 Orleans framework不了解特定于部署的硬件(在主动部署期间可能会发生变化)、部署生命周期中的数据更改以及某些特定于供应商的特性仅在某些情况下可用。因此，关系数据库和Orleans之间的接口应该遵循一组最小的抽象和规则，以满足目标，但也要使其健壮，防止误用，并在需要时易于测试。运行时表、集群管理和具体的 成员协议实现 . 此外，SQL Server实现包含SQL Server版本特定的调整。数据库与Orleans的接口合同定义如下： 总的想法是通过Orleans特定的查询来读写数据。Orleans在读取时操作列名和类型，在写入时操作参数名称和类型。 实施 必须 保留输入和输出名称和类型。Orleans使用这些参数按名称和类型读取查询结果。只要保持接口契约，就允许进行特定于供应商和部署的调优，并鼓励贡献。 跨供应商特定脚本的实现 应该 保留约束名称。这通过跨具体实现的统一命名简化了故障排除。 版本 –或 ETag 应用程序代码中–因为Orleans代表了一个独特的版本。它实际实现的类型并不重要，只要它代表一个唯一的版本。在实现中，Orleans代码需要一个有符号的32位整数。 为了明确和消除歧义，Orleans希望一些查询返回 TRUE as > 0 值或 False as=0 价值观。也就是说，受影响的行或类似的行并不重要。如果引发错误或引发异常，则查询 必须 确保整个事务被回滚，并且可能返回FALSE或传播异常。 目前除了一个查询外，所有查询都是单行插入或更新(注意，一个可以替换 Update 查询 Insert 他们提供了 Select 查询将提供最后一次写入)统计插入除外。统计插入，定义如下 InsertOrleansStatisticsKey 使用以预定义的最大大小批量写入统计信息 Union All 对于除Oracle之外的所有数据库 UNION ALL FROM DUAL 构造被使用。 InsertOrleansStatisticsKey 是唯一定义一种模板参数的查询，Orleans将其乘以具有不同值的参数的倍数。 数据库引擎支持数据库编程，这类似于加载可执行脚本并调用它来执行数据库操作的思想。在伪代码中，它可以描述为 const int Param1 = 1; const DateTime Param2 = DateTime.UtcNow; const string queryFromOrleansQueryTableWithSomeKey = \"SELECT column1, column2 FROM <some Orleans table> where column1 = @param1 AND column2 = @param2;\"; TExpected queryResult = SpecificQuery12InOrleans<TExpected>(query, Param1, Param2); 这些原则也是 包含在数据库脚本中 . 应用定制脚本的几点思考 更改 OrleansQuery 中脚本的 IF ELSE ，以便Grains的持久化使用默认值保存某些状态 插入 ,例如，一些Grains状态使用， 内存优化表 . 这个 SELECT 查询需要相应地修改。 这个想法 1 可用于利用其他部署或特定于供应商的方面。例如在 SSD 或 HDD ，将一些数据放在加密的表上，或者通过sqlserver将统计数据插入Hadoop，甚至 链接服务器 . 修改后的脚本可以通过运行Orleans测试套件或直接在数据库中测试，例如， SQL Server单元测试项目 . 添加新的ADO.NET供应商指南 根据 目标的实现 以上章节。 将供应商ADO不变名称添加到 ADO变量 以及ADO.NET提供程序特定数据 DbConstantStore . 它们(可能)用于某些查询操作。e、 g.选择正确的统计插入模式(即 Union All 有或没有 FROM DUAL ). Orleans对所有系统商店都有全面的测试：会员资格、提醒和统计数据。为新数据库脚本添加测试是通过复制粘贴现有测试类和更改ADO不变名来完成的。同样，从 关系存储测试 以定义ADOInvariant的测试功能。"
  },
  "Documentation/grains/grain_persistence/dynamodb_storage.html": {
    "href": "Documentation/grains/grain_persistence/dynamodb_storage.html",
    "title": "Amazon DynamoDB Grain Persistence | Microsoft Orleans 中文文档",
    "keywords": "Amazon DynamoDBGrain持久化 安装 安装 Microsoft.Orleans.Persistence.DynamoDB NuGet的软件包。 组态 使用以下命令配置Dynamo DB Grain Persistence提供程序 ISiloBuilder.AddDynamoDBGrainStorage 扩展方法。 siloBuilder.AddDynamoDBGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.AccessKey = /* Dynamo DB access key */; options.SecretKey = /* Dynamo DB secret key */; options.Service = /* Dynamo DB service name */; });"
  },
  "Documentation/grains/grain_persistence/index.html": {
    "href": "Documentation/grains/grain_persistence/index.html",
    "title": "Persistence | Microsoft Orleans 中文文档",
    "keywords": "持久化 Grains可以具有多个与之关联的命名持久数据对象。在激活Grains期间会从存储中加载此状态，以便在请求期间可以使用它们。Grain持久化使用可扩展的插件模型，因此可以使用任何数据库的存储提供程序。此持久化模型仅出于简化目的而设计，并不旨在涵盖所有数据访问模式。Grains还可以直接访问数据库，而无需使用Grains持久化模型。 在上图中，UserGrain有一个 Profile 状态和 Cart 状态，每个状态都存储在单独的存储系统中。 目标 每个Grains有多个命名的持久数据对象。 多个配置的存储提供程序，每个存储提供程序可以具有不同的配置并由不同的存储系统支持。 存储提供商可以由社区开发和发布。 存储提供者可以完全控制他们如何在持久化后备存储中存储Grains状态数据。结论：Orleans没有提供全面的ORM存储解决方案，但允许自定义存储提供商在需要时支持特定的ORM要求。 配套 可以在以下位置找到OrleansGrains存储提供商 NuGet 。官方维护的软件包包括： Microsoft.Orleans.Persistence.AdoNet 适用于ADO.NET支持的SQL数据库和其他存储系统。有关更多信息，请参见 ADO.NETGrain持久化 。 Microsoft.Orleans.Persistence.AzureStorage 通过Azure Table Storage API访问Azure存储，包括Azure Blob存储，Azure表存储和Azure CosmosDB。有关更多信息，请参见 Azure存储Grain持久化 。 Microsoft.Orleans.Persistence.DynamoDB 适用于Amazon DynamoDB。有关更多信息，请参见 Amazon DynamoDBGrain持久化 。 API Grains与它们的持久状态相互作用 IPersistentState <TState> 哪里 State 是可序列化状态类型： Grains通过 IPersistentState<TState> （其中 <TState> 为其可序列化状态类型）与它们的持久化状态交互。 public interface IPersistentState<TState> where TState : new() { TState State { get; set; } string Etag { get; } Task ClearStateAsync(); Task WriteStateAsync(); Task ReadStateAsync(); } IPersistentState <TState> 的实例作为构造函数参数注入到Grains中。这些参数可以用 [PersistentState(stateName，storageName)] 属性来标识要注入的状态的名称以及提供状态存储提供程序的名称。以下示例通过将两个命名状态注入到 UserGrain 构造函数： public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; private readonly IPersistentState<CartState> _cart; public UserGrain( [PersistentState(\"profile\", \"myGrainStorage\")] IPersistentState<ProfileState> profile, [PersistentState(\"cart\", \"cartStorage\")] IPersistentState<CartState> cart, ) { _profile = profile; _cart = cart; } } 即使它们是同一类型，不同的Grain类型也可以使用不同的配置存储提供程序：例如，两个不同的Azure Table Storage提供程序实例连接到不同的Azure存储帐户。 读取状态 当激活grains时，将自动读取grains状态，但是grains负责在必要时显式触发任何更改的grains状态的写入。 如果某个Grains希望从后备存储中明确重新读取该Grains的最新状态，则该Grains应调用 ReadStateAsync() 方法。 这将通过存储提供程序从持久存储重新加载Grain状态，并且当 ReadStateAsync() 任务完成时，将覆盖和替换之前的内存状态副本。 使用以下命令访问状态值 State 属性。例如，以下方法访问上面的代码中声明的配置文件状态： public Task<string> GetNameAsync() => Task.FromResult(_profile.State.Name); 无需调用 ReadStateAsync() 在正常操作期间：在激活期间自动加载状态。然而， ReadStateAsync() 可以用来刷新外部修改的状态。 见 失败模式 以下部分提供了有关错误处理机制的详细信息。 写入状态 状态可以通过 State 属性。修改后的状态不会自动保持。相反，开发人员通过调用 WriteStateAsync() 方法。例如，以下方法更新一个属性 State 并保持更新状态： public async Task SetNameAsync(string name) { _profile.State.Name = name; await _profile.WriteStateAsync(); } 从概念上讲，Orleans运行时将在任何写入操作期间获取Grains状态数据对象的深层副本以供其自己使用。在幕后，运行时 可能 在保留预期的逻辑隔离语义的前提下，使用优化规则和试探法避免在某些情况下执行部分或全部深度复制。 见 失败模式 以下部分提供了有关错误处理机制的详细信息。 状态清理 ClearStateAsync() 方法清除存储中的Grains状态。根据提供者，此操作可以选择完全删除grains状态。 入门 在Grains可以使用持久化之前，必须在silos上配置存储提供程序。 首先，配置存储提供程序： var host = new HostBuilder() .UseOrleans(siloBuilder => { // Configure Azure Table storage using the name \"profileStore\" siloBuilder.AddAzureTableGrainStorage( name: \"profileStore\", configureOptions: options => { // Use JSON for serializing the state in storage options.UseJson = true; // Configure the storage connection key options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; }); // -- other options }) .Build(); 现在，已经使用名称配置了存储提供程序 “ profileStore” ，我们可以从Grains访问此提供程序。 持久状态可以通过两种主要方式添加到Grains中： 通过注入 IPersistentState <TState> 进入Grains的构造函数 通过继承 Grain<TState> 推荐的添加Grains存储方式的方法是通过注入 IPersistentState<TState> 并关联 [PersistentState(\"stateName\",\" providerName\")] 属性到Grains的构造函数。有关详细信息 GrainsTState> ， 见下文 。仍支持此功能，但被认为是旧版。 声明一个类来保持我们的Grains状态： [Serializable] public class ProfileState { public string Name { get; set; } public Date DateOfBirth } 注入 IPersistentState <配置文件状态> 到Grains的构造函数中： public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; public UserGrain([PersistentState(\"profile\", \"profileStore\")] IPersistentState<ProfileState> profile) { _profile = profile; } } 注意：配置文件状态在注入到构造函数中时不会被加载，因此那时访问它是无效的。该状态将在 OnActivateAsync 调用。 现在，grain具有持久状态，我们可以添加读取和写入状态的方法： public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; public UserGrain([PersistentState(\"profile\", \"profileStore\")] IPersistentState<ProfileState> profile) { _profile = profile; } public Task<string> GetNameAsync() => Task.FromResult(_profile.State.Name); public async Task SetNameAsync(string name) { _profile.State.Name = name; await _profile.WriteStateAsync(); } } 持久化操作的失败模式 读取操作的失败模式 存储提供程序在初始读取该特定Grain的状态数据期间返回的故障将导致Grain的激活操作失败;在这种情况下，将不调用该Grain的 OnActivateAsync() 生命周期回调方法。 导致激活该Grain的失败的原始请求将像在Grain激活期间任何其他故障一样返回给调用方。 存储提供程序在读取特定Grains的状态数据时遇到失败，将导致 ReadStateAsync() 任务失败。Grains可以选择处理或忽略该故障 Task ，就像其他任何东西一样 Task 在Orleans。 由于缺少/错误的存储提供程序配置，任何在silos启动时无法加载消息的尝试都会返回永久错误 Orleans.BadProviderConfigException 。 写入操作的失败模式 存储提供程序在写入特定Grains的状态数据时遇到失败，将导致 WriteStateAsync() 任务失败。通常，这将意味着Grain调用将把错误返回给客户端调用者，前提是 WriteStateAsync() 任务被正确地链接到这个Grain方法最终返回的 Task 中。但是，某些高级方案可能会编写Grain代码来专门处理此类错误，就像它们可以处理任何其他错误一样 Task 。 执行错误处理/恢复代码的Grains 必须 捕获 WriteStateAsync() 任务的异常/错误，而不重新抛出以表示它们已成功处理了写入错误。 推荐建议 使用JSON序列化或其他版本容忍的序列化格式 代码会随着时间的推移而发展，并且通常还包括存储类型。为了适应这些更改，应配置适当的序列化方式。对于大多数存储提供商而言， Json 选项或类似选项可用于将JSON用作序列化格式。确保在发展数据合同时，已经存储的数据仍然可以加载。 使用Grain 为Grains指定存储 注意： 使用 grains<T> 为Grainsz指定存储考虑为 遗留 功能：应使用以下方式添加Grains存储 IPersistentState <T> 如前所述。 继承自的Grains类 grains<T> (哪里 T 是需要保留的特定于应用程序的状态数据类型)，将从指定存储中自动加载其状态。 此类Grains标有 [StorageProvider] 该属性指定一个存储提供程序的命名实例，该实例用于读取/写入此Grains的状态数据。 [StorageProvider(ProviderName=\"store1\")] public class MyGrain : Grain<MyGrainState>, /*...*/ { /*...*/ } 的 grains<T> 基类定义了以下方法供子类调用： protected virtual Task ReadStateAsync() { /*...*/ } protected virtual Task WriteStateAsync() { /*...*/ } protected virtual Task ClearStateAsync() { /*...*/ } 这些方法的行为对应于 IPersistentState <TState> 较早定义。 创建存储提供程序 状态持久化API有两部分：通过 IPersistentState <T> 要么 grains<T> ， 以及以 IGrainStorage 为中心的存储提供程序API——存储提供程序必须实现的接口。 /// <summary> /// Interface to be implemented for a storage able to read and write Orleans grain state data. /// </summary> public interface IGrainStorage { /// <summary>Read data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">State data object to be populated for this grain.</param> /// <returns>Completion promise for the Read operation on the specified grain.</returns> Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); /// <summary>Write data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">State data object to be written for this grain.</param> /// <returns>Completion promise for the Write operation on the specified grain.</returns> Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); /// <summary>Delete / Clear data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">Copy of last-known state data object for this grain.</param> /// <returns>Completion promise for the Delete operation on the specified grain.</returns> Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); } 通过实现此接口来创建自定义存储提供程序，并 注册 该实施。有关现有存储提供程序实现的示例，请参见 AzureBlobGrainStorage 。 存储提供程序语义 特定于不透明的提供者 Etag 值( string ) 可能 由存储提供者设置为读取状态时填充的Grains状态元数据的一部分。一些提供商可能选择将此保留为 null 如果他们不使用 Etag 。 当存储提供程序检测到 Etag 约束违反_should_时，任何执行写操作的尝试都会导致写 Task 出现故障，并出现瞬时抛出 Orleans.InconsistentStateException 异常并并包装基础存储异常。 public class InconsistentStateException : OrleansException { public InconsistentStateException( string message, string storedEtag, string currentEtag, Exception storageException) : base(message, storageException) { this.StoredEtag = storedEtag; this.CurrentEtag = currentEtag; } public InconsistentStateException(string storedEtag, string currentEtag, Exception storageException) : this(storageException.Message, storedEtag, currentEtag, storageException) { } /// <summary>The Etag value currently held in persistent storage.</summary> public string StoredEtag { get; private set; } /// <summary>The Etag value currently held in memory, and attempting to be updated.</summary> public string CurrentEtag { get; private set; } } 来自存储操作的任何其他失败条件都会导致返回的 Task 被中断，并出现一个异常，指示底层存储问题。在许多情况下，此异常可能会返回给调用方，后者通过在Grains上调用方法来触发存储操作。重要的是要考虑调用者是否可以反序列化此异常。例如，客户端可能尚未加载包含异常类型的特定持久化库。因此，建议将异常转换为可以传播回调用方的异常。 数据映射 各个存储提供者应决定如何最好地存储Grains状态-blob(各种格式/序列化形式)或每字段列是显而易见的选择。 注册存储提供商 Orleans运行时将从服务提供商那里解析存储提供商( IServiceProvider )创建Grain时。运行时将解析一个实例 IGrainStorage 。如果存储提供者已命名，例如通过 [PersistentState(stateName，storageName)] 属性，然后是的命名实例 IGrainStorage 将得到解决。 注册的命名实例 IGrainStorage ， 使用 IServiceCollection.AddSingletonNamedService 扩展方法，可以参考以下 AzureTableGrainStorage提供程序 。"
  },
  "Documentation/grains/grain_persistence/azure_storage.html": {
    "href": "Documentation/grains/grain_persistence/azure_storage.html",
    "title": "Azure Storage Grain Persistence | Microsoft Orleans 中文文档",
    "keywords": "Azure存储Grain持久化 Azure存储Grain持久化提供程序同时支持 Azure Blob存储 和 Azure表存储 。 安装 安装 Microsoft.Orleans.Persistence.AzureStorage NuGet的软件包。 组态 Azure表存储 Azure表存储提供程序将状态存储在表行中，如果超出单个列的限制，则将状态分为多个列。每行的最大长度为一兆字节，例如 扩展Azure表存储 。 使用以下命令配置Azure表存储Grain持久化提供程序 ISiloBuilder.AddAzureTableGrainStorage 扩展方法。 siloBuilder.AddAzureTableGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; }); Azure Blob存储 Azure Blob存储提供程序将状态存储在Blob中。 使用以下命令配置Azure Blob存储Grain持久化提供程序 ISiloBuilder.AddAzureBlobGrainStorage 扩展方法。 siloBuilder.AddAzureBlobGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; });"
  },
  "Documentation/grains/grain_versioning/backward_compatibility_guidelines.html": {
    "href": "Documentation/grains/grain_versioning/backward_compatibility_guidelines.html",
    "title": "向后兼容准则 | Microsoft Orleans 中文文档",
    "keywords": "向后兼容准则 编写向后兼容的代码可能很难测试。 永远不要更改现有方法的签名 由于Orleans序列化程序的工作方式，您永远不应该更改现有方法的签名。 以下示例是正确的： [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } 这是不正确的： [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg, obj o); } 注意 ：您不应在代码中进行此更改，因为这是导致非常糟糕的副作用的不良实践的示例。这是一个如果您只重命名参数名会发生什么的示例：假设我们在集群中部署了以下两个接口版本： [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // return a - b Task<int> Substract(int a, int b); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // return y - x Task<int> Substract(int y, int x); } 这种方法似乎是相同的。但是，如果使用V1调用客户端，并且请求由V2激活处理： var grain = client.GetGrain<IMyGrain>(0); var result = await grain.Substract(5, 4); // Will return \"-1\" instead of expected \"1\" 这是由于内部Orleans序列化程序是如何工作的。 避免改变现有的方法逻辑 这看起来很明显，但是在更改现有方法的主体时应该非常小心。除非您正在修复一个bug，否则如果您需要修改代码，最好只添加一个新方法。 例子： // V1 public interface MyGrain : IMyGrain { // First method Task MyMethod(int arg) { SomeSubRoutine(arg); } } // V2 public interface MyGrain : IMyGrain { // Method inherited from V1 // Do not change the body Task MyMethod(int arg) { SomeSubRoutine(arg); } // New method added in V2 Task MyNewMethod(int arg) { SomeSubRoutine(arg); NewRoutineAdded(arg); } } 不要从grain接口删除方法 除非确定不再使用这些方法，否则不应从grain接口中删除方法。如果要删除方法，应该分两步完成：1。部署V2grains，V1方法标记为 过时的 [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 [Obsolete] Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } 当您确定没有进行V1调用时(实际上V1不再部署在正在运行的集群中)，则在部署V3时删除V1方法 cs [Version(3)] public interface IMyGrain : IGrainWithIntegerKey { // New method added in V2 Task MyNewMethod(int arg, obj o); }"
  },
  "Documentation/grains/grain_versioning/compatible_grains.html": {
    "href": "Documentation/grains/grain_versioning/compatible_grains.html",
    "title": "兼容Grains | Microsoft Orleans 中文文档",
    "keywords": "兼容Grains 当现有的Grains激活将要处理请求时，运行时将检查请求中的版本与Grains的实际版本是否兼容。 Orleans不会在运行时推断要使用哪个策略 ，确定两个版本是否兼容的默认行为由 GrainVersioningOptions.CompatibilityStrategy 向后兼容(默认) 定义 如果满足以下条件，则Grain接口版本Vn可以与Vm向后兼容： 接口名称未更改(或覆盖的类型代码) Vm版本中存在的所有公共方法都在Vn版本中。 重要的是，不要修改从Vm继承的方法的签名。 ：由于Orleans使用内部内置的序列化程序，因此修改/重命名字段(甚至私有)可能会使序列化中断。 由于Vn与Vm相比可以增加其他方法，因此Vm与Vn不兼容。 例 如果在集群中，给定接口有两个版本，即V1和V2，并且该V2向后兼容V1： 如果当前激活为V2，而请求的版本为V1，则当前激活将能够正常处理请求 如果当前激活为V1，而请求的版本为V2，则将取消激活当前激活，并创建与V2兼容的新激活(请参见 版本选择器策略 )。 完全兼容 定义 如果满足以下条件，则Grains接口版本Vn可以与Vm完全兼容： Vn与Vm向后兼容 在Vn版本中未添加任何公共方法 如果Vn与Vm完全兼容，则Vm也与Vn完全兼容。 例 如果在集群中，给定接口有两个版本，即V1和V2，并且该V2与V1完全兼容： 如果当前激活为V2，而请求的版本为V1，则当前激活将能够正常处理请求 如果当前激活为V1，而请求的版本为V2，则当前激活也将能够正常处理请求"
  },
  "Documentation/grains/grain_versioning/grain_versioning.html": {
    "href": "Documentation/grains/grain_versioning/grain_versioning.html",
    "title": "grains接口版本控制 | Microsoft Orleans 中文文档",
    "keywords": "grains接口版本控制 [!警告]本页介绍如何使用Grain接口版本控制。Grain状态的版本控制超出范围。 概述 在给定的集群上，silos可以支持不同版本的Grains类型。 在本例中，客户端和silos{1,2,3}是用grain接口编译的 A 版本1。silos4是用 A 版本2。 限制： 无状态工作进程 流接口没有版本控制 启用版本控制 默认情况下，不会对grains进行版本控制。您可以使用grain接口上的VersionAttribute来设置grain版本： [Version(X)] public interface IVersionUpgradeTestGrain : IGrainWithIntegerKey {} 在哪里？ 十 是grains接口的版本号，通常单调递增。 grains版本兼容性和存储 当来自版本控制的grain的调用到达集群时： 如果不存在激活，将创建兼容的激活 如果激活存在： 如果当前的不兼容，它将被停用并创建新的兼容的(请参阅 版本选择器策略 ) 如果当前版本兼容(请参见 相容grains )，访问将正常处理。 默认情况下： 所有版本化的grains只能向后兼容(参见 向后兼容准则 和 相容grains ). 这意味着v1grains可以调用v2grains，但v2grains不能调用v1。 当集群中存在多个版本时，新的激活将随机存储在兼容的silos上。 您可以通过选项更改此默认行为 GrainVersioning选项 : var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(MinimumVersion); }) [...]"
  },
  "Documentation/grains/grain_lifecycle.html": {
    "href": "Documentation/grains/grain_lifecycle.html",
    "title": "Grain Lifecycle | Microsoft Orleans 中文文档",
    "keywords": "Grains生命周期 总览 OrleansGrains使用可观察到的生命周期(请参见 Orleans生命周期 )进行有序的激活和停用。这允许在Grains激活和收集期间以有序的方式启动和停止Grains逻辑，系统组件和应用程序逻辑。 阶段 预定的Grains生命周期阶段如下。 public static class GrainLifecycleStage { public const int First = int.MinValue; public const int SetupState = 1000; public const int Activate = 2000; public const int Last = int.MaxValue; } First -Grains生命周期的第一阶段 SetupState –在激活之前设置grains状态。对于有状态的Grains，这是从存储中加载状态的阶段。 Activate – OnActivateAsync 和 OnDeactivateAsync 阶段 Last -Grains生命周期的最后阶段 尽管将在Grains激活期间使用Grains生命周期，但由于在某些错误情况下(例如Silo崩溃)并非总是停用Grains，因此应用程序不应依赖于在Grains停用过程中始终执行的Grains生命周期。 grain生命周期参与 应用程序逻辑可以通过两种方式参与Grains的生命周期：Grains可以参与其生命周期，和/或组件可以通过Grains激活上下文访问生命周期(请参阅IGrainActivationContext.ObservableLifecycle)。 Grains始终参与其自身的生命周期，因此可以通过覆盖参与方法来引入应用程序逻辑。 示例 public override void Participate(IGrainLifecycle lifecycle) { base.Participate(lifecycle); lifecycle.Subscribe(this.GetType().FullName, GrainLifecycleStage.SetupState, OnSetupState); } 在上面的示例中， grains<T> 覆盖 参加 告诉生命周期的方法在生命周期的SetupState阶段调用其OnSetupState方法。 在Grains的构造过程中创建的组件也可以参与生命周期，而无需添加任何特殊的Grains逻辑。由于Grains的激活环境( IGrainActivationContext )，包括Grains的生命周期( IGrainActivationContext.ObservableLifecycle )是在创建Grains之前创建的，容器注入Grains中的任何成分都可以参与Grains的生命周期。 示例 使用工厂方法 Create(..) 创建时，以下组件会参与Grains的生命周期。这种逻辑可能存在于组件的构造函数中，但是这会冒着风险在组件完全构建之前将其添加到生命周期中的风险，这可能并不安全。 public class MyComponent : ILifecycleParticipant<IGrainLifecycle> { public static MyComponent Create(IGrainActivationContext context) { var component = new MyComponent(); component.Participate(context.ObservableLifecycle); return component; } public void Participate(IGrainLifecycle lifecycle) { lifecycle.Subscribe<MyComponent>(GrainLifecycleStage.Activate, OnActivate); } private Task OnActivate(CancellationToken ct) { // Do stuff } } 通过工厂方法 Create(..) 注册上述组件到服务容器中，任何将组件作为依赖项构造的grain将使组件参与其生命周期，而grain中没有任何特殊逻辑。 在容器中注册组件 services.AddTransient<MyComponent>(sp => MyComponent.Create(sp.GetRequiredService<IGrainActivationContext>()); Grains以成分为依存关系 public class MyGrain : Grain, IMyGrain { private readonly MyComponent component; public MyGrain(MyComponent component) { this.component = component; } }"
  },
  "Documentation/grains/stateless_worker_grains.html": {
    "href": "Documentation/grains/stateless_worker_grains.html",
    "title": "Stateless Worker Grains | Microsoft Orleans 中文文档",
    "keywords": "无状态工作者Grains 默认情况下，Orleans运行时在集群中创建的grain不超过一次激活。这是虚拟角色模型最直观的表达方式，每个Grain对应一个具有唯一类型/标识的实体。但是，也有一些情况下，应用程序需要执行与系统中特定实体无关的功能性无状态操作。例如，如果客户端发送的请求带有压缩的有效负载，而这些负载需要在将它们路由到目标Grain进行处理之前进行解压缩，那么这种解压缩/路由逻辑就不会绑定到应用程序中的特定实体，并且可以很容易地进行扩展。 当 [StatelessWorker] 属性应用于grain类，它向Orleans运行时指示该类的grains应被视为 无状态工作者 Grains。 无状态工作者 grains具有以下特性，使得它们的执行与普通grains类的执行非常不同。 Orleans运行时可以并且将在集群的不同silos上创建多个无状态工作线程的激活。 对无状态工作Grain的请求总是在本地执行，即在发出请求的同一个silos上执行，或者由silos上运行的Grain发出，或者由silos的客户端网关接收。因此，从其他Grain或客户端网关调用无状态工作线程不会引发远程消息。 如果已经存在的工作线程繁忙，Orleans运行时会自动创建无状态工作线程的额外激活。运行时为每个silos创建的无状态工作线程的最大激活数默认由计算机上的CPU内核数限制，除非可选的 maxLocalWorkers 争论。 由于2和3，无状态的Worker-grain激活不能单独寻址。对无状态工作线程Grain的两个后续请求可以通过对其进行不同的激活来处理。 无状态工作线程提供了一种直接的方法来创建一个自动管理的grain激活池，该池根据实际负载自动伸缩。运行时总是以相同的顺序扫描可用的无状态工作线程Grain激活。因此，它总是将请求发送到它可以找到的第一个空闲本地激活，并且只有在所有以前的激活都很忙的情况下才能到达最后一个。如果所有的激活都很忙并且还没有达到激活限制，它会在列表的末尾再创建一个激活，并将请求发送给它。这意味着，当对无状态工作线程的请求速率增加，并且现有的激活当前都很忙时，运行时会将其激活池扩展到最大限度。相反，当负载下降时，并且可以通过较少数量的无状态工作线程的激活来处理，则列表末尾的激活将不会得到分派给它们的请求。它们将变为空闲，并最终被标准激活收集过程停用。因此，激活池最终将缩小以匹配负载。 下面的示例定义了一个无状态的Worker grain类 MyStatelessWorkerGrain 使用默认的最大激活数限制。 [StatelessWorker] public class MyStatelessWorkerGrain : Grain, IMyStatelessWorkerGrain { ... } 对无状态Worker-grain的调用与对任何其他grain的调用相同。唯一的区别是，在大多数情况下，使用单个grainsID，0或 Guid.Empty . 当需要多个无状态工作线程Grain池时，可以使用多个grain ID，每个ID一个。 var worker = GrainFactory.GetGrain<IMyStatelessWorkerGrain>(0); await worker.Process(args); 这一个定义了一个无状态的Worker-grain类，每个silos只有一个grain激活。 [StatelessWorker(1)] // max 1 activation per silo public class MyLonelyWorkerGrain : ILonelyWorkerGrain { ... } 请注意 [StatelessWorker] 属性不会更改目标grain类的Reentrant性。与其他任何Grain一样，无状态工作者Grain在默认情况下是不Reentrant的。通过添加一个 [Reentrant] 属性设置为grain类。 State “无状态工作者”的“无状态”部分并不意味着无状态工作者不能有状态，并且仅限于执行功能性操作。与其他任何Grain一样，无状态工作线程可以加载所需的任何状态并将其保存在内存中。这只是因为一个无状态的Worker-grain的多个激活可以在集群的同一个和不同的Silo上创建，所以没有一个简单的机制来协调不同激活所保持的状态。 有几个有用的模式涉及到无状态工作者保持状态。 扩展热缓存项 对于具有高吞吐量的热缓存项，将每个这样的项保存在无状态工作进程中会使其a)在silos中自动横向扩展并跨群集中的所有silos；b)使数据始终在通过其客户端网关接收客户端请求的silos上本地可用，这样就可以在不需要额外的网络跃点到另一个silos的情况下响应请求。 减少样式聚合 在某些场景中，应用程序需要计算集群中特定类型的所有Grain的特定度量，并定期报告聚合。例如，报告每个游戏地图上的玩家数量、VoIP访问的平均持续时间等。如果成千上万或数百万个grains中的每一个都向单个全局聚合器报告其指标，聚合器将立即过载，无法处理大量报告。另一种方法就是将此任务转换为 2（或更多）步骤减少样式聚合。聚合的第一层是通过报告Grain将其指标发送到无状态工作者预聚合Grain来完成的。Orleans 运行时将自动为每个Silo创建无状态工作者Grain的多个激活。由于所有此类调用都将在本地处理，无需远程调用或消息序列化，因此此类聚合的成本将大大低于远程案例。现在，每个预聚合无状态工作者Grain的激活，独立或与其他本地激活协调，可以将其聚合报告发送到全局最终聚合器（或必要时发送到另一个缩减层），而无需重载。"
  },
  "Documentation/grains/external_tasks_and_grains.html": {
    "href": "Documentation/grains/external_tasks_and_grains.html",
    "title": "External Tasks and Grains | Microsoft Orleans 中文文档",
    "keywords": "外部任务和grain 根据设计，任何从子级代码中产生的子任务(例如，通过使用await要么 继续 要么 Task.Factory.StartNew )将在每次激活时分派 TPL任务计划程序 作为父任务，因此继承了与其余Grains代码相同的单线程执行模型。这是单线程执行的主要要点 基于Grains转向的并发 。 在某些情况下，Grains代码可能需要“突破”Orleans任务调度模型并“做一些特别的事情”，例如明确指向 Task 到其他任务计划程序或使用.NET线程池。这种情况的一个例子是当Grains代码必须执行同步的远程阻塞调用(例如远程IO)时。在Grains环境中执行此操作将阻塞Grains以及Orleans线程之一，因此永远不应该这样做。相反，grain代码可以在线程池线程上执行这段阻塞代码并加入(await)该执行的完成，并根据具体情况进行。我们希望，从“Orleans”调度程序中转义将是非常高级且很少需要的使用场景，超出了“正常”使用模式。 基于任务的API： 1)await， Task.Factory.StartNew (见下文)， Task.ContinuewWith ， Task.WhenAny ， Task.WhenAll ， Task.Delay 都尊重当前的任务计划程序。这意味着以默认方式使用它们而不传递其他TaskScheduler会使它们在Grains上下文中执行。 2)两者Task.Run 和 endMethod 的代表 Task.Factory.FromAsync 不要尊重当前的任务计划程序。他们都使用 TaskScheduler.Default Scheduler，它是.NET线程池任务Scheduler。因此，里面的代码Task.Run 和 endMethod 将始终在OrleansGrains的单线程执行模型之外的.NET线程池上运行， 如这里详细 。但是， 等待Task.Run 要么 等待Task.Factory.FromAsync 将在创建任务时在调度程序下运行，这就是Grains调度程序。 3) configureAwait(false) 是用于逃避当前任务计划程序的显式API。这将导致在等待的任务之后在 TaskScheduler.Default 调度程序，它是.NET线程池，因此将中断Orleans grain的单线程执行。你一般应该 永远不要使用 ConfigureAwait(false) 直接在Grains代码中。 4)带签名的方法 异步无效 不应与Grains一起使用。它们旨在用于图形用户接口事件处理程序。 Task.Factory.StartNew和异步委托 在任何C＃程序中调度任务的通常建议是使用Task.Run 有利于 Task.Factory.StartNew 。实际上，谷歌快速搜索使用 Task.Factory.StartNew() 会建议[那是危险的](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html)和[那应该永远喜欢Task.Run ]( https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)。但是，如果我们希望保留在Orleans单线程执行模型中，那么我们需要使用它，那么我们如何正确地执行它呢？使用时的“危险”`Task.Factory.StartNew()`是它本身不支持异步委托。这意味着这可能是一个错误：`var notIntendedTask = Task.Factory.StartNew(SomeDelegateAsync) 。 notIntendedTask 是*不*在以下时间完成的任务 SomeDelegateAsync 做。相反，应该*总是*解开返回的任务： var task = Task.Factory.StartNew(SomeDelegateAsync).Unwrap()`。 例： 以下是示例代码，演示了如何使用 TaskScheduler.Current ，Task.Run`以及一个特殊的自定义调度程序，可从OrleanGrains上下文以及如何返回到该上下文中逃脱。 public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; await TaskDelay(10000); // Current task scheduler did not change, the code after await is still running in the same task scheduler. Assert.AreEqual(orleansTs, TaskScheduler.Current); Task t1 = Task.Run( () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(TaskScheduler.Default, TaskScheduler.Current); } ); await t1; // We are back to the Orleans task scheduler. // Since await was executed in Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); // Example of using ask.Factory.StartNew with a custom scheduler to escape from the Orleans scheduler Task t2 = Task.Factory.StartNew(() => { // This code runs on the MyCustomSchedulerThatIWroteMyself scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(MyCustomSchedulerThatIWroteMyself, TaskScheduler.Current); }, CancellationToken.None, TaskCreationOptions.None, scheduler: MyCustomSchedulerThatIWroteMyself); await t2; // We are back to Orleans task scheduler. Assert.AreEqual(orleansTS, TaskScheduler.Current); } 高级示例-从运行在线程池上的代码进行Grain调用 甚至更高级的方案是一段Grains代码，需要“突破”Orleans任务调度模型并在线程池(或其他非Orleans上下文)上运行，但仍需要调用另一个Grains。如果您尝试进行一次Grains调用但不在Orleans上下文中，则会收到一个异常，指出您正在“尝试从silos而不是从Grains内部而不是系统目标内部发送消息(RuntimeContext不是 设置为SchedulingContext)”。 public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; Task<int> t1 = Task.Run(async () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); // You can do whatever you need to do here. Now let's say you need to make a grain call. Task<Task<int>> t2 = Task.Factory.StartNew(() => { // This code runs on the Orleans task scheduler since we specified the scheduler: orleansTs. Assert.AreEqual(orleansTS, TaskScheduler.Current); return GrainFactory.GetGrain<IFooGrain>(0).MakeGrainCall(); }, CancellationToken.None, TaskCreationOptions.None, scheduler: orleansTs); int res = await (await t2); // double await, unrelated to Orleans, just part of TPL APIs. // This code runs back on the thread pool scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); return res; } ); int result = await t1; // We are back to the Orleans task scheduler. // Since await was executed in the Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); } 下面的代码演示了如何从在Grains内部但不在Grains上下文中运行的一段代码进行Grains调用。 与图书馆打交道 您的代码正在使用的某些外部库可能正在使用 ConfigureAwait(false)内部。 实际上，在.NET中使用它是一种正确的好习惯 ConfigureAwait(false) 在实现通用库时。在Orleans，这不是问题。 只要调用库方法的grain中的代码正在等待常规的库调用 等待，粒码正确。 结果将完全符合要求-库代码将在Default Scheduler上继续运行(碰巧是 ThreadPoolTask​​Scheduler 但这不能保证继续操作一定会在ThreadPool线程上运行，因为继续操作通常在上一个线程中内联)，而grain代码将在Orleans调度程序上运行。 另一个经常问到的问题是，是否需要使用Task.Run -也就是说，是否需要将库代码显式卸载到ThreadPool(用于Grains代码) Task.Run(()=> myLibrary.FooAsync()))。答案是否定的。除了库代码进行阻塞同步调用的情况外，无需将任何代码卸载到ThreadPool。通常，任何编写正确且正确的.NET异步库(返回的方法 Task 并以 异步`后缀)请勿拨调用。因此，除非您怀疑异步库有故障或故意使用同步阻塞库，否则无需将任何内容卸载到ThreadPool。 摘要 你想做什么？ 怎么做 在.NET线程池线程上运行后台工作。不允许使用任何Grains代码或Grains调用。 Task.Run` grains接口调用 方法返回类型= Task 或 Task<T> 使用基于Orleans回合的并发保证( 往上看 )。 Task.Factory.StartNew(WorkerAsync).Unwrap() 使用基于Orleans回合的并发保证，可以从Grains代码运行同步工作者任务。 Task.Factory.StartNew(WorkerSync) 执行工作项的超时 Task.Delay + Task.WhenAny 用于async/await 普通的.NET Task-Async编程模型。支持和推荐 ConfigureAwait(false) 请勿使用内部Grains代码。仅在库内部允许。 调用异步库 await图书馆调用"
  },
  "Documentation/deployment/multi-cluster_support/MultiClusterConfiguration.html": {
    "href": "Documentation/deployment/multi-cluster_support/MultiClusterConfiguration.html",
    "title": "Multi-Cluster Configuration | Microsoft Orleans 中文文档",
    "keywords": "多群集配置 多群集配置确定哪些群集当前是多群集的一部分。它不会自动更改，但由操作员控制。因此，它与集群中使用的成员机制有很大不同，后者自动确定集群中的一组silos。 我们对服务中的集群使用以下术语： 集群是 积极的 如果它至少有一个活动silos，并且 不活动 否则 集群是 加入 如果它是当前多群集配置的一部分，并且 未连接 否则 活动/非活动与连接/非连接是独立的：所有四种组合都是可能的。 特定服务的所有集群都通过 八卦网 是的。八卦网传播配置和状态信息。 注入配置 运营商通过将配置更改注入多集群网络来发布配置更改。配置可以注入到任何集群中，并从那里扩展到所有活动集群。每个新配置都包含一个组成多集群的集群id列表。它还有一个UTC时间戳，用于跟踪它在八卦网中的传播。 最初，多集群配置为空，这意味着多集群列表为空(不包含集群)。因此，操作员 必须 最初注入多群集配置。一旦注入，此配置将在所有连接的silos(运行时)和所有指定的八卦频道(如果这些频道是持久的)中持续存在。 我们对注入新配置提出了一些限制，操作员必须遵守这些限制： 每个新配置都可以添加多个集群，或删除多个集群(但不能同时删除这两个集群)。 在仍在处理以前的配置更改时，操作员不应发布新配置。 这些限制确保诸如单实例协议之类的协议可以正确地维护激活的互斥，即使在配置更改的情况下也是如此。 经管粮 使用Orleans管理Grain，可以在任何集群中的任何节点上注入多集群配置。例如，要注入由三个集群{us1、eu1、us2}组成的多集群配置，我们可以向管理Grain传递一个可枚举的字符串： var clusterlist = \"us1,eu1,us2\".Split(','); var mgtGrain = client.GetGrain<IManagementGrain>(0); mgtGrain.InjectMultiClusterConfiguration(clusterlist, \"my comment here\")); 第一个论点 注入多群集配置 是群集ID的可枚举项，它将定义新的多群集配置。第二个参数是一个(可选)注释字符串，可用于用任意信息标记配置，例如谁注入了配置的原因。 有一个可选的第三个参数，一个名为 第一次检查 ，默认为true。这意味着系统将尽最大努力检查是否有任何silos尚未赶上当前配置，如果发现此类silos，则拒绝更改。这有助于检测违反限制的情况，即一次只能挂起一个配置更改(尽管在任何情况下都不能保证)。 通过默认配置 在预先知道多集群配置并且每次部署都是新的(例如为了测试)的情况下，我们可能希望提供默认配置。全局配置支持可选属性 默认多群集 它采用以逗号分隔的群集ID列表： var silo = new SiloHostBuilder() [...] .Configure<MultiClusterOptions>(options => { [...] options.DefaultMultiCluster = new[] { \"us1\", \"eu1\", \"us2\" }; [...] }) [...] 使用此设置启动silos后，它将检查当前多群集配置是否为空，如果为空，则将给定配置注入当前UTC时间戳。 警告。持久的多集群八卦频道(例如，基于azuretable)保留上次注入的配置，除非它们被显式删除。在这种情况下，指定DefaultMultiCluster在重新部署群集时不起作用，因为存储在八卦频道中的配置不为空。> 通过八卦频道 操作员还可以将配置直接注入八卦频道。频道中的变化会被周期性的背景八卦自动拾取和传播，尽管可能非常缓慢(使用管理Grain要快得多)。对传播时间的粗略估计是30秒(或全局配置中指定的任何八卦间隔)乘以所有集群中silos总数的二进制对数。但是，由于八卦对是随机选择的，所以它可以快得多，也可以慢得多。 如果使用基于azure表的八卦频道，运营商只需在 Orleans可行 ，例如，使用某些工具编辑azure表中的数据。配置记录的格式如下： 姓名 类型 价值 分区键 字符串 服务ID 行键 字符串 “配置” 集群 字符串 群集ID的逗号分隔列表，例如“us1、eu1、us2” 评论 字符串 可选注释 棉纱印花 日期时间 配置的UTC时间戳 注意 是啊。在存储器中编辑此记录时，gossipttimestamp也必须设置为比当前更新的值(否则将忽略更改)。最方便和推荐的方法是 删除gossipttimestamp字段 -然后，我们的gossip通道实现会自动将其替换为正确的当前时间戳(它使用azure表时间戳)。 群集添加/删除过程 从多集群中添加或删除集群通常需要在一些更大的上下文中进行协调。我们建议在从多群集添加/删除群集时始终遵循以下步骤。 添加群集的过程 启动一个新Orleans集群，等待所有silos都启动并运行。 插入包含新群集的配置。 开始将用户请求路由到新群集。 删除群集的过程 停止将新用户请求路由到群集。 插入不再包含群集的配置。 停止群集的所有silos。 以这种方式删除群集后，可以按照添加新群集的过程重新添加它。 非连接群集上的活动 在群集处于活动状态和未连接状态时，可能会有短暂的临时时间段： 新启动的集群可能在进入多集群配置之前(在添加集群的过程的步骤1和步骤2之间)开始执行代码。 正在停用的群集在关闭silos之前(在删除群集的过程的步骤2和步骤3之间)仍可以执行代码。 在这些中间情况下，可能出现以下情况： 对于全局单实例grains：grains可能在未连接的集群上具有重复激活。 对于已版本化的grains：当grains状态更改时，未连接群集上的激活不会收到通知。"
  },
  "Documentation/deployment/multi-cluster_support/GossipChannels.html": {
    "href": "Documentation/deployment/multi-cluster_support/GossipChannels.html",
    "title": "Multi-Cluster Communication | Microsoft Orleans 中文文档",
    "keywords": "多集群通信 网络的配置必须使任何Orleanssilos都可以通过TCP/IP连接到任何其他Orleanssilos，而不管它位于世界的哪个位置。具体如何实现这一点不在Orleans的范围内，因为这取决于silos的部署方式和地点。 例如，在windows azure上，我们可以使用vnets连接一个区域内的多个部署，并使用网关连接不同区域的vnets。 群集ID 每个群集都有自己唯一的群集ID。必须在全局配置中指定群集ID。 群集ID不能为空，也不能包含逗号。此外，如果使用azure表存储，则群集ID不能包含行键(/，\\，，？)所禁止的字符。是的。 我们建议对集群id使用非常短的字符串，因为集群id经常传输，并且可能由一些日志视图提供程序存储在存储器中。 群集网关 每个集群都会自动指定其活动silos的一个子集作为 群集网关 是的。群集网关直接向其他群集公布其IP地址，因此可以充当“第一联系人”。默认情况下，最多10个silos(或配置为 MaxMultiClusterGateways系列 )被指定为群集网关。 不同集群中的silos之间的通信 不 总是经过一个关口。一旦一个silos知道并缓存了一个Grains激活的位置(无论在哪个集群中)，它就直接向该silos发送消息，即使silos不是集群网关。 八卦 gossip是集群共享配置和状态信息的机制。顾名思义，八卦是分散的、双向的：每个silos直接与其他silos通信，无论是在同一个集群中还是在其他集群中，以便在两个方向上交换信息。 内容 是的。八卦包含以下部分或全部信息： 当前时间戳 多群集配置 是的。 包含有关群集网关信息的字典。密钥是silos地址，该值包含(1)时间戳，(2)群集ID和(3)状态，状态可以是活动的，也可以是非活动的。 快速和慢速传播 是的。当网关更改其状态，或当操作员注入新配置时，此八卦信息将立即发送到所有silos、集群和八卦频道。这种情况发生得很快，但并不可靠。如果消息由于任何原因(如竞争、套接字中断、silos故障)而丢失，我们定期的背景八卦会确保信息最终传播，尽管传播速度会更慢。所有信息最终都会在任何地方传播，并且对偶尔的消息丢失和失败具有很强的弹性。 所有八卦数据都有时间戳，这样可以确保更新的信息替换旧的信息，而不管消息的相对时间。例如，较新的多群集配置替换较旧的配置，而有关网关的较新信息替换有关该网关的较旧信息。有关八卦数据表示的更多详细信息，请参见 多簇数据 上课。它有一个 合并 方法，该方法结合八卦数据，使用时间戳解决冲突。 八卦频道 当silos首次启动或故障后重新启动时，它需要有一种方法 揭发流言蜚语 是的。这是 八卦频道 ，可以在 silos配置 是的。启动时，一个Silo从八卦频道获取所有信息。启动后，silos每隔30秒或任何配置为 背景消息间隔 是的。每次它与从所有群集网关和八卦频道中随机选择的伙伴同步八卦信息。 笔记： 虽然不是严格要求，但我们建议始终在不同的区域配置至少两个八卦频道，以获得更好的可用性。 与八卦频道沟通的延迟并不重要。 只要serviceid guid(由它们各自的配置指定)是不同的，多个不同的服务就可以使用相同的八卦频道而不受干扰。 没有严格要求所有silos使用相同的八卦频道，只要频道足够让silos在启动时最初与“八卦社区”连接。但是，如果八卦频道不是silos配置的一部分，并且silos是网关，则它不会将其状态更新推送到频道(快速传播)，因此在通过周期性背景八卦(慢速传播)到达频道之前，可能需要更长的时间。 基于azure表的八卦频道 我们已经实现了一个基于azure表的八卦频道。配置指定用于azure帐户的标准连接字符串。例如，一个配置可以使用单独的azure存储帐户指定两个八卦频道 美国 和 欧洲 具体如下： var silo = new SiloHostBuilder() [...] .Configure<MultiClusterOptions>(options => { [...] options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"); options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\") [...] }) [...] 多个不同的服务可以使用相同的八卦频道而不受干扰，只要它们各自配置指定的serviceid guid是不同的。 其他八卦频道实现 我们正在研究其他八卦频道提供商，类似于如何为许多不同的存储后端打包成员资格和提醒。"
  },
  "Documentation/deployment/multi-cluster_support/Overview.html": {
    "href": "Documentation/deployment/multi-cluster_support/Overview.html",
    "title": "多集群支持 | Microsoft Orleans 中文文档",
    "keywords": "多集群支持 Orleans V.1.3.0增加了对将多个Orleans集群联合到松散连接的 多簇 就像一个单一的服务。 多集群促进 地理分布 也就是说，在全世界的多个数据中心运行一个Orleans应用程序更加容易。此外，多集群可以在单个数据中心内运行，以获得更好的故障和性能隔离。 所有机制的设计都特别注意(1)最小化集群之间的通信，和(2)让每个集群独立运行，即使其他集群失败或无法访问。 配置和操作 下面我们将介绍如何配置和操作多集群。 沟通 是的。集群通过集群中使用的同一个silos到silos的连接进行通信。为了交换状态和配置信息，集群使用gossip机制和gossip通道实现。 silos配置 是的。需要配置silos，以便它们知道自己属于哪个集群(每个集群由一个唯一的字符串标识)。此外，每个silos都需要配置连接字符串，以允许它们连接到一个或多个 八卦频道 启动时。 多集群配置注入 . 在运行时，服务操作员可以指定和/或更改 多群集配置 ，其中包含群集ID的列表，以指定哪些群集是当前多群集的一部分。这是通过调用任何集群中的管理Grain来完成的。 多簇grains 下面我们将介绍如何在应用程序级别使用多集群功能。 全局单实例Grain . 开发人员可以指示集群应该在何时以及如何根据特定的grain类协调其grain目录。这个 [全球照明] 属性意味着我们需要与在单个全局集群中运行orleans时相同的行为：即将所有调用路由到一个单一的grain激活。相反地， [OneInstancePerCluster] 属性指示每个群集可以有自己的独立激活。如果集群之间的通信是不需要的，这是合适的。 原木视图grains (不在V.1.3.0中) . 一种特殊类型的Grain，使用与事件源类似的新api来同步或持久化Grain状态。它可以用来自动和有效地同步集群之间和存储grain的状态。因为它的同步算法可以安全地与Reentrant的grains一起使用，并且优化为使用批处理和复制，所以当一个grains在多个集群中频繁访问和/或当它被频繁写入存储器时，它可以比标准grains执行得更好。对日志视图Grain的支持还不是主分支的一部分。我们有一个预发行版，包括示例和一些文档 地理Orleans分行 . 它目前正由一个早期采用者在生产中进行评估。"
  },
  "Documentation/clusters_and_clients/configuration_guide/configuring_.NET_garbage_collection.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/configuring_.NET_garbage_collection.html",
    "title": "Configuring .NET Garbage Collection | Microsoft Orleans 中文文档",
    "keywords": "配置.NET垃圾回收 为了获得良好的性能，必须以正确的方式为silos进程配置.NET垃圾回收。我们找到的最佳设置组合是设置gcserver=true和gcconcurrent=true。这些很容易通过应用程序csproj文件设置。示例如下： .NET框架和.NET核心 // .csproj <PropertyGroup> <ServerGarbageCollection>true</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> 具有旧.csproj项目格式的.NET框架 // App.config <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> 但是，如果silos作为azure工作器角色的一部分运行(默认情况下配置为使用工作站gc)，这就不那么容易了。这篇博客文章展示了如何为azure工作者角色设置相同的配置- https://blogs.msdn.microsoft.com/cclayton/2014/06/05/server-garbage-collection-mode-in-microsoft-azure/ [啊！注意] server garbage collection is available only on multiprocessor computers 中。因此，即使您通过应用程序csproj文件或通过引用的博客文章上的脚本配置垃圾回收，如果silos运行在具有单个核心的(虚拟)计算机上，您也不会从 gcserver=真 是的。"
  },
  "Documentation/clusters_and_clients/configuration_guide/adonet_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/adonet_configuration.html",
    "title": "数据库配置 | Microsoft Orleans 中文文档",
    "keywords": "数据库配置 下面的段落包含链接SQL脚本，以配置您的数据库，以及相应的ADO.Net不变性，用于配置ADO.Net Providers in Orleans。这些脚本如果需要扩充，将被关闭。 聚类 数据库 脚本 Nuget包装 不变性 SQL服务器 SQLServer-Clustering.sql System.Data.SqlClient System.Data.SqlClient 玛丽亚 MySQL-Clustering.sql MySql.Data MySql.Data.MySqlClient 后格雷斯克尔 PostgreSQL-Clustering.sql 中华人民共和国 中华人民共和国 神谕 神谕集群 ODP.net oracle.dataaccess.client文件 持久化 数据库 脚本 NuGET包 ADO.NET不变量 SQL Server sqlserver-persistence.sql数据库 system.data.sqlclient系统 system.data.sqlclient系统 MySQL/马里亚行 mysql-persistence.sql文件 mysql.数据 MySql.Data.MySqlClient PostgreSQL PostgreSQL-持久化.sql NPGSQL NPGSQL 甲骨文 Oracle持久化.sql 网 oracle.dataaccess.client文件 提醒 数据库 脚本 NuGET包 ADO.NET不变量 SQL Server sqlserver-reminders.sql提示 system.data.sqlclient系统 system.data.sqlclient系统 MySQL/马里亚行 mysql-reminders.sql文件 MySQL数据 MySql.Data.MySqlClient PostgreSQL PostgreSQL提醒.sql NPGSQL NPGSQL 神谕。 Oracle提醒.sql 网 oracle.dataaccess.client文件"
  },
  "Documentation/clusters_and_clients/configuration_guide/server_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/server_configuration.html",
    "title": "Server Configuration | Microsoft Orleans 中文文档",
    "keywords": "[啊！注意!]如果要启动本地silos和本地客户端进行开发，请查看 本地开发配置页 服务器配置 silos通过编程方式配置 silohostbuilder软件 以及一些补充选项类。Orleans的选项类遵循 ASP.NET选项 模式，可以通过文件、环境变量等加载。 silos配置有几个关键方面： Orleans聚类信息 群集提供程序 用于silos到silos和客户端到silos通信的终结点 应用程序部件 这是一个silos配置的示例，它定义群集信息、使用azure群集并配置应用程序部分： var silo = new SiloHostBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"AspNetSampleApp\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Endpoints .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) // Application parts: just reference one of the grain implementations that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(ValueGrain).Assembly).WithReferences()) // Now create the silo! .Build(); 让我们分解此示例中使用的步骤： Orleans聚类信息 [...] // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"AspNetSampleApp\"; }) [...] 这里我们做两件事： 设置 棒状的 到 “我的第一个群集” ：这是Orleans集群的唯一ID。使用此ID的所有客户端和silos都可以直接相互通信。你可以选择使用不同的 棒状的 不过，对于不同的部署。 设置 服务ID 到 “aspnetsampleap” ：这是应用程序的唯一ID，某些提供程序(如持久化提供程序)将使用它。 此ID应保持稳定，并且在部署期间不会更改 是的。 群集提供程序 [...] // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) [...] 通常，在orleans上构建的服务部署在节点集群上，或者部署在专用硬件上，或者部署在azure中。为了进行开发和基本测试，可以在单节点配置中部署Orleans。当部署到一个节点集群时，orleans在内部实现了一组协议来发现和维护集群中orleans silo的成员关系，包括检测节点故障和自动重新配置。 为了可靠地管理集群成员关系，orleans使用azure表、sql server或apache zookeeper来同步节点。 在这个示例中，我们使用azure表作为成员资格提供程序。 端点 var silo = new SiloHostBuilder() [...] // Endpoints .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) [...] Orleanssilos有两种典型的端点配置： silos到silos端点，用于同一集群中silos之间的通信 客户端到silos端点(或网关)，用于在同一集群中的客户端和silos之间进行通信 在示例中，我们使用helper方法 .配置终结点(siloport:11111，gatewayport:30000) 它将用于silos到silos通信的端口设置为 11111个 和网关的端口 30000个 是的。此方法将检测要侦听的接口。 这种方法在大多数情况下应该足够了，但是如果需要的话，可以进一步自定义它。下面是如何将外部IP地址与某些端口转发一起使用的示例： [...] .Configure<EndpointOptions>(options => { // Port to use for Silo-to-Silo options.SiloPort = 11111; // Port to use for the gateway options.GatewayPort = 30000; // IP Address to advertise in the cluster options.AdvertisedIPAddress = IPAddress.Parse(\"172.16.0.42\"); // The socket used for silo-to-silo will bind to this endpoint options.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any, 40000); // The socket used by the gateway will bind to this endpoint options.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any, 50000); }) [...] 在内部，silos会监听 0.0.0.0:40000个 和 0.0.0.0:50000 ，但在成员资格提供程序中发布的值将是 172.16.0.42:11111 和 172.16.0.42:30000 是的。 应用程序部件 [...] // Application parts: just reference one of the grain implementations that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(ValueGrain).Assembly).WithReferences()) [...]; 虽然技术上不需要此步骤(如果未配置，Orleans将扫描当前文件夹中的所有程序集)，但鼓励开发人员对此进行配置。此步骤将帮助Orleans加载用户程序集和类型。这些组件称为应用程序部件。所有Grain、Grain接口和序列化器都是使用应用程序部件发现的。 应用程序部件的配置使用 IApplicationPartsManager应用程序部件管理器 ，可以使用 配置应用程序部件 上的扩展方法 IClientBuilder 和 IsiloHostBuilder 是的。这个 配置应用程序部件 方法接受委托， 操作<iapplicationpartmanager> 是的。 上的以下扩展方法 IApplicationPartManager 支持常见用途： addapplicationpart(程序集) 使用此扩展方法可以添加单个程序集。 AddFromAppdomain() 添加当前加载在 应用程序域 是的。 AddFromApplicationBaseDirectory() 加载并添加当前基路径中的所有程序集(请参见 appdomain.basedirectory目录 )中。 通过上述方法添加的程序集可以在其返回类型上使用以下扩展方法进行补充， 带程序集的IApplicationPartManager ： 引用() 从添加的零件添加所有引用的部件。这将立即加载任何可传递引用的程序集。忽略程序集加载错误。 使用代码生成() 为添加的部件生成支持代码并将其添加到部件管理器中。注意，这需要 Microsoft.Orleans.Orleanscodegenerator 要安装的包，通常称为运行时代码生成。 类型发现要求提供的应用程序部分包含特定属性。添加生成时代码生成包( Microsoft.Orleans.CodeGenerator.MSBuild 或 Microsoft.Orleans.OrleansCodeGenerator.Build )对于包含Grain、Grain接口或序列化程序的每个项目，建议使用确保这些属性存在的方法。生成生成时代码只支持C。对于F、Visual Basic和其他.NET语言，可以在配置期间通过 使用代码生成() 上述方法。有关代码生成的更多信息，请参见 相应部分 是的。"
  },
  "Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html",
    "title": "Configuring ADO.NET Providers | Microsoft Orleans 中文文档",
    "keywords": "配置ADO.NET提供程序 任何可靠的Orleans部署都需要使用持久存储来保持系统状态，特别是Orleans集群成员表和提醒。可用的选项之一是通过ADO.NET提供程序使用SQL数据库。 为了使用ado.net进行持久化、集群或提醒，需要将ado.net提供程序配置为silos配置的一部分，如果是集群，则还需要配置为客户端配置的一部分。 silos配置代码应如下所示： var siloHostBuilder = new SiloHostBuilder(); var invariant = \"System.Data.SqlClient\"; // for Microsoft SQL Server var connectionString = \"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; //use AdoNet for clustering siloHostBuilder.UseAdoNetClustering(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); //use AdoNet for reminder service siloHostBuilder.UseAdoNetReminderService(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); //use AdoNet for Persistence siloHostBuilder.AddAdoNetGrainStorage(\"GrainStorageForTest\", options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); 客户端配置代码应如下所示： var siloHostBuilder = new SiloHostBuilder(); var invariant = \"System.Data.SqlClient\"; var connectionString = \"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; //use AdoNet for clustering siloHostBuilder.UseAdoNetClustering(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); 其中 连接串 设置为有效的ADONET服务器连接字符串。 为了使用ado.net提供程序进行持久化、提醒或集群，有用于创建数据库工件的脚本，所有将托管Orleanssilos的服务器都需要访问这些脚本。缺乏对目标数据库的访问是我们看到的开发人员所犯的一个典型错误。 在ADONET扩展名NUGETS上安装或执行NUGET还原后，脚本将复制到项目目录或leansADONETcontent，其中每个受支持的ADO.NET扩展名都有自己的目录。我们将adonet nuget分为每个功能nuget： Microsoft.Orleans.Clustering.adonet 对于集群， Microsoft.Orleans.Persistence.adonet 为了坚持和 Microsoft.Orleans.Reminders.adonet 作为提醒。"
  },
  "Documentation/clusters_and_clients/configuration_guide/index.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/index.html",
    "title": "Orleans Configuration Guide | Microsoft Orleans 中文文档",
    "keywords": "Orleans配置指南 本配置指南解释了关键配置参数以及它们在大多数典型使用场景中的使用方式。 orleans可以用于各种适合不同使用场景的配置，例如用于开发和测试的本地单节点部署、服务器群集、多实例azure工作者角色等。 本指南提供了在目标场景中运行Orleans所需的关键配置参数的说明。还有一些其他的配置参数，主要有助于微调Orleans以获得更好的性能。 通过 silohostbuilder软件 和 客户端生成器 以及一些补充期权类别。Orleans的选项类遵循 ASP.NET选项 模式，可通过文件、环境变量等加载。请参阅 选项模式文档 更多信息。 如果要为本地开发配置silos和客户端，请查看 本地开发配置 页：1茶 服务器配置 和 客户端配置 导游盖部分配置谷仓和顾客，各自。 第二节 典型配置 提供一个少量共同配置的概要。 一份可配置的重要核心选项清单可在上面找到。 本节 页：1 重要的 确保你预先配置净垃圾邮件收藏 配置网收藏 页：1"
  },
  "Documentation/clusters_and_clients/configuration_guide/client_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/client_configuration.html",
    "title": "Client Configuration | Microsoft Orleans 中文文档",
    "keywords": "[啊！注意!]如果只想启动本地silos和本地客户端进行开发，请查看本地开发配置页。 客户端配置 连接到silos集群并向Grains发送请求的客户端是通过 客户端生成器 以及一些补充选项类。与思洛选项一样，客户端选项类遵循 ASP.NET选项 是的。 客户端配置有几个关键方面： Orleans聚类信息 群集提供程序 应用程序部件 客户端配置示例： var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); 让我们分解此示例中使用的步骤： Orleans聚类信息 [...] // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"orleans-docker\"; options.ServiceId = \"AspNetSampleApp\"; }) [...] 这里我们设定了两件事： 这个 棒状的 到 “我的第一个群集” ：这是Orleans集群的唯一ID。使用此ID的所有客户端和silos将能够直接相互通信。有些人会选择使用不同的 棒状的 例如，对于每个部署。 这个 服务ID 到 “aspnetsampleap” ：这是应用程序的唯一ID，某些提供程序(例如，持久化提供程序)将使用它。 此ID在部署期间应该是稳定的(而不是更改的) 是的。 群集提供程序 [...] // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) [...] 客户端将使用此提供程序发现群集中可用的所有网关。有几个提供程序可用，在此示例中，我们使用azure表提供程序。 要获得更多详细信息，请查看服务器配置页中的匹配部分。 应用程序部件 [...] // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)).WithReferences()) [...]; 要获得更多详细信息，请查看服务器配置页中的匹配部分。"
  },
  "Documentation/clusters_and_clients/configuration_guide/activation_garbage_collection.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/activation_garbage_collection.html",
    "title": "Activation Garbage Collection | Microsoft Orleans 中文文档",
    "keywords": "激活垃圾回收 如核心概念部分所述， grains活化 是一个grain类的内存实例，由orleans运行时根据需要自动创建，作为grain的临时物理实施例。 激活垃圾收集(activation gc)是从内存中删除未使用的grains激活的过程。它在概念上类似于.net中的内存垃圾收集工作方式。然而，激活gc只考虑特定grains激活空闲的时间。内存使用率不是一个因素。 激活gc的工作原理 激活gc的一般过程包括在silos中的orleans运行时定期扫描在配置的时间段(收集期限)内根本没有使用的Grains激活。一旦Grains激活闲置了那么长时间，它就会被停用。停用过程开始于运行时调用grain的 OnDeactivateAsync() 方法，并通过从silos的所有数据结构中移除对Grain Activation对象的引用来完成，以便.NET GC回收内存。 因此，在不给应用程序代码增加负担的情况下，只有最近使用的grains激活会保留在内存中，而不再使用的激活会被自动删除，它们使用的系统资源会被运行时回收。 对于Grains活化收集而言，什么算是“活跃” 接收方法调用 收到提醒 通过流接收事件 对于Grains活化收集而言，什么不算“活跃” 执行访问(对另一个Grains或对一个Orleans客户) 定时器事件 不涉及orleans框架的任意io操作或外部调用 收款年龄限制 在这段时间之后，闲置Grains的激活会受到激活GC的影响，这段时间称为收集期限限制。默认的收集期限为2小时，但可以全局更改，也可以针对单个Grains类更改。 显式控制激活垃圾回收 延迟激活gc Grains激活可以通过调用 this.delaydeactivation() 方法： protected void DelayDeactivation(TimeSpan timeSpan) 此调用将确保此激活至少在指定的持续时间内不被停用。它的优先级高于配置中指定的激活垃圾回收设置，但不会取消这些设置。因此，此调用为 将停用延迟到激活垃圾收集设置中指定的时间之外 是的。此调用不能用于加速激活垃圾收集。 积极的 时间跨度 值表示“在该时间段内阻止此激活的GC”。 否定的 时间跨度 值表示“取消 Task.Delay 调用并使此激活行为基于常规激活垃圾收集设置”。 情节： 1)激活垃圾收集设置指定10分钟的期限，Grains正在调用 Task.Delay(TimeSpan.FromMinutes(20)) ，它将导致至少20分钟内无法收集此激活。 2)激活垃圾收集设置指定10分钟的期限，Grains正在调用 Task.Delay(TimeSpan.FromMinutes(5)) ，如果没有额外访问，则激活将在10分钟后收集。 3)激活垃圾收集设置指定10分钟的期限，Grains正在调用 Task.Delay(TimeSpan.FromMinutes(5)) ，7分钟后，如果没有额外的调用，则会在17分钟后从时间0开始收集激活。 4)激活垃圾收集设置指定10分钟的期限，Grains正在调用 Task.Delay(TimeSpan.FromMinutes(20)) ，7分钟后，此Grains上还有另一个调用，如果没有额外的调用，则将在从时间0开始的20分钟后收集激活。 请注意 Task.Delay 无法100%保证在指定的时间段到期之前不会停用Grains激活。有些失效案例可能导致Grains过早失活。也就是说 Task.Delay 不能用作永久“固定”内存中的grains激活或固定到特定silos的方法 是的。 Task.Delay 这仅仅是一种优化机制，可以帮助降低Grains随着时间的推移被停用和重新激活的总成本，如果这很重要的话。在大多数情况下，不需要使用 Task.Delay 完全。 加速活化气相色谱 Grains激活还可以通过调用 这个。停用空闲() 方法： protected void DeactivateOnIdle() 如果此时不处理任何消息，则认为Grains激活处于空闲状态。如果你调用 停用空闲 当Grains正在处理消息时，一旦当前消息的处理完成，它将被停用。 如果有任何请求排队等待Grains，它们将被转发到下一个激活。 停用空闲 优先于配置或 Task.Delay 是的。请注意，此设置仅适用于调用它的grains激活，而不适用于此类型的其他grains激活。 配置 可以使用 GrainCollection选项 选项： mySiloHostBuilder.Configure<GrainCollectionOptions>(options => { // Set the value of CollectionAge to 10 minutes for all grain options.CollectionAge = TimeSpan.FromMinutes(10); // Override the value of CollectionAge to 5 minutes for MyGrainImplementation options.ClassSpecificCollectionAge[typeof(MyGrainImplementation).FullName] = TimeSpan.FromMinutes(5); })"
  },
  "Documentation/clusters_and_clients/configuration_guide/serialization.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/serialization.html",
    "title": "Serialization and Writing Custom Serializers | Microsoft Orleans 中文文档",
    "keywords": "序列化和编写自定义序列化程序 Orleans有一个高级和可扩展的序列化框架。orleans序列化在grain请求和响应消息以及grain持久状态对象中传递的数据类型。作为这个框架的一部分，orleans自动为这些数据类型生成序列化代码。除了为已可.NET序列化的类型生成更有效的序列化/反序列化之外，Orleans还尝试为不可.NET序列化的Grain接口中使用的类型生成序列化程序。该框架还包括一组用于常用类型(列表、字典、字符串、原语、数组等)的高效内置序列化程序。 Orleans的序列化程序有两个重要的特性，使它与许多其他第三方序列化框架不同：动态类型/任意多态性和对象标识。 动态类型与任意多态性 -orleans对可以在grain调用中传递的类型没有任何限制，并保持了实际数据类型的动态特性。例如，这意味着如果grain接口中的方法被声明为接受 词典 但在运行时发送者通过 分类词典 ，接收器确实会 分类词典 (尽管“static contract/grain”接口没有指定此行为)。 维护对象标识 -如果同一个对象在一个grain调用的参数中传递了多个类型，或者从参数中间接指向了多个类型，那么orleans将只序列化它一次。在接收端，orleans将正确地恢复所有引用，以便反序列化后指向同一对象的两个指针仍然指向同一对象。在如下场景中，对象标识是很重要的。假设actor a正在向actor b发送一个包含100个条目的字典，并且字典中的10个键指向a一侧的同一个对象obj。在不保留对象标识的情况下，b将收到一个包含100个条目的字典，其中10个键指向10个不同的obj克隆。在保留对象标识的情况下，B侧的字典与A侧的字典完全相同，10个键指向一个对象obj。 以上两个行为是由标准的.NET二进制序列化程序提供的，因此，支持这一标准以及Orleans常见的行为对我们来说也很重要。 生成的序列化程序 Orleans使用以下规则来决定要生成哪些序列化程序。规则是： 1)扫描所有引用Core Orleans库的程序集中的所有类型。 2)在这些程序集中：为直接在grain interfaces方法签名或状态类签名中引用的类型或任何标记为 [Serializable] 属性。 3)此外，grain接口或实现项目可以通过添加 [知识] 或 [知识装配] 程序集级属性，指示代码生成器为程序集中的特定类型或所有符合条件的类型生成序列化程序。 序列化提供程序 Orleans支持使用提供程序模型与第三方序列化程序集成。这需要实现 IExternalSerializer 在此文档的自定义序列化部分中描述的类型。一些常见序列化程序的集成与Orleans一起维护，例如： 协议缓冲区 以下内容： Orleans.Serialization.ProtobufSerializer 从 Microsoft.Orleans.OrleansGoogle实用程序 Nuget包。 债券 以下内容： orleans.serialization.bondsserializer 从 Microsoft.Orleans.Serialization.bond Nuget包。 newtonsoft.json又名json.net 以下内容： orleans.serialization.orleansjsson序列化程序 从Orleans核心图书馆。 自定义实现 IExternalSerializer 在下面的编写自定义序列化程序部分中进行了描述。 配置 确保序列化配置在所有客户端和silos上都是相同的，这一点很重要。如果配置不一致，则可能发生序列化错误。 序列化提供程序，它实现 IExternalSerializer ，可以使用 序列化提供程序 属性 客户端配置 和 全球配置 代码中： var cfg = new ClientConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); var cfg = new GlobalConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); 或者，可以在 <serializationproviders/> 属性 <信息> 以下内容： <Messaging> <SerializationProviders> <Provider type=\"GreatCompany.FantasticSerializer, GreatCompany.SerializerAssembly\"/> </SerializationProviders> </Messaging> 在这两种情况下，都可以配置多个提供程序。集合是有序的，这意味着如果可以序列化类型的提供程序 一个 和 乙 在只能序列化类型的提供程序之前指定 乙 ，则不会使用后一个提供程序。 编写自定义序列化程序 除了自动序列化生成之外，应用程序代码还可以为其选择的类型提供自定义序列化。Orleans建议对大多数应用程序类型使用自动序列化生成，只有在少数情况下，当您认为可以通过手动编写序列化程序来提高性能时，才编写自定义序列化程序。本说明描述了如何这样做，并确定了一些可能有用的特定情况。 应用程序可以通过三种方式自定义序列化： 向类型中添加序列化方法并用适当的属性标记它们( 复印机 ， 序列化方法 ， 反序列化方法 )中。对于应用程序拥有的类型(即可以向其添加新方法的类型)，此方法更可取。 实施 IExternalSerializer 并在配置期间注册它。此方法对于集成外部序列化库非常有用。 编写一个单独的静态类，用 [序列化程序(typeof(yourtype))] 其中包含3个序列化方法和与上面相同的属性。此方法对于应用程序不拥有的类型非常有用，例如，在应用程序无法控制的其他库中定义的类型。 以下各节详细介绍了每种方法。 介绍 Orleans序列化分为三个阶段：对象立即被深度复制以确保隔离；在连接之前；对象被序列化为消息字节流；当传递到目标激活时，对象从接收的字节流重新创建(反序列化)。可以在消息中发送的数据类型(即可以作为方法参数或返回值传递的类型)必须具有执行这三个步骤的关联例程。我们将这些例程统称为数据类型的序列化程序。 类型的复印机是独立的，而序列化器和反序列化器是一起工作的一对。您可以只提供一个自定义复印机，或者只提供一个自定义序列化器和一个自定义反序列化器，也可以提供这三个的自定义实现。 序列化程序在silos启动时以及加载程序集时为每个受支持的数据类型注册。对于要使用的类型，自定义序列化程序例程需要注册。序列化程序选择基于要复制或序列化的对象的动态类型。因此，不需要为抽象类或接口创建序列化程序，因为它们永远不会被使用。 何时考虑编写自定义序列化程序 手工编制的序列化程序例程很少会比生成的版本执行得更好。如果您想这样做，您应该首先考虑以下选项： 如果数据类型中有不需要序列化或复制的字段或属性，可以使用 非序列化 属性。这将导致生成的代码在复制和序列化时跳过这些字段。使用 不可变<t> & [不变] 尽可能避免复制不可变数据。关于 优化拷贝 详情见下文。如果要避免使用标准泛型集合类型，请不要使用。Orleans运行时包含泛型集合的自定义序列化程序，这些泛型集合使用集合的语义来优化复制、序列化和反序列化。这些集合在序列化字节流中还具有特殊的“缩写”表示形式，从而带来更大的性能优势。例如，一个 字典<string，string> 会比 list<tuple<string，string>> 是的。 自定义序列化程序可以提供显著性能提高的最常见情况是，数据类型中编码了重要的语义信息，而这些信息仅通过复制字段值是不可用的。例如，通过将数组视为索引/值对的集合，即使应用程序为了提高操作速度而将数据保持为完全实现的数组，填充较少的数组通常也可以更有效地序列化。 在编写自定义序列化程序之前，要做的一个关键事情是确保生成的序列化程序确实会损害您的性能。分析在这方面有点帮助，但更重要的是使用不同的序列化负载运行应用程序的端到端压力测试，以评估系统级别的影响，而不是序列化的微观影响。例如，构建一个不向grain方法传递参数或结果的测试版本，只需在两端使用固定值，就可以放大序列化和复制对系统性能的影响。 方法1:向类型添加序列化方法 所有序列化程序例程都应实现为它们所操作的类或结构的静态成员。这里显示的名称不是必需的；注册基于各个属性的存在，而不是方法名。请注意，序列化程序方法不必是公共的。 除非实现所有三个序列化例程，否则应使用 可串行化 属性，以便为您生成缺少的方法。 复印机 复印机方法用 Orleans复印机 属性： [CopierMethod] static private object Copy(object input, ICopyContext context) { ... } 复印机通常是最简单的序列化程序编写。它们接受一个对象，该对象的类型保证与复印机定义的类型相同，并且必须返回该对象在语义上等效的副本。 如果作为复制对象的一部分，需要复制子对象，则最好的方法是使用serializationmanager的deepcopyinner例程： var fooCopy = SerializationManager.DeepCopyInner(foo, context); 为了维护完整复制操作的对象标识上下文，使用deepcopyinner而不是deepcopy非常重要。 维护对象标识 复制例程的一个重要职责是维护对象标识。orleans运行时为此提供了一个helper类。在“手动”复制子对象(即，不是通过调用deepcopyiner)之前，请检查是否已按如下方式引用它： var fooCopy = context.CheckObjectWhileCopying(foo); if (fooCopy == null) { // Actually make a copy of foo context.RecordObject(foo, fooCopy); } 最后一行，打给 记录对象 是必需的，以便将来可以通过 检查对象选择 是啊。 请注意，这只应针对类实例，而不是结构实例或.NET原语(字符串、uri、枚举)。 如果你使用 深复制内部 若要复制子对象，则会为您处理对象标识。 序列化程序 序列化方法标记为 序列化方法 属性： [SerializerMethod] static private void Serialize(object input, ISerializationContext context, Type expected) { ... } 与copiers一样，传递给序列化程序的“input”对象保证是定义类型的实例。可以忽略“预期”类型；它基于有关数据项的编译时类型信息，并在较高级别上用于在字节流中形成类型前缀。 若要序列化子对象，请使用 序列化管理器 的 序列化内部 例行程序： SerializationManager.SerializeInner(foo, context, typeof(FooType)); 如果foo没有特定的预期类型，那么可以为预期类型传递null。 这个 二进制令牌流编写器 类提供了多种将数据写入字节流的方法。类的实例可以通过 上下文.streamwriter 属性。有关文档，请参见类。 反序列化程序 反序列化方法标记为 反序列化方法 属性： [DeserializerMethod] static private object Deserialize(Type expected, IDeserializationContext context) { ... } 可以忽略“预期”类型；它基于有关数据项的编译时类型信息，并在较高级别上用于在字节流中形成类型前缀。要创建的对象的实际类型将始终是定义反序列化程序的类的类型。 若要反序列化子对象，请使用 序列化管理器 的 反序列化内部 例行程序： var foo = SerializationManager.DeserializeInner(typeof(FooType), context); 或者： var foo = SerializationManager.DeserializeInner<FooType>(context); 如果foo没有特定的预期类型，请使用非泛型 反序列化内部 变型并通过 无效的 对于所需的类型。 这个 二进制令牌流读取器 类提供了从字节流读取数据的各种方法。类的实例可以通过 上下文.streamreader 属性。有关文档，请参见类。 方法2:编写序列化程序提供程序 在这个方法中，您可以实现 Orleans.serialization.iexternalserializer 并将其添加到 序列化提供程序 两者的属性 客户端配置 在客户和 全球配置 在silos里。配置在上面的序列化提供程序部分有详细说明。 实施 IExternalSerializer 遵循以下为序列化方法描述的模式 方法1 上面添加了 初始化 方法和 发布支持类型 Orleans用来确定序列化程序是否支持给定类型的方法。这是接口定义： public interface IExternalSerializer { /// <summary> /// Initializes the external serializer. Called once when the serialization manager creates /// an instance of this type /// </summary> void Initialize(Logger logger); /// <summary> /// Informs the serialization manager whether this serializer supports the type for serialization. /// </summary> /// <param name=\"itemType\">The type of the item to be serialized</param> /// <returns>A value indicating whether the item can be serialized.</returns> bool IsSupportedType(Type itemType); /// <summary> /// Tries to create a copy of source. /// </summary> /// <param name=\"source\">The item to create a copy of</param> /// <param name=\"context\">The context in which the object is being copied.</param> /// <returns>The copy</returns> object DeepCopy(object source, ICopyContext context); /// <summary> /// Tries to serialize an item. /// </summary> /// <param name=\"item\">The instance of the object being serialized</param> /// <param name=\"context\">The context in which the object is being serialized.</param> /// <param name=\"expectedType\">The type that the deserializer will expect</param> void Serialize(object item, ISerializationContext context, Type expectedType); /// <summary> /// Tries to deserialize an item. /// </summary> /// <param name=\"context\">The context in which the object is being deserialized.</param> /// <param name=\"expectedType\">The type that should be deserialized</param> /// <returns>The deserialized object</returns> object Deserialize(Type expectedType, IDeserializationContext context); } 方法3:为单个类型编写序列化程序 在这个方法中，您可以编写一个新的类，并用一个属性进行注释 [序列化属性(typeof(targettype))] ，其中 目标类型 正在序列化的类型，并实现3个序列化例程。如何编写这些例程的规则与方法1相同。Orleans使用 [序列化属性(typeof(targettype))] 确定该类是 目标类型 如果这个属性能够序列化多个类型，那么可以在同一个类上多次指定它。下面是这样一个类的示例： public class User { public User BestFriend { get; set; } public string NickName { get; set; } public int FavoriteNumber { get; set; } public DateTimeOffset BirthDate { get; set; } } [Orleans.CodeGeneration.SerializerAttribute(typeof(User))] internal class UserSerializer { [CopierMethod] public static object DeepCopier(object original, ICopyContext context) { var input = (User) original; var result = new User(); // Record 'result' as a copy of 'input'. Doing this immediately after construction allows for // data structures which have cyclic references or duplicate references. // For example, imagine that 'input.BestFriend' is set to 'input'. In that case, failing to record // the copy before trying to copy the 'BestFriend' field would result in infinite recursion. context.RecordCopy(original, result); // Deep-copy each of the fields. result.BestFriend = (User)context.SerializationManager.DeepCopy(input.BestFriend); result.NickName = input.NickName; // strings in .NET are immutable, so they can be shallow-copied. result.FavoriteNumber = input.FavoriteNumber; // ints are primitive value types, so they can be shallow-copied. result.BirthDate = (DateTimeOffset)context.SerializationManager.DeepCopy(input.BirthDate); return result; } [SerializerMethod] public static void Serializer(object untypedInput, ISerializationContext context, Type expected) { var input = (User) untypedInput; // Serialize each field. SerializationManager.SerializeInner(input.BestFriend, context); SerializationManager.SerializeInner(input.NickName, context); SerializationManager.SerializeInner(input.FavoriteNumber, context); SerializationManager.SerializeInner(input.BirthDate, context); } [DeserializerMethod] public static object Deserializer(Type expected, IDeserializationContext context) { var result = new User(); // Record 'result' immediately after constructing it. As with with the deep copier, this // allows for cyclic references and de-duplication. context.RecordObject(result); // Deserialize each field in the order that they were serialized. result.BestFriend = SerializationManager.DeserializeInner<User>(context); result.NickName = SerializationManager.DeserializeInner<string>(context); result.FavoriteNumber = SerializationManager.DeserializeInner<int>(context); result.BirthDate = SerializationManager.DeserializeInner<DateTimeOffset>(context); return result; } } 序列化泛型类型 这个 目标类型 参数 [序列化程序(typeof(targettype))] 可以是开放泛型类型，例如， MyGenericType<> 是的。在这种情况下，序列化程序类必须具有与目标类型相同的泛型参数。Orleans将在运行时为每个具体对象创建序列化程序的具体版本 MyGenericType<T> 序列化的类型，例如，每个 MyGenericType<int> 和 MyGenericType<string> 是的。 编写序列化程序和反序列化程序的提示 通常，编写序列化器/反序列化器对的最简单方法是通过构造字节数组并将数组长度写入流，然后是数组本身，然后通过反转过程进行反序列化。如果数组是固定长度的，则可以从流中忽略它。如果数据类型可以简洁地表示，并且没有可能重复的子对象(因此不必担心对象标识)，那么这种方法很好地工作。 另一种方法，即Orleans运行时对字典等集合所采用的方法，适用于具有重要而复杂的内部结构的类：使用实例方法访问对象的语义内容，序列化该内容，并通过设置语义内容而不是复杂的内部内容反序列化。国家。在这种方法中，使用serializeinner编写内部对象，使用deserializeinner读取内部对象。在这种情况下，编写自定义复印机也很常见。 如果您编写一个自定义序列化程序，并且它最终看起来像类中每个字段的序列化内部调用序列，则不需要该类的自定义序列化程序。 回退序列化 Orleans支持在运行时传输任意类型，因此内置代码生成器无法确定将提前传输的整个类型集。此外，某些类型不能为其生成序列化程序，因为它们不可访问(例如， 私有的 )或者有不可访问的字段(例如， 只读 )中。因此，需要对意外或无法提前生成序列化程序的类型进行及时序列化。负责这些类型的序列化程序称为 回退序列化程序 是的。Orleans提供了两个回退序列化程序： Orleans.Serialization.BinaryFormatterSerializer 使用.net的 二进制格式 ；和 Orleans.Serialization.ILBasedSerializer 发出 CIL 在运行时创建序列化程序的指令，该序列化程序利用Orleans的序列化框架对每个字段进行序列化。这意味着如果一个不可访问的类型 我的私掠型 包含字段 我的类型 它有一个自定义序列化程序，该自定义序列化程序将用于序列化它。 可以使用 FallbackSerializationProvider 两者的属性 客户端配置 在客户和 全球配置 在silos里。 var cfg = new ClientConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); var cfg = new GlobalConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); 或者，可以在XML配置中指定回退序列化提供程序： <Messaging> <FallbackSerializationProvider type=\"GreatCompany.FantasticFallbackSerializer, GreatCompany.SerializerAssembly\"/> </Messaging> 二进制格式序列化程序 是默认的回退序列化程序。 异常序列化 使用 回退序列化程序 是的。使用默认配置， 二进制格式序列化程序 是回退序列化程序，因此 ISerializable模式 必须紧跟其后才能确保异常类型中所有属性的正确序列化。 以下是具有正确实现的序列化的异常类型的示例： [Serializable] public class MyCustomException : Exception { public string MyProperty { get; } public MyCustomException(string myProperty, string message) : base(message) { this.MyProperty = myProperty; } public MyCustomException(string transactionId, string message, Exception innerException) : base(message, innerException) { this.MyProperty = transactionId; } // Note: This is the constructor called by BinaryFormatter during deserialization public MyCustomException(SerializationInfo info, StreamingContext context) : base(info, context) { this.MyProperty = info.GetString(nameof(this.MyProperty)); } // Note: This method is called by BinaryFormatter during serialization public override void GetObjectData(SerializationInfo info, StreamingContext context) { base.GetObjectData(info, context); info.AddValue(nameof(this.MyProperty), this.MyProperty); } } 使用不可变类型优化复制 Orleans有一个特性，可以用来避免一些与序列化包含不可变类型的消息相关的开销。本节从上下文开始介绍特性及其应用程序。 Orleans的序列化 当一个grain方法被调用时，orleans运行时会对方法参数进行一个深度拷贝，并从拷贝中形成请求。这可以防止调用代码在数据传递给被调用的Grain之前修改参数对象。 如果被调用的Grain在不同的silos上，那么拷贝最终被序列化为字节流，并通过网络发送到目标silos，在那里它们被反序列化为对象。如果被调用的grain位于同一个silos上，那么副本将直接传递给被调用的方法。 返回值的处理方式相同：首先复制，然后可能序列化和反序列化。 请注意，所有3个进程(复制、序列化和反序列化)都尊重对象标识。换言之，如果您传递一个列表，其中包含两个相同的对象，那么在接收端，您将得到一个列表，其中包含两个相同的对象，而不是包含两个具有相同值的对象。 优化拷贝 在许多情况下，深度复制是不必要的。例如，一个可能的场景是一个web前端，它从客户端接收一个字节数组，并将该请求(包括字节数组)传递到一个grain进行处理。前端进程一旦将数组传递给grain，就不会对它做任何事情；特别是，它不会重用数组来接收将来的请求。在Grains内部，字节数组被解析以获取输入数据，但未被修改。grain返回它创建的另一个字节数组，并将其传递回web客户端；一旦返回该数组，它将立即丢弃该数组。web前端将结果字节数组传递回其客户端，而无需修改。 在这种情况下，不需要复制请求或响应字节数组。不幸的是，orleans运行时无法自己解决这个问题，因为它无法判断数组是由web前端修改的还是由grain修改的。在最好的情况下，我们会有某种.NET机制来指示某个值不再被修改；如果没有这种机制，我们会为此添加特定于Orleans的机制： 不可变<t> 包装类和 [不变] 属性。 使用 不可变<t> 这个 Orleans.Concurrency.Immutable<T> wrapper类用于指示一个值可能被认为是不可变的；也就是说，底层值不会被修改，因此安全共享不需要复制。注意使用 不可变<t> 意味着无论是价值的提供者还是价值的接受者都不会在未来对其进行修改；它不是单方面的承诺，而是相互的双边承诺。 使用 不可变<t> 很简单：在grain接口中，而不是传递 T型 ，通过 不可变<t> 是的。例如，在上述场景中，grain方法是： Task<byte[]> ProcessRequest(byte[] request); 变成： Task<Immutable<byte[]>> ProcessRequest(Immutable<byte[]> request); 创建 不可变<t> ，只需使用构造函数： Immutable<byte[]> immutable = new Immutable<byte[]>(buffer); 若要获取不可变的内部值，请使用 .价值 属性： byte[] buffer = immutable.Value; 使用 [不变] 对于用户定义的类型， [Orleans.并发性.不可变] 属性可以添加到类型。这指示Orleans的序列化程序避免复制此类型的实例。下面的代码片段演示如何使用 [不变] 表示不可变类型。在传输过程中不会复制此类型。 [Immutable] public class MyImmutableType { public MyImmutableType(int value) { this.MyValue = value; } public int MyValue { get; } } Orleans的不变性 对于orleans来说，不变性是一个相当严格的声明：数据项的内容不会以任何可能改变其语义的方式进行修改，也不会干扰另一个线程同时访问该项。确保这一点的最安全方法是根本不修改项：按位不变，而不是逻辑不变。 在某些情况下，将其放宽到逻辑不变性是安全的，但是必须注意确保变异代码是正确的线程安全的；因为处理多线程是复杂的，并且在Orleans上下文中是不常见的，所以我们强烈建议不要使用这种方法，并建议坚持按位不变性。 序列化最佳实践 序列化在Orleans有两个主要目的： 作为在运行时在Grains和客户端之间传输数据的有线格式。 作为一种存储格式，用于保存长期数据以供以后检索。 Orleans产生的串行器由于其灵活性、性能和通用性而适合于第一目的。它们不太适合用于第二个目的，因为它们没有显式的版本容忍。建议用户配置一个版本容忍序列化程序，如 协议缓冲区 对于持久数据。协议缓冲区通过 Orleans.Serialization.ProtobufSerializer 从 Microsoft.Orleans.OrleansGoogle实用程序 Nuget包。应使用所选特定序列化程序的最佳实践，以确保版本公差。可以使用 序列化提供程序 如上所述的配置属性。"
  },
  "Documentation/clusters_and_clients/configuration_guide/typical_configurations.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/typical_configurations.html",
    "title": "Typical Configurations | Microsoft Orleans 中文文档",
    "keywords": "典型配置 下面是可用于开发和生产部署的典型配置示例。 地方发展 见 本地开发配置 使用azure的可靠生产部署 要使用azure进行可靠的生产部署，需要使用azure表选项作为群集成员身份。此配置是部署到本地服务器、容器或azure虚拟机实例的典型配置。 数据连接字符串的格式为 “DefaultEndpointsProtocol=https；帐户名=<azure存储帐户>；帐户密钥=<azure表存储帐户密钥>” silos配置： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAzureStorageClustering(options => options.ConnectionString = connectionString) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); 客户端配置： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var client = new ClientBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAzureStorageClustering(options => options.ConnectionString = connectionString) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); 使用SQL Server进行可靠的生产部署 为了使用SQL Server进行可靠的生产部署，需要提供SQL Server连接字符串。 silos配置： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAdoNetClustering(options => { options.ConnectionString = connectionString; options.Invariant = \"System.Data.SqlClient\"; }) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); 客户端配置： // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var client = new ClientBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAdoNetClustering(options => { options.ConnectionString = connectionString; options.Invariant = \"System.Data.SqlClient\"; }) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); 在专用服务器群集上部署不可靠 对于在不考虑可靠性的情况下在专用服务器集群上进行测试，可以利用MembershipTableGrain并避免对azure表的依赖。您只需要将其中一个节点指定为主节点。 在silos上： var primarySiloEndpoint = new IPEndpoint(PRIMARY_SILO_IP_ADDRESS, 11111); var silo = new SiloHostBuilder() .UseDevelopmentClustering(primarySiloEndpoint) .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(logging => logging.AddConsole()) .Build(); 对客户： var gateways = new IPEndPoint[] { new IPEndPoint(PRIMARY_SILO_IP_ADDRESS, 30000), new IPEndPoint(OTHER_SILO__IP_ADDRESS_1, 30000), [...] new IPEndPoint(OTHER_SILO__IP_ADDRESS_N, 30000), }; var client = new ClientBuilder() .UseStaticClustering(gateways) .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"AdventureApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build();"
  },
  "Documentation/clusters_and_clients/index.html": {
    "href": "Documentation/clusters_and_clients/index.html",
    "title": "What is a grain client | Microsoft Orleans 中文文档",
    "keywords": "什么是Grains客户？ 术语“客户端”或有时“Grains客户端”用于与Grains交互的应用程序代码，但它本身不是Grains逻辑的一部分。客户端代码在Orleans服务器集群(称为silos)之外运行，这些服务器集群承载Grains。因此，客户端充当到集群和应用程序所有Grain的连接器或管道。 通常，在前端web服务器上使用客户端连接到作为中间层的orleans集群，其中grains执行业务逻辑。在典型设置中，前端Web服务器： 接收Web请求 执行必要的身份验证和授权验证 决定应处理请求的Grains 使用Grain客户端对Grain进行一个或多个方法调用 处理grain调用和任何返回值的成功完成或失败 发送对Web请求的响应 Grains客户端初始化 在使用grain客户端调用orleans集群中托管的grain之前，需要对其进行配置、初始化并连接到集群。 配置通过 客户端生成器 以及许多补充选项类，其中包含用于以编程方式配置客户端的配置属性层次结构。 更多信息可以在 客户端配置指南 是的。 客户端配置示例： var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); 最后，我们需要调用 Connect() 方法，使其连接到Orleans群集。它是一个异步方法，返回 Task 是的。所以我们需要等待它的完成await或 .等等() 是的。 await client.Connect(); 调用给Grains 从客户那里调用给grain和 在grain代码中进行这样的调用 是的。相同的 getgrain<t>(key) 方法，其中 T 是目标grains接口，在两种情况下都使用 获取Grains引用 是的。细微的区别在于我们调用的工厂对象 获取grains 是的。在客户端代码中，我们通过连接的客户端对象来实现这一点。 IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Task t = player.JoinGame(game) await t; 对grain方法的调用返回 Task 或者 Task<t> 根据 grains接口规则 是的。客户可以使用await关键字异步等待返回的 Task 没有阻塞线程，或者在某些情况下 等待() 方法来阻止当前执行线程。 从客户端代码和从另一个Grain内部调用grains的主要区别在于grains的单线程执行模型。Grains被orleans运行时限制为单线程，而客户端可能是多线程的。Orleans没有在客户端提供任何这样的保证，因此客户端需要使用适合其环境的任何同步构造来管理自己的并发性—锁、事件， Task 等等。 接收通知 在某些情况下，简单的请求-响应模式是不够的，客户端需要接收异步通知。例如，当某个用户发布了她正在跟踪的新消息时，该用户可能希望收到通知。 观察者 是一种这样的机制，它允许将客户端对象公开为类似于grains的目标，以供grains调用。对观察者的访问并没有提供任何成功或失败的迹象，因为它们是作为单向尽力信息发送的。因此，应用程序代码有责任在必要时在观察者之上构建更高级别的可靠性机制。 另一种可用于向客户端传递异步消息的机制是 Streams 是的。流暴露了单个消息传递成功或失败的迹象，因此能够与客户端进行可靠的通信。 例子 这是上面给出的一个客户端应用程序的扩展版本，该客户端应用程序连接到Orleans，查找玩家帐户，向观察家订阅玩家参与的游戏会话的更新，并打印出通知，直到程序手动终止。 namespace PlayerWatcher { class Program { /// <summary> /// Simulates a companion application that connects to the game /// that a particular player is currently part of, and subscribes /// to receive live notifications about its progress. /// </summary> static void Main(string[] args) { RunWatcher().Wait(); // Block main thread so that the process doesn't exit. // Updates arrive on thread pool threads. Console.ReadLine(); } static async Task RunWatcher() { try { var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); // Hardcoded player ID Guid playerId = new Guid(\"{2349992C-860A-4EDA-9590-000000000006}\"); IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); IGameGrain game = null; while (game == null) { Console.WriteLine(\"Getting current game for player {0}...\", playerId); try { game = await player.GetCurrentGame(); if (game == null) // Wait until the player joins a game { await Task.Delay(5000); } } catch (Exception exc) { Console.WriteLine(\"Exception: \", exc.GetBaseException()); } } Console.WriteLine(\"Subscribing to updates for game {0}...\", game.GetPrimaryKey()); // Subscribe for updates var watcher = new GameObserver(); await game.SubscribeForGameUpdates( await client.CreateObjectReference<IGameObserver>(watcher)); Console.WriteLine(\"Subscribed successfully. Press <Enter> to stop.\"); } catch (Exception exc) { Console.WriteLine(\"Unexpected Error: {0}\", exc.GetBaseException()); } } } /// <summary> /// Observer class that implements the observer interface. Need to pass a grain reference to an instance of this class to subscribe for updates. /// </summary> class GameObserver : IGameObserver { // Receive updates public void UpdateGameScore(string score) { Console.WriteLine(\"New game score: {0}\", score); } } } }"
  },
  "Documentation/resources/Migration/MigrationAzure2.0.html": {
    "href": "Documentation/resources/Migration/MigrationAzure2.0.html",
    "title": "Migration from Orleans 1.5 to 2.0 when using Azure | Microsoft Orleans 中文文档",
    "keywords": "使用Azure从Orleans 1.5迁移到2.0 在Orleans2.0中，silos和客户端的配置已更改。在Orleans1.5中，我们曾经有一个用于处理所有配置项的整体对象，而且提供程序也已添加到该配置对象中。在Orleans2.0中，配置过程围绕 SiloHostBuilder ，类似于在ASP.NET Core中使用 WebHostBuilder 。 在Orleans1.5中，Azure的配置如下所示： var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); 的 AzureSilo 类公开了一个名为DefaultConfiguration()的静态方法，该方法用于加载配置XML文件。不建议使用这种配置silos的方式，但仍通过 旧版支持包 。 在Orleans2.0中，配置完全是编程的。新的配置API如下所示： //Load the different settings from the services configuration var proxyPort = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints[\"OrleansProxyEndpoint\"].IPEndpoint.Port; var siloEndpoint = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints[\"OrleansSiloEndpoint\"].IPEndpoint; var connectionString = RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\"); var deploymentId = RoleEnvironment.DeploymentId; var builder = new SiloHostBuilder() //Set service ID and cluster ID .Configure<ClusterOptions>(options => { options.ClusterId = deploymentId; options.ServiceIs = \"my-app\"; }) // Set silo name .Configure<SiloOptions>(options => options.SiloName = this.Name) //Then, we can configure the different endpoints .ConfigureEndpoints(siloEndpoint.Address, siloEndpoint.Port, proxyPort) //Then, we set the connection string for the storage .UseAzureStorageClustering(options => options.ConnectionString = connectionString) //If reminders are needed, add the service, the connection string is required .UseAzureTableReminderService(connectionString) //If Queues are needed, add the service, set the name and the Adapter, the one shown here //is the one provided with Orleans, but it can be a custom one .AddAzureQueueStreams<AzureQueueDataAdapterV2>(\"StreamProvider\", configurator => configurator.Configure(configure => { configure.ConnectionString = connectionString; })) //If Grain Storage is needed, add the service and set the name .AddAzureTableGrainStorage(\"AzureTableStore\"); AzureSilo到ISiloHost 在Orleans1.5， AzureSilo 类是在Azure Worker角色中托管silos的推荐方法。仍然可以通过 Microsoft.Orleans.Hosting.AzureCloudServices NuGet包 。 public class WorkerRole : RoleEntryPoint { AzureSilo silo; public override bool OnStart() { // Do other silo initialization – for example: Azure diagnostics, etc return base.OnStart(); } public override void OnStop() { silo.Stop(); base.OnStop(); } public override void Run() { var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); // Configure storage providers silo = new AzureSilo(); bool ok = silo.Start(config); silo.Run(); // Call will block until silo is shutdown } } Orleans2.0提供了更灵活的模块化API，用于通过以下方式配置和托管silos SiloHostBuilder 和 ISiloHost 。 public class WorkerRole : RoleEntryPoint { private ISiloHost host; private ISiloHostBuilder builder; private readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(); private readonly ManualResetEvent runCompleteEvent = new ManualResetEvent(false); public override void Run() { try { this.RunAsync(this.cancellationTokenSource.Token).Wait(); runCompleteEvent.WaitOne(); } finally { this.runCompleteEvent.Set(); } } public override bool OnStart() { //builder is the SiloHostBuilder from the first section // Build silo host, so that any errors will restart the role instance this.host = this.builder.Build(); return base.OnStart(); } public override void OnStop() { this.cancellationTokenSource.Cancel(); this.runCompleteEvent.WaitOne(); this.host.StopAsync().Wait(); base.OnStop(); } private Task RunAsync(CancellationToken cancellationToken) { return this.host.StartAsync(cancellationToken); } }"
  },
  "Documentation/resources/Migration/Migration1.5.html": {
    "href": "Documentation/resources/Migration/Migration1.5.html",
    "title": "Migration from Orleans 1.5 to 2.0 | Microsoft Orleans 中文文档",
    "keywords": "从Orleans迁移到0.5 Orleans的大部分API在2.0中保持不变，或者这些API的实现留在遗留类中以实现向后兼容性。同时，新引入的api提供了一些新的功能或更好的方法来完成这些任务。当涉及到.NETSDK工具和VisualStudio支持时，还有更细微的区别，这有助于我们意识到这一点。本文档为将应用程序代码从迁移到Orleans 2.0提供了指导。 Visual Studio和工具要求 Orleans2.0.0建立在.NET标准2.0之上。因此，您需要升级开发工具，以确保您获得愉快的开发体验。我们建议使用Visual Studio 2017或更高版本来开发Orleans 2.0.0应用程序。根据我们的经验，15.5.2及更高版本的效果最好。NET Standard 2.0.0与.NET 4.6.1及更高版本、.NET Core 2.0和其他框架列表兼容。Orleans2.0.0继承了这种兼容性。有关与其他.NET标准的兼容性信息，请参阅.NET .NET标准文档 ：如果您正在使用Orleans开发.NET Core或.NET应用程序，则需要按照某些步骤来设置环境，例如安装.NET Core SDK。更多信息，请参考 文档 . 配置代码的可用选项 群众或部队的集合 配置和启动silos(使用新的SiloBuilder API和旧的ClusterConfiguration对象) Orleans 2.0中有许多新的选项类，它们为配置silos提供了一种新的方法。为了便于迁移到新的API，有一个可选的向后兼容包， Microsoft.Orleans.Runtime.遗产 ，它提供了从旧的1.x配置API到新的配置API的桥。 如果你加上 Microsoft.Orleans.Runtime.遗产 包，silos仍然可以通过传统的 群集配置 对象，然后可以传递给 SiloHostBuilder 建造和启动silos。 您仍然需要通过 配置应用程序部件 调用。 以下是如何以传统方式配置本地silos的示例： public class Program { public static async Task Main(string[] args) { try { var host = await StartSilo(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); await host.StopAsync(); return 0; } catch (Exception ex) { Console.WriteLine(ex); return 1; } } private static async Task<ISiloHost> StartSilo() { // define the cluster configuration (temporarily required in the beta version, // will not be required by the final release) var config = ClusterConfiguration.LocalhostPrimarySilo(); // add providers to the legacy configuration object. config.AddMemoryStorageProvider(); var builder = new SiloHostBuilder() .UseConfiguration(config) // Add assemblies to scan for grains and serializers. // For more info read the Application Parts section .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly) .WithReferences()) // Configure logging with any logging framework that supports Microsoft.Extensions.Logging. // In this particular case it logs using the Microsoft.Extensions.Logging.Console package. .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } 配置和连接客户端(使用新的ClientBuilder API和旧的ClientConfiguration对象) orleans2.0中有许多新的选项类，它们为配置客户端提供了一种新的方法。为了便于迁移到新的API，有一个可选的向后兼容包， Microsoft.Orleans.Core.遗产 ，它提供了从旧的1.x配置API到新的配置API的桥。 如果你添加了 Microsoft.Orleans.Core.遗产 包，客户端仍然可以通过旧版本以编程方式配置 客户端配置 对象，然后可以传递给 客户端生成器 来构建和连接客户端。 您仍然需要通过 配置应用程序部件 调用。 下面是一个示例，说明客户端如何使用传统配置连接到本地silos： // define the client configuration (temporarily required in the beta version, // will not be required by the final release) var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder() .UseConfiguration(config) // Add assemblies to scan for grains interfaces and serializers. // For more info read the Application Parts section .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IHello).Assembly)) .ConfigureLogging(logging => logging.AddConsole()) var client = builder.Build(); await client.Connect(); 登录中 Orleans 2.0使用与ASP.NET核心2.0。您可以在中找到大多数Orleans日志记录功能的替代品ASP.NET岩芯测井。Orleans特定的日志记录功能，例如 ILogConsumer 和消息膨胀，仍然保持在 Microsoft.Orleans.Logging.遗产 包，这样你仍然可以选择使用它们。但是如何在2.0中使用Orleans配置日志记录发生了变化。让我来给你介绍一下迁移的过程。 在1.5中，日志配置是通过 客户端配置 和 节点配置 . 您可以配置 默认跟踪级别 , 跟踪文件名 , 跟踪模式 , TraceLevelOverrides , 跟踪控制台 , 批量消息限制 , 木材消费者 等等。在2.0中，日志记录配置与ASP.NETcore2.0日志记录，这意味着大部分配置都是通过 Microsoft.Extensions.Logging.ILoggingBuilder . 配置 默认跟踪级别 和 TraceLevelOverrides ，你需要申请 日志过滤 到 ILoggingBuilder . 例如，要在orleans运行时中将跟踪级别设置为“Debug”，可以使用下面的示例， siloBuilder.AddLogging(builder=>builder.AddFilter(\"Orleans\", LogLevel.Debug)); 您可以用同样的方法为应用程序代码配置日志级别。如果要将默认的最小跟踪级别设置为调试，请使用下面的示例 siloBuilder.AddLogging(builder=>builder.SetMinimumLevel(LogLevel.Debug); 有关日志筛选的详细信息，请参阅 https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging ; 将TraceToConsole配置为 是的 ，需要参考 Microsoft.Extensions.Logging.控制台 打包后使用 添加控制台() 扩展方法 ILoggingBuilder . 同样的 跟踪文件名 和 跟踪模式 ，如果要将消息记录到文件中，则需要使用 AddFile(“文件名”) 方法 ILoggingBuilder . 如果您仍然想使用消息填充特性，您需要通过 ILoggingBuilder 也。消息填充功能存在于 Microsoft.Orleans.Logging.遗产 包裹。所以您需要首先添加对该包的依赖性。然后通过 ILoggingBuilder . 下面是一个如何配置它的示例 ISiloHostBuilder siloBuiler.AddLogging(builder => builder.AddMessageBulkingLoggerProvider(new FileLoggerProvider(\"mylog.log\"))); 此方法将对 FileLoggerProvider ，使用默认的填充配置。 由于我们将在将来最终弃用并删除LogConsumer特性支持，我们强烈建议您尽快迁移掉这个特性。有两种方法你可以采取迁移。一个选择是保持你自己的 iLogger提供程序 ，这就创造了 窃听器 谁登录到所有现有的日志使用者。这和我们正在做的非常相似 Microsoft.Orleans.Logging.遗产 包裹。你可以看看 LegacyOrleanSlogger提供程序 从中借用逻辑。另一个选择是替换 ILogConsumer 现有的 iLogger提供程序 在nuget上，它提供相同或相似的功能，或者实现您自己的功能 iLogger提供程序 符合您特定的日志记录要求。并配置它们 iLogger提供程序 与 ILoggingBuilder . 但如果您不能在短期内迁移非日志使用者，您仍然可以使用它。支持 ILogConsumer 生活在 Microsoft.Orleans.Logging.遗产 包裹。所以您需要首先添加对该包的依赖，然后通过扩展方法配置日志使用者 添加LegacyOrleansLogging 在 ILoggingBuilder . 有本地人 添加日志记录 方法 IServiceCollection 提供单位ASP.NET供您配置 ILoggingBuilder . 我们还将该方法包装在 ISiloHostBuilder 和 IClientBuilder . 所以你可以调用 添加日志记录 方法来配置silo builder和client builder ILoggingBuilder . 下面是一个例子： var severityOverrides = new OrleansLoggerSeverityOverrides(); severityOverrides.LoggerSeverityOverrides.Add(typeof(MyType).FullName, Severity.Warning); siloBuilder.AddLogging(builder => builder.AddLegacyOrleansLogging(new List<ILogConsumer>() { new LegacyFileLogConsumer($\"{this.GetType().Name}.log\") }, severityOverrides)); 如果您投资于的自定义实现，则可以使用此功能 ILogConsumer 无法将它们转换为 iLogger提供程序 短期内。 Logger GetLogger(字符串loggerName) 方法 Grains 基类和 IProviderRuntime ，和 记录器日志{get；} 在2.0中，IStorageProvider上的方法仍作为不推荐使用的功能进行维护。您仍然可以在迁移Orleans遗留日志的过程中使用它。但我们建议你尽快离开它们。 提供程序配置 在Orleans 2.0中，包含的提供者的配置已经标准化，可以从 俱乐部选项 为silos或客户端配置。 服务ID是集群所代表的服务或应用程序的稳定标识符。随着时间的推移，在实施服务的群集的部署和升级之间，服务ID不会改变。 与服务ID不同，集群ID只在Silo集群的生命周期中保持不变。如果一个正在运行的集群被关闭，并且部署了同一服务的新集群，那么新集群将拥有一个新的、唯一的集群ID，但是将维护旧集群的服务ID。 服务ID通常用作密钥的一部分，用于持久化需要在整个服务生命周期中保持连续性的数据。例如Grain状态、提醒和持久流的队列。另一方面，集群成员关系表中的数据只在其集群的范围内有意义，因此通常是从集群ID中键入的。 在2.0之前，Orleans提供者的行为有时与使用服务ID和集群ID(以前也称为部署ID)不一致。由于这种统一性以及提供者配置API的整体变化，一些提供者写入存储器的数据可能会改变位置或密钥。对此更改敏感的提供程序示例是Azure队列流提供程序。 如果您正在将现有服务从1.x迁移到2.0，并且需要保持与您在服务中使用的提供程序持久化的数据的位置或键相关的向后兼容性，请验证数据是否位于您的服务或提供商预期的位置。如果您的服务碰巧依赖于1.x提供程序对服务ID和Cluster ID的错误使用，则可以重写 俱乐部选项 通过调用 ISiloHostBuilder.AddProviderClusterOptions() 或 IClientBuilder.AddProviderClusterOptions() 并强制它从存储器中的1.x位置读/写数据"
  },
  "Documentation/resources/Migration/Codegen.html": {
    "href": "Documentation/resources/Migration/Codegen.html",
    "title": "Code Generation in Orleans 2.0 | Microsoft Orleans 中文文档",
    "keywords": "Orleans2.0中的代码生成 在Orleans 2.0中，代码生成得到了改进，从而缩短了启动时间并提供了更具确定性和可调试性的体验。与早期版本一样，Orleans提供生成时和运行时代码生成。 在构建期间 -这是推荐的选项，仅支持C＃项目。在这种模式下，代码生成将在每次编译项目时运行。将一个构建任务注入到项目的构建管道中，并在项目的中间输出目录中生成代码。要激活此模式，请添加其中一个软件包 Microsoft.Orleans.CodeGenerator.MSBuild 要么 Microsoft.Orleans.OrleansCodeGenerator.Build 所有包含Grains，Grain接口，序列化器或需要序列化器的类型的项目。包和其他代码生成信息之间的差异可以在相应的文件中找到 代码生成 部分。通过指定以下值可以在构建时发出其他诊断： OrleansCodeGenLogLevel 在目标项目的 csproj 文件。例如， <OrleansCodeGenLogLevel>跟踪</ OrleansCodeGenLogLevel> 。 配置期间 -这是F＃，Visual Basic和其他非C＃项目唯一受支持的选项。此模式在配置阶段生成代码。要访问它，请参阅配置文档。 两种模式都生成相同的代码，但是运行时代码生成只能为公共可访问类型生成代码。"
  },
  "Documentation/resources/Migration/index.html": {
    "href": "Documentation/resources/Migration/index.html",
    "title": "Migration | Microsoft Orleans 中文文档",
    "keywords": "＃迁移信息 /// TODO：评估迁移信息后，写一个有关将要保留的内容的页面，等等。"
  },
  "Documentation/resources/Presentations/index.html": {
    "href": "Documentation/resources/Presentations/index.html",
    "title": "Orleans Presentations | Microsoft Orleans 中文文档",
    "keywords": "Orleans最佳实践 一系列技巧和窍门，可帮助设计，构建和运行基于Orleans的应用程序。 第28届国际分布式计算研讨会(2014年DISC)上的Orleans演讲 Orleans在第15届高性能交易系统国际研讨会上的演讲(HPTS 2013) Orleans的平衡技术 统一API是42-虚拟聚会＃3 Orleans在FreeBay-虚拟聚会＃4 Orleans流媒体-虚拟聚会＃5-2015年5月 Geo Distributed Orleans-虚拟聚会＃6-2015年10月 适用于Orleans的Orleankka Functional API-虚拟聚会＃7 Orleans路线图-虚拟聚会＃8-2016年1月 Orleans网络讨论-虚拟聚会＃8.5-2016年2月 服务结构上的Orleans-虚拟聚会＃9第1部分-2016年2月 Orleans与YAMS-虚拟聚会＃9第2部分-2016年2月 与Orleans一起走进分布式系统园"
  },
  "Documentation/resources/Contributing.html": {
    "href": "Documentation/resources/Contributing.html",
    "title": "Contributing to Orleans | Microsoft Orleans 中文文档",
    "keywords": "对Orleans的贡献 为那些想为Orleans做出贡献的开发者提供一些注释和指导。 对本项目的贡献 这里有一些建议，任何人寻找迷你特性和工作项目，将对Orleans作出积极的贡献。 这些只是一些想法，所以如果你想到其他有用的方法，那么就把 讨论线索 在GitHub上讨论这个提议，并付诸行动！ OrleansGitHub存储库 拉请求总是受欢迎的！ 实习生和学生项目 对可能的实习生/学生项目的一些建议。 文件编制指南 用于编写此网站文档的样式指南。 代码贡献 这个项目和另一个项目使用相同的贡献过程 DotNet项目 在GitHub上。 DotNet项目贡献指南 为GitHub上的DotNet项目提供帮助的指南和工作流。 互联网CLA GitHub上DotNet项目的贡献许可协议。 .NET框架设计指南 一些基本的API设计规则、编码标准和.NETFramework API的样式指南。 编码标准和惯例 对于编码风格的战争，我们尽量不要过于拘泥于强迫症，但在发生争议时，我们确实会回到GitHub上其他DotNet OSS项目使用的两本“.NET编码标准”书籍中的核心原则： 编码风格指南 .NET框架设计指南 还有很多其他有用的文档 .NET核心清除器 和 .NET核心框架 值得一读的文档站点，尽管大多数有经验的C开发人员可能已经通过渗透获得了许多这样的最佳实践，特别是在性能和内存管理方面。 源代码组织 Orleans并没有严格遵循“每个文件一个类”的规则，但是我们尝试使用实际的判断来最大限度地改变团队中开发人员的“代码理解能力”。如果许多小的ish类共享一个“公共主题”和/或总是一起处理，那么在大多数情况下，将它们放在一个源代码文件中是可以的。例如，不同的“LogConsumer”类最初放在单个源文件中，因为它们表示代码理解的单个单元。 作为推论，如果类位于与类同名的文件中，那么查找该类的源代码就容易得多[类似于Java文件命名规则]因此，在代码查找能力和最小化/限制解决方案中的项目数量和项目中的文件数量之间存在着一种张力和价值判断[对于大型项目，这两者都直接影响到visualstudio的“开放”和“构建”时间\"]. 在VS和ReSharper中的代码搜索工具绝对有帮助。 依赖关系和项目间引用 我们非常严格的一个主题是关于组件和子系统之间的依赖引用。 组件/项目参考 解决方案中项目之间的引用必须始终使用“ 项目参考文献 “而不是” DLL引用 “以确保构建工具知道组件构建关系。 赖特 : <ProjectReference Include=\"..\\Orleans\\Orleans.csproj\"> <Project>{BC1BD60C-E7D8-4452-A21C-290AEC8E2E74}</Project> <Name>Orleans</Name> </ProjectReference> 错了 : <Reference Include=\"Orleans\" > <HintPath>..\\Orleans\\bin\\Debug\\Orleans.dll</HintPath> </Reference> 为了帮助确保项目间引用保持干净，然后在构建服务器上[和本地的 生成.cmd 脚本]我们故意使用并排输入 .\\src 和输出 .\\二进制文件 目录而不是更正常的就地构建目录结构(例如。 [项目]\\bin\\发布 )由本地开发计算机上的VS使用。 统一组件版本 我们在整个Orleans代码库中使用相同的外部组件统一版本，因此不需要添加 绑定重定向 中的条目 应用程序配置 文件夹。 而且，一般来说，几乎没有必要 私有=真 元素，但重写与Windows/VS“system”组件的冲突除外。一些包管理工具在进行版本更改时有时会感到困惑，有时会认为我们在一个解决方案中使用同一程序集的多个版本，当然，我们从来没有这样做过。 我们渴望有一天.NET包管理工具可以进行事务性版本更改！在此之前，偶尔需要通过手动编辑.csproj文件(它们只是XML文本文件)来“修复”某些.NET包管理工具的错误操作，并/或使用“Discard Edited Line”函数，这些函数是大多数优秀的Git工具，如 阿特拉斯资源树 提供。 使用“sort”引用和统一的组件版本可以避免在Orleans运行时组件和/或外部组件之间创建脆弱的链接，并且在过去几年中被证明在重要部署里程碑期间为Orleans团队降低压力水平非常有效。:)"
  },
  "1.5/Documentation/Advanced-Concepts/External-Tasks-and-Grains.html": {
    "href": "1.5/Documentation/Advanced-Concepts/External-Tasks-and-Grains.html",
    "title": "External Tasks and Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . External Tasks and Grains By design, any sub-Tasks spawned from grain code (for example, by using await or ContinueWith or Task.Factory.StartNew ) will be dispatched on the same per-activation TPL Task Scheduler as the parent task and therefore inherit the same single-threaded execution model as the rest of grain code. This is the main point behind single threaded execution of grain turn based concurency . In some cases grain code might need to “break out” of the Orleans task scheduling model and “do something special”, such as explicitly pointing a Task to a different task scheduler or using the .NET Thread pool. An example of such cases is when grain code has to execute a synchronous remote blocking call (such as remote IO). Doing that in the grain context will block the grain as well as one of the Orleans threads and thus should never be made. Instead, the grain code can execute this piece of blocking code on the thread pool thread and join ( await ) the completion of that execution and proceed in the grain context. We expect that escaping from the Orleans scheduler will be a very advanced and seldom required usage scenario beyond the “normal” usage patterns. Task based APIs: 1) await , Task.Factory.StartNew , Task.ContinuewWith , Task.WhenAny , Task.WhenAll , Task.Delay all respect the current Task Scheduler. That means that using them in the default way, without passing a different TaskScheduler, will cause them to execute in the grain context. 2) Both Task.Run and the endMethod delegate of Task.Factory.FromAsync do NOT respect the current task Scheduler. They both use the TaskScheduler.Default scheduler, which is the .NET thread pool task Scheduler. Therefore, the code inside Task.Run and the endMethod will ALWAYS run on the .NET thread pool outside of the single-threaded execution model for Orleans grains, as detailed here . However, any code after the await Task.Run or await Task.Factory.FromAsync will run back under the scheduler at the point the task was created, which is the grain scheduler. 3) configureAwait(false) is an explicit API to escape the current task Scheduler. It will cause the code after an awaited Task to be executed on the TaskScheduler.Default scheduler, which is the .NET thread pool, and will thus break the single-threaded execution of the Orleans grain. You should in general never ever use configureAwait(false) directly in grain code. 4) Methods with signature async void should not be used with grains. They are intended for graphical user interface event handlers. Example: Below is sample code that demonstrates the usage of TaskScheduler.Current , Task.Run and a special custom scheduler to escape from Orlean grain context and how to get back to it. public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; await TaskDelay(10000); // Current task scheduler did not change, the code after await is still running in the same task scheduler. Assert.AreEqual(orleansTs, TaskScheduler.Current); Task t1 = Task.Run( () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(TaskScheduler.Default, TaskScheduler.Current); } ); await t1; // We are back to the Orleans task scheduler. // Since await was executed in Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); // Example of using ask.Factory.StartNew with a custom scheduler to escape from the Orleans scheduler Task t2 = Task.Factory.StartNew(() => { // This code runs on the MyCustomSchedulerThatIWroteMyself scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(MyCustomSchedulerThatIWroteMyself, TaskScheduler.Current); }, CancellationToken.None, TaskCreationOptions.None, scheduler: MyCustomSchedulerThatIWroteMyself); await t2; // We are back to Orleans task scheduler. Assert.AreEqual(orleansTS, TaskScheduler.Current); } Advanced Example - making a grain call from code that runs on a thread pool An even more advanced scenario is a piece of grain code that needs to “break out” of the Orleans task scheduling model and run on a thread pool (or some other, non-Orleans context), but still needs to call another grain. If you try to make a grain call but are not within an Orleans context, you will get an exception that says you are \"trying to send a message on a silo not from within a grain and not from within a system target (RuntimeContext is not set to SchedulingContext)\". Below is code that demonstrates how a grain call can be made from a piece of code that runs inside a grain but not in the grain context. public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; Task<int> t1 = Task.Run(async () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); // You can do whatever you need to do here. Now let's say you need to make a grain call. Task<Task<int>> t2 = Task.Factory.StartNew(() => { // This code runs on the Orleans task scheduler since we specified the scheduler: orleansTs. Assert.AreEqual(orleansTS, TaskScheduler.Current); return GrainFactory.GetGrain<IFooGrain>(0).MakeGrainCall(); }, CancellationToken.None, TaskCreationOptions.None, scheduler: orleansTs); int res = await (await t2); // double await, unrelated to Orleans, just part of TPL APIs. // This code runs back on the thread pool scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); return res; } ); int result = await t1; // We are back to the Orleans task scheduler. // Since await was executed in the Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); } Dealing with libraries Some external libraries that your code is using might be using ConfigureAwait(false) internally. In fact, it is a good and correct practice in .NET to use ConfigureAwait(false) when implementing general purpose libraries . This is not a problem in Orleans. As long as the code in the grain that invokes the library method is awaiting the library call with a regular await , the grain code is correct. The result will be exactly as desired -- the library code will run continuations on the Default scheduler (which happens to be ThreadPoolTaskScheduler but it does not guarantee that the continuations will definitely run on a ThreadPool thread, as continuations are often inlined in the previous thread), while the grain code will run on the Orleans scheduler. Another frequently-asked question is whether there is a need to execute library calls with Task.Run -- that is, whether there is a need to explicitly offload the library code to ThreadPool (for grain code to do Task.Run(()=> myLibrary.FooAsync()) ). The answer is No. There is no need to offload any code to ThreadPool, except for the case of library code that is making a blocking synchronous calls. Usually, any well-written and correct .NET async library (methods that return Task and are named with an Async suffix) do not make blocking calls. Thus there is no need to offload anything to ThreadPool, unless you suspect the async library is buggy or if you are deliberately using a synchronous blocking library. Summary What are you trying to do? How to do it Run background work on .NET thread-pool threads. No grain code or grain calls allowed. Task.Run Grain interface call Method return types = Task or Task<T> Run worker task from grain code with Orleans turn-based concurrency guarantees. Task.Factory.StartNew Timeouts for executing work items Task.Delay + Task.WhenAny Use with async / await The normal .NET Task-Async programming model. Supported & recommended ConfigureAwait(false) Do not use inside grain code. Allowed only inside libraries. Calling async library await the library call"
  },
  "1.5/Documentation/Advanced-Concepts/Interceptors.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Interceptors.html",
    "title": "Interceptors | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Interceptors Grain call filters provide a means for intercepting grain calls. Filters can execute code both before and after a grain call. Multiple filters can be installed simultaneously. Filters are asynchronous and can modify RequestContext , arguments, and the return value of the method being invoked. Filters can also inspect the MethodInfo of the method being invoked on the grain class and can be used to throw or handle exceptions. Some example usages of grain call filters are: Authorization: a filter can inspect the method being invoked and the arguments or some authorization information in the RequestContext to determine whether or not to allow the call to proceed. Logging/Telemetry: a filter can log information and capture timing data and other statistics about method invocation. Error Handling: a filter can intercept exceptions thrown by a method invocation and transform it into another exception or handle the exception as it passes through the filter. Grain call filters must implement the IGrainCallFilter interface, which has one method: public interface IGrainCallFilter { Task Invoke(IGrainCallContext context); } The IGrainCallContext argument passed to the Invoke method has the following shape: public interface IGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> of the method being invoked. /// </summary> MethodInfo Method { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } The IGrainCallFilter.Invoke() method must await or return the result of IGrainCallContext.Invoke() to execute the next configured filter and eventually the grain method itself. The IGrainCallContext.Result property can be modified after awaiting the Invoke() method. The IGrainCallContext.Method property returns the MethodInfo of the implementation class, not the interface. The MethodInfo of the interface method can be accessed using reflection. Grain call filters are called for all method calls to a grain and this includes calls to grain extensions (implementations of IGrainExtension ) which are installed in the grain. For example, grain extensions are used to implement Streams and Cancellation Tokens . Therefore, it should be expected that the value of IGrainCallContext.Method is not always a method in the grain class itself. Configuring Grain Call Filters Implementations of IGrainCallFilter can either be registered as silo-wide filters via Dependency Injection or they can be registered as grain-level filters via a grain implementing IGrainCallFilter directly. Silo-wide Grain Call Filters A delegate can be registered as a silo-wide grain call filters using Dependency Injection like so: services.AddGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.Method.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); Similarly, a class can be registered as a grain call filter using the AddGrainCallFilter helper method. Here is an example of a grain call filter which logs the results of every grain method: public class LoggingCallFilter : IGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.Method.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.Method.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } This filter can then be registered using the AddGrainCallFilter extension method: services.AddGrainCallFilter<LoggingCallFilter>(); Alternatively, the filter can be registered without the extension method: services.AddSingleton<IGrainCallFilter, LoggingCallFilter>(); Per-grain Grain Call Filters A grain class can register itself as a grain call filter and filter any calls made to it by implementing IGrainCallFilter like so: public class MyFilteredGrain : Grain, IMyFilteredGrain, IGrainCallFilter { public async Task Invoke(IGrainCallContext context) { await context.Invoke(); // Change the result of the call from 7 to 38. if (string.Equals(context.Method.Name, nameof(this.GetFavoriteNumber))) { context.Result = 38; } } public Task<int> GetFavoriteNumber() => Task.FromResult(7); } In the above example, all calls to the GetFavoriteNumber method will return 38 instead of 7 , because the return value has been altered by the filter. Another use case for filters is in access control, as in this example: [AttributeUsage(AttributeTargets.Method)] public class AdminOnlyAttribute : Attribute { } public class MyAccessControlledGrain : Grain, IMyFilteredGrain, IGrainCallFilter { public Task Invoke(IGrainCallContext context) { // Check access conditions. var isAdminMethod = context.Method.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool) RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {context.Method.Name}!\"); } return context.Invoke(); } [AdminOnly] public Task<int> SpecialAdminOnlyOperation() => Task.FromResult(7); } In the above example, the SpecialAdminOnlyOperation method can only be called if \"isAdmin\" is set to true in the RequestContext . In this way, grain call filters can be used for authorization. In this example, it is the responsibility of the caller to ensure that the \"isAdmin\" value is set correctly and that authentication is performed correctly. Note that the [AdminOnly] attribute is specified on the grain class method. This is because the IGrainCallContext.Method property returns the MethodInfo of the implementation, not the interface. The interface method can be accessed using reflection. Ordering of Grain Call Filters Grain call filters follow a defined ordering: IGrainCallFilter implementations configured in the dependency injection container, in the order in which they are registered. (Obsolete) Silo-wide InvokeInterceptor , configured via IProviderRuntime.SetInvokeInterceptor(...) . Grain-level filter, if the grain implements IGrainCallFilter . (Obsolete) Grain-level interceptor, if the grain implements IGrainInvokeInterceptor . Grain method implementation or grain extension method implementation. Each call to IGrainCallContext.Invoke() encapsulates the next defined filter so that each filter has a chance to execute code before and after the next filter in the chain and eventually the grain method itself. Client-side interceptors If a client side interceptor is defined, any grain call made from an Orleans client will invoke this interceptor before the call is dispatched remotely. The interceptor is invoked synchronously in the same thread where the call is made after call arguments are deep copied. Since the interceptor is invoked synchronously it should return promptly and do minimal work, to avoid blocking the calling thread or impacting throughput. The interceptor is allowed to mutate the call arguments and also mutate the Orleans.RequestContext . Any changes made by the interceptor to Orleans.RequestContext will be picked up as part of the call dispatch logic that occurs after the interceptor. If the interceptor logic throws an exception, the remote call will not be made and the client calling code will throw promptly. The interceptor can be set by setting GrainClient.ClientInvokeCallback , which is a property of type Action<InvokeMethodRequest, IGrain> . The first argument is the invocation request that includes various details about the invoked call, such as InterfaceId and MethodId, as well as deep-copied arguments. The second argument is the target grain reference to which this call is made. Currently, the main scenario that we know of that uses client side pre-call inteceptors is to add some extra information to Orleans.RequestContext , such as any special call context or token. Use Cases Exception Conversion When an exception which has been thrown from the server is getting deserialized on the client, you may sometimes get the following exception instead of the actual one: TypeLoadException: Could not find Whatever.dll. This happens if the assembly containing the exception is not available to the client. For example, say you are using Entity Framework in your grain implementations; then it is possible that an EntityException is thrown. The client on the other hand does not (and should not) reference EntityFramework.dll since it has no knowledge about the underlying data access layer. When the client tries to deserialize the EntityException , it will fail due to the missing DLL; as a consequence a TypeLoadException is thrown hiding the original EntityException . One may argue that this is pretty okay, since the client would never handle the EntityException ; otherwise it would have to reference EntityFramework.dll . But what if the client wants at least to log the exception? The problem is that the original error message is lost. One way to workaround this issue is to intercept server-side exceptions and replace them by plain exceptions of type Exception if the exception type is presumably unknown on the client side. However, there is one important thing we have to keep in mind: we only want to replace an exception if the caller is the grain client . We don't want to replace an exception if the caller is another grain (or the Orleans infrastructure which is making grain calls, too; e.g. on the GrainBasedReminderTable grain). On the server side this can be done with a silo-level interceptor: public class ExceptionConversionFilter : IGrainCallFilter { private static readonly HashSet<string> KnownExceptionTypeAssemblyNames = new HashSet<string> { typeof(string).Assembly.GetName().Name, \"System\", \"System.ComponentModel.Composition\", \"System.ComponentModel.DataAnnotations\", \"System.Configuration\", \"System.Core\", \"System.Data\", \"System.Data.DataSetExtensions\", \"System.Net.Http\", \"System.Numerics\", \"System.Runtime.Serialization\", \"System.Security\", \"System.Xml\", \"System.Xml.Linq\", \"MyCompany.Microservices.DataTransfer\", \"MyCompany.Microservices.Interfaces\", \"MyCompany.Microservices.ServiceLayer\" }; public async Task Invoke(IGrainCallContext context) { var isConversionEnabled = RequestContext.Get(\"IsExceptionConversionEnabled\") as bool? == true; if (!isConversionEnabled) { // If exception conversion is not enabled, execute the call without interference. await context.Invoke(); return; } RequestContext.Remove(\"IsExceptionConversionEnabled\"); try { await context.Invoke(); } catch (Exception exc) { var type = exc.GetType(); if (KnownExceptionTypeAssemblyNames.Contains(type.Assembly.GetName().Name)) { throw; } // Throw a base exception containing some exception details. throw new Exception( string.Format( \"Exception of non-public type '{0}' has been wrapped.\" + \" Original message: <<<<----{1}{2}{3}---->>>>\", type.FullName, Environment.NewLine, exc, Environment.NewLine)); } } } As mentioned earlier, this filter can then be registered using the AddGrainCallFilter extension method: services.AddGrainCallFilter<ExceptionConversionFilter>(); On the client side you have to set up a client-side interceptor: GrainClient.ClientInvokeCallback = (request, grain) => { RequestContext.Set(\"IsExceptionConversionEnabled\", true); }; This way the client tells the server that it wants to use exception conversion. Calling Grains from Interceptors It is possible to make grain calls from an interceptor through the injection of IGrainFactory into our interceptor class: private readonly IGrainFactory grainFactory; public CustomCallFilter(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Invoke(IGrainCallContext context) { // Hook calls to any grain other than ICustomFilterGrain implementations. // This avoids potential infinite recursion when calling OnReceivedCall() below. if (!(context.Grain is ICustomFilterGrain)) { var filterGrain = this.grainFactory.GetGrain<ICustomFilterGrain>(context.Grain.GetPrimaryKeyLong()); // Perform some grain call here. await filterGrain.OnReceivedCall(); } // Continue invoking the call on the target grain. await context.Invoke(); } Obsolete Interceptor Features The following sections describe functionality which has been superseded by the above features and may be removed in a future release. Silo-level Interceptors Silo-level interceptors are called for all grain calls within a silo. They can be installed using IProviderRuntime.SetInvokeInterceptor(interceptor) , typically from within a Bootstrap Provider 's Init method, like so: providerRuntime.SetInvokeInterceptor(async (method, request, grain, invoker) => { log.LogInfo($\"{grain.GetType()}.{method.Name}(...) called\"); // Invoke the request and return the result back to the caller. var result = await invoker.Invoke(grain, request); log.LogInfo($\"Grain method returned {result}\"); return result; }); Note how the interceptor wraps the call to the grain. This allows the user to inspect the return value of each method as well as handle any exceptions which are thrown. SetInvokeInterceptor takes a single parameter, a delegate of type InvokeInterceptor with the following signature: public delegate Task<object> InvokeInterceptor( MethodInfo targetMethod, InvokeMethodRequest request, IGrain target, IGrainMethodInvoker invoker); In this delegate: targetMethod is the MethodInfo of the method being called on the grain implementation, not the interface. request.Arguments is an object[] containing the arguments to the method, if any. target is the grain implementation instance being called. invoker is used to invoke the method itself. Grain-level Interceptors Grain-level interceptors intercept calls for individual grains only. Grain-level interceptors are enabled by implementing IGrainInvokeInterceptor in a grain class: public interface IGrainInvokeInterceptor { Task<object> Invoke( MethodInfo method, InvokeMethodRequest request, IGrainMethodInvoker invoker); } For example: public Task<object> Invoke( MethodInfo methodInfo, InvokeMethodRequest request, IGrainMethodInvoker invoker) { // Check access conditions. var isAdminMethod = methodInfo.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool)RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {methodInfo.Name}!\"); } return invoker.Invoke(this, request); } If a silo-level interceptor is also present, the grain-level interceptor is invoked inside of silo-level interceptors, during the call to invoker.Invoke(...) . Grain-level interceptors will also be invoked for grain extensions (implementations of IGrainExtension ), not only for method in the current class."
  },
  "1.5/Documentation/Advanced-Concepts/Request-Context.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Request-Context.html",
    "title": "Request Context | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Request Context RequestContext is an Orleans feature that allows application metadata, such as a trace ID, to flow with requests. Application metadata may be added on the client; it will flow with Orleans requests to the receiving grain. The feature is implemented by a public static class, RequestContext, in the Orleans namespace. This class exposes two simple methods: void Set(string key, object value) is used to store a value in the request context. The value can be any Serializable type. Object Get(string key) is used to retrieve a value from the current request context. The backing storage for RequestContext is thread-static. When a thread (whether client-side or within Orleans) sends a request, the contents of the sending thread’s RequestContext is included with the Orleans message for the request; when the grain code receives the request, that metadata is accessible from the local RequestContext. If the grain code does not modify the RequestContext, then any grain it makes a request of will receive the same metadata, and so on. Application metadata also is maintained when you schedule a future computation using StartNew or ContinueWith; in both cases, the continuation will execute with the same metadata as the scheduling code had at the moment the computation was scheduled (that is, the system makes a copy of the current metadata and passes that to the continuation, so changes after the call to StartNew or ContinueWith will not be seen by the continuation). Note that application metadata does not flow back with responses; that is, code that runs as a result of a response being received, either within a ContinueWith continuation or after a call to Wait or GetValue, will still run within the current context that was set by the original request. For example, to set a trace ID in the client to a new GUID, one would simply call: RequestContext.Set(\"TraceId\", new Guid()); Within grain code (or other code that runs within Orleans on a scheduler thread), the trace ID of the original client request could be used, for instance, when writing a log: Logger.Info(\"Currently processing external request {0}\", RequestContext.Get(\"TraceId\")); While any serializable object may be sent as application metadata, it’s worth mentioning that large or complex objects may add noticeable overhead to message serialization time. For this reason, the use of simple types (strings, GUIDs, or numeric types) is recommended."
  },
  "1.5/Documentation/Advanced-Concepts/Application-Bootstrap-within-a-Silo.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Application-Bootstrap-within-a-Silo.html",
    "title": "Application Bootstrapping within a Silo | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Application Bootstrapping within a Silo There are several scenarios where application want to run some \"auto-exec\" functions when a silo comes online. Some examples include, but are not limited to: Starting background timers to perform periodic housekeeping tasks Pre-loading some cache grains with data downloaded from external backing storage. We have now added support for this auto-run functionality through configuring \"bootstrap providers\" for Orleans silos. For example: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <BootstrapProviders> <Provider Type=\"My.App.BootstrapClass1\" Name=\"bootstrap1\" /> <Provider Type=\"My.App.BootstrapClass2\" Name=\"bootstrap2\" /> </BootstrapProviders> </Globals> </OrleansConfiguration> It is also possible to register Bootstrap provider programaticaly, via calling one of the: public void RegisterBootstrapProvider(string providerTypeFullName, string providerName, IDictionary<string, string> properties = null) public void RegisterBootstrapProvider<T>(string providerName, IDictionary<string, string> properties = null) where T : IBootstrapProvider on the Orleans.Runtime.Configuration.GlobalConfiguration class. These bootstrap providers are C# classes that implement the Orleans.Providers.IBootstrapProvider interface. When each silo starts up, the Orleans runtime will instantiate each of the listed app bootstrap classes, and then call their Init method in an appropriate runtime execution context that allows those classes to act as a client and send messages to grains. There should be no blocking calls made inside the Init method. Task Init( string name, IProviderRuntime providerRuntime, IProviderConfiguration config) Any Exceptions that are thrown from an Init method of a bootstrap provider will be reported by the Orleans runtime in the silo log, then the silo startup will be halted. This fail-fast approach is the standard way that Orleans handles silo start-up issues, and is intended to allow any problems with silo configuration and/or bootstrap logic to be easily detected during testing phases rather than being silently ignored and causing unexpected problems later in the silo lifecycle."
  },
  "1.5/Documentation/Grain-Versioning/Version-selector-strategy.html": {
    "href": "1.5/Documentation/Grain-Versioning/Version-selector-strategy.html",
    "title": "Version selector strategy | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Version selector strategy When several versions of the same grain interface exist in the cluster, and a new activation has to be created, a compatible version will be chosen according to the strategy defined in GlobalConfiguration.DefaultVersionSelectorStrategy . Orleans out of the box supports the following strategies: All compatible versions (default) Using this strategy, the version of the new activation will be chosen randomly across all compatible versions. For example if we have 2 versions of a given grain interface, V1 and V2: V2 is backward compatible with V1 In the cluster there are 2 silos that support V2, 8 support V1 The request was made from a V1 client/silo In this case, there is a 20% chance that the new activation will be a V2 and 80% chance that it will be a V1. Latest version Using this strategy, the version of the new activation will always be the latest compatible version. For example if we have 2 versions of a given grain interface, V1 and V2 (V2 is backward or fully compatible with V1) then all new activations will be V2. Minimum version Using this strategy, the version of the new activation will always be the requested or the minimum compatible version. For example if we have 2 versions of a given grain interface, V2, V3, all fully compatibles: If the request was made from a V1 client/silo, the new activation will be a V2 If the request was made from a V3 client/silo, the new activation will be a V2 too"
  },
  "1.5/Documentation/Grain-Versioning/Grain-versioning.html": {
    "href": "1.5/Documentation/Grain-Versioning/Grain-versioning.html",
    "title": "Grain versioning | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain versioning Warning This page describes how to use grain interface versioning. The versioning of Grain state is out of scope. Overview On a given cluster, silos can support different versions of a grain type. In this example the client and Silo{1,2,3} were compiled with grain interface A version 1. Silo 4 was compiled with A version 2. Limitations: No versioning on stateless worker Streaming interfaces are not versioned Enable versioning By default, grains are not versioned. You can version grain by using the VersionAttribute on the grain interface: [Version(X)] public interface IVersionUpgradeTestGrain : IGrainWithIntegerKey {} Where X is the version number of the grain interface, which is typically monotonically increasing. Grain version compatibility and placement When a call from a versioned grain arrive in a cluster: If no activation exists, a compatible activation will be created If an activation exists: If the current one is not compatible, it will be deactivated and new compatible will be created (see version selector strategy ) If the current one is compatible (see compatible grains ), the call will be handled normally. By default: All versioned grains are supposed to be backward-compatible only (see backward compatibility guidelines and compatible grains ). That means that a v1 grain can make calls to a v2 grain, but a v2 grain cannot call a v1. This default behavior can be changed with GlobalConfiguration.DefaultCompatibilityStrategy When multiple versions exist in the cluster, the new activation will be randomly placed on a compatible silo. This default behavior can be changed with GlobalConfiguration.DefaultVersionSelectorStrategy"
  },
  "1.5/Documentation/Grain-Versioning/Compatible-grains.html": {
    "href": "1.5/Documentation/Grain-Versioning/Compatible-grains.html",
    "title": "Compatible grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Compatible grains When an existing grain activation is about to process a request, the runtime will check if the version in the request and the actual version of the grain are compatible. Orleans does not infer at runtime which policy to use , The default behavior to determine if two versions are compatible is determined by GlobalConfiguration.CompatibilityStrategy Backward compatible (default) Definition A grain interface version Vn can be be backward compatible with Vm if: The name of the interface didn't change (or the overridden typecode) All public methods present in the Vm version are in the Vn version. It is important that the signatures of the methods inherited from Vm are not modified : since Orleans use an internal built-in serializer, modifying/renaming a field (even private) can make the serialization to break. Since Vn can have added methods compared to Vm, Vm is not compatible with Vn. Example If in the cluster we have two versions of a given interface, V1 and V2 and that V2 is backward compatible with V1: If the current activation is a V2 and the requested version is V1, the current activation will be able to process the request normally If the current activation is a V1 and the requested version is V2, the current activation will be deactivated and a new activation compatible with V2 will be created (see version selector strategy ). Fully compatible Definition A grain interface version Vn can be fully compatible with Vm if: Vn is backward compatible with Vm No public methods where added in the Vn version If Vn is fully compatible with Vm then Vm is also fully compatible with Vn. Example If in the cluster we have two versions of a given interface, V1 and V2 and that V2 is fully compatible with V1: If the current activation is a V2 and the requested version is V1, the current activation will be able to process the request normally If the current activation is a V2 and the requested version is V1, the current activation will also be able to process the request normally"
  },
  "1.5/Documentation/Grain-Versioning/Backward-compatibility-guidelines.html": {
    "href": "1.5/Documentation/Grain-Versioning/Backward-compatibility-guidelines.html",
    "title": "Backward compatibility guidelines | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Backward compatibility guidelines Writing backward compatible code can be hard and difficult to test. Never change the signature of existing methods Because of the way on how Orleans serializer work, you should never change the signature of existing methods. The following example is correct: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } This is not correct: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg, obj o); } NOTE : you should not do this change in your code, as it's an example of a bad practice that leads to very bad side-effects. This is an example of what can happen if you just rename the parameter names: let's say that we have the two following interface version deployed in the cluster: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // return a - b Task<int> Substract(int a, int b); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // return y - x Task<int> Substract(int y, int x); } This methods seems identical. But if the client was called with V1, and the request is handled by a V2 activation: var grain = client.GetGrain<IMyGrain>(0); var result = await grain.Substract(5, 4); // Will return \"-1\" instead of expected \"1\" This is due to how the internal Orleans serializer works. Avoid changing existing method logic It can seems obvious, but you should be very careful when changing the body of an existing method. Unless you are fixing a bug, it is better to just add a new method if you need to modify the code. (see compatible grains ) Example: // V1 public interface MyGrain : IMyGrain { // First method Task MyMethod(int arg) { SomeSubRoutine(arg); } } // V2 public interface MyGrain : IMyGrain { // Method inherited from V1 // Do not change the body Task MyMethod(int arg) { SomeSubRoutine(arg); } // New method added in V2 Task MyNewMethod(int arg) { SomeSubRoutine(arg); NewRoutineAdded(arg); } } Do not remove methods from grain interfaces Unless you are sure that they are no longer used, you should not remove methods from the grain interface. If you want to remove methods, this should be done in 2 steps: Deploy V2 grains, with V1 method marked as Obsolete [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 [Obsolete] Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } When you are sure that no V1 calls are made (effectively V1 is no longer deployed in the running cluster), deploy V3 with V1 method removed [Version(3)] public interface IMyGrain : IGrainWithIntegerKey { // New method added in V2 Task MyNewMethod(int arg, obj o); }"
  },
  "1.5/Documentation/Grain-Versioning/Deployment.html": {
    "href": "1.5/Documentation/Grain-Versioning/Deployment.html",
    "title": "Deploy new version of grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Deploy new version of grains Rolling upgrade In this method you deploy newer silos directly on your environment. This is the simplest method, but it can be difficult to interrupt an ongoing deployment and to rollback. Recommended configuration: DefaultCompatibilityStrategy set to BackwardCompatible DefaultVersionSelectorStrategy set to AllCompatibleVersions When using this configuration, \"old\" clients will be able to talk to activations on both versions of silos. Newer clients and silos will only trigger new activations on newer silos. Using a staging environment In this method you will need a second environment (Staging environment), on which you will deploy newer silos before stopping the Production environment. The Production and the Staging silos and clients will be part of the same cluster . It is important that silos from both environment can talk to each other. Recommended configuration: DefaultCompatibilityStrategy set to BackwardCompatible DefaultVersionSelectorStrategy set to MinimumVersion Suggested deployment steps: \"V1\" silos and clients are deployed and are running in the Production slot. \"V2\" silos and clients begin to start in the Staging slot. They will join the same cluster as the Production slot. No \"V2\" activations will be created so far. Once the deployment in the Staging slot is finished, the developper can redirect some traffic on the V2 clients (smoke tests, targeted beta users, ect.). This will create V2 activations, but since Grains are backward compatibles and that all silos are in the same cluster, no duplicate activations will be created. If the validation is successful, proceed to VIP swap. If not, you can safely shutdown the Staging cluster: existing V2 activations will be destroyed and V1 activations will be created if needed. V1 activations will naturally \"migrate\" to V2 silos eventually. You can safely shutdown V1 silos. Warning Remember that stateless workers are not versioned and that streaming agents will also start in the staging environment."
  },
  "1.5/Documentation/Multi-Cluster/SiloConfiguration.html": {
    "href": "1.5/Documentation/Multi-Cluster/SiloConfiguration.html",
    "title": "Multi-Cluster Silo Configuration | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Silo Configuration To get a quick overview, we show all relevant configuration parameters (including optional ones) in XML syntax below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <MultiClusterNetwork ClusterId=\"clusterid\" DefaultMultiCluster=\"uswest,europewest,useast\" BackgroundGossipInterval=\"30s\" UseGlobalSingleInstanceByDefault=\"false\" GlobalSingleInstanceRetryInterval=\"30s\" GlobalSingleInstanceNumberRetries=\"3\" MaxMultiClusterGateways=\"10\"> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> </MultiClusterNetwork> <SystemStore ... ServiceId=\"some-guid\" .../> </Globals> </OrleansConfiguration> As usual, all configuration settings can also be read and written programmatically, via the respective members of the GlobalConfiguration class. The Service Id is an arbitrary Guid for identifying this service. It must be the same for all clusters and all silos. If not specified, the default Guid (containing all zeroes) is used. The MultiClusterNetwork section is optional - if not present, all multi-cluster support is disabled for this silo. The required parameters ClusterId and GossipChannel are explained in the section on Multi-Cluster Communication . The optional parameters MaxMultiClusterGateways and BackgroundGossipInterval are explained in the section on Multi-Cluster Communication . The optional parameter DefaultMultiCluster is explained in the section on Multi-Cluster Configuration . The optional parameters UseGlobalSingleInstanceByDefault , GlobalSingleInstanceRetryInterval and GlobalSingleInstanceNumberRetries are explained in the section on Global-Single-Instance Grains . Orleans Client Configuration No extra configuration is required for Orleans client. The same client may not connect to silos in different clusters (the silo refuses the connection in that situation)."
  },
  "1.5/Documentation/Multi-Cluster/GlobalSingleInstance.html": {
    "href": "1.5/Documentation/Multi-Cluster/GlobalSingleInstance.html",
    "title": "Global-Single-Instance Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain Coordination Attributes Developers can indicate when and how clusters should coordinate their grain directories with respect to a particular grain class. The [GlobalSingleInstance] attribute means we want the same behavior as as when running Orleans in a single global cluster: that is, route all calls to a single activation of the grain. Conversely, the [OneInstancePerCluster] attribute indicates that each cluster can have its own independent activation. This is appropriate if communication between clusters is undesired. The attributes are placed on grain implementations. For example: using Orleans.MultiCluster; [GlobalSingleInstance] public class MyGlobalGrain : Orleans.Grain, IMyGrain { ... } [OneInstancePerCluster] public class MyLocalGrain : Orleans.Grain, IMyGrain { ... } If a grain class does not specify either one of those attributes, it defaults to [OneInstancePerCluster] , or [GlobalSingleInstance] if the configuration parameter UseGlobalSingleInstanceByDefault is set to true. Protocol for Global-Single-Instance Grains When a global-single-instance (GSI) grain is accessed, and no activation is known to exist, a special GSI activation protocol is executed before activating a new instance. Specifically, a request is sent to all other clusters in the current multi-cluster configuration to check if they already have an activation for this grain. If all responses are negative, a new activation is created in this cluster. Otherwise, the remote activation is used (and a reference to it is cached in the local directory). Protocol for One-Instance-Per-Cluster Grains There is no inter-cluster communication for One-Instance-Per-Cluster grains. They simply use the standard Orleans mechanism independently within each cluster. Inside the Orleans framework itself, the following grain classes are marked with the [OneInstancePerCluster] attribute: ManagementGrain , GrainBasedMembershipTable , and GrainBasedReminderTable . Doubtful Activations If the GSI protocol does not receive conclusive responses from all clusters after 3 retries (or whatever number is specified by the configuration parameter GlobalSingleInstanceNumberRetries ), it creates a new local \"doubtful\" activation optimistically, favoring availability over consistency. Doubtful activations may be duplicates (because some remote cluster that did not respond during the GSI protocol activation may nevertheless have an activation of this grain). Therefore, periodically every 30 seconds (or whatever interval is specified by the configuration parameter GlobalSingleInstanceRetryInterval ) the GSI protocol is run again for all doubtful activations. This ensures that once communication between clusters is restored, duplicate activations can be detected and removed."
  },
  "1.5/Documentation/Multi-Cluster/MultiClusterConfiguration.html": {
    "href": "1.5/Documentation/Multi-Cluster/MultiClusterConfiguration.html",
    "title": "Multi-Cluster Configuration | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Configuration The multi-cluster configuration determines which clusters are currently part of the multi-cluster. It does not change automatically, but is controlled by the operator. Thus, it is quite different from the membership mechanism used within a cluster, which automatically determines the set of silos that are part of the cluster. We use the following terminology for the clusters in a service: A cluster is active if it has at least one active silo, and inactive otherwise A cluster is joined if it is part of the current multi-cluster configuration, and non-joined otherwise Being active/inactive is independent from being joined/non-joined: all four combinations are possible. All the clusters for a particular service are connected by a gossip network . The gossip network propagates configuration and status information. Injecting a configuration An operator issues configuration changes by injecting them into the multi-cluster network. The configurations can be injected into any cluster, and spread from there to all active clusters. Each new configuration consists of a list of cluster ids that form the multi-cluster. It also has a UTC timestamp that is used to track its propagation through the gossip network. Initially, the multi-cluster configuration is null, which means the multi-cluster list is empty (contains no clusters). Thus, the operator must initially inject a multi-cluster configuration. Once injected, this configuration persists in all connected silos (while running) and in all specified gossip channels (if those channels are persistent). We pose some restrictions on the injection of new configurations that an operator must follow: Each new configuration may add a number of clusters, or remove a number of clusters (but not both at the same time). An operator should not issue a new configuration while a previous configuration change is still being processed. These restrictions ensure that protocols such as the single-instance-protocol can correctly maintain mutual exclusion of activations even under configuration changes. Via Management Grain Multi-cluster configurations can be injected on any node in any cluster, using the Orleans Management Grain. For example, to inject a multi-cluster configuration that consists of the three clusters { us1, eu1, us2 }, we can pass a string enumerable to the management grain: var clusterlist = \"us1,eu1,us2\".Split(','); var mgtGrain = GrainClient.GrainFactory.GetGrain<IManagementGrain>(0); mgtGrain.InjectMultiClusterConfiguration(clusterlist, \"my comment here\")); The first argument to InjectMultiClusterConfiguration is an enumerable of cluster ids, which is going to define the new multi-cluster configuration. The second argument is an (optional) comment string that can be used to tag configurations with arbitrary information, such as who injected them why. There is an optional third argument, a boolean called checkForLaggingSilosFirst , which defaults to true. It means that the system performs a best-effort check to see if there are any silos anywhere that have not caught up to the current configuration yet, and rejects the change if it finds such a silo. This helps to detect violations of the restriction that only one configuration change should be pending at a time (though it cannot guarantee it under all circumstances). Via Default Configuration In situations where the multi-cluster configuration is known in advance and the deployment is fresh every time (e.g. for testing), we may want to supply a default configuration. The global configuration supports an optional attribute DefaultMultiCluster which takes a comma-separated list of cluster ids: <MultiClusterNetwork ... DefaultMulticluster=\"us1,eu1,us2\" ...> After a silo is started with this setting, it checks to see if the current multi-cluster configuration is null, and if so, injects the given configuration with the current UTC timestamp. WARNING. Persistent multi-cluster gossip channels (e.g. based on AzureTable) retain the last injected configuration unless they are deleted explicitly. In that case, specifying a DefaultMulticluster has no effect when re-deploying a cluster because the configuration stored in the gossip channels is not null.> Via Gossip Channel An operator can also inject the configuration directly into the gossip channel. Changes in the channel are picked up and propagated automatically by the periodic background gossip, though possibly very slowly (using the management grain is much faster). A rough estimate on the propagation time is 30 seconds (or whatever gossip interval is specified in the global configuration) times the binary logarithm of the total number of silos in all clusters. But since the gossip pairs are selected randomly, it can be both much quicker or much slower. If using the Azure Table-Based Gossip Channel, operators can inject a new configuration simply by editing the configuration record in the OrleansGossipTable , e.g. using some tool for editing data in Azure tables. The configuration record has the following format: Name Type Value PartitionKey String the ServiceId GUID RowKey String \"CONFIG\" Clusters String comma-separated list of cluster IDs, e.g. \"us1,eu1,us2\" Comment String optional comment GossipTimestamp DateTime UTC timestamp for the configuration NOTE . When editing this record in storage, the GossipTimestamp must also be set to a newer value than it has currently (otherwise the change is ignored). The most convenient and recommended way to do this is to delete the GossipTimestamp field - our gossip channel implementation then automatically replaces it with a correct, current Timestamp (it uses the Azure Table Timestamp). Cluster Addition/Removal Procedures Adding or removing a cluster from the multi-cluster often needs to be coordinated within some larger context. We recommend to always follow the procedures described below when adding/removing clusters from the multi-cluster. Procedure for adding a cluster Start a new Orleans cluster and wait till all silos are up and running. Inject a configuration that contains the new cluster. Start routing user requests to the new cluster. Procedure for removing a cluster Stop routing new user requests to the cluster. Inject a configuration that no longer contains the cluster. Stop all silos of the cluster. Once a cluster has been removed in this way, it can be re-added by following the procedure for adding a new cluster. Activity on Non-Joined Clusters There can be brief, temporary periods of time where a cluster is both active and non-joined: A freshly started cluster may start executing code before it is in the multicluster configuration (between steps 1 and 2 of the procedure for adding a cluster) A cluster that is being decommissioned may still execute code before the silos are shut down (between steps 2 and 3 of the procedure for removing a cluster). During those intermediate situations, the following are possible: For global-single-instance grains: A grain may have a duplicate activation on a non-joined cluster. For versioned grains: activations on non-joined clusters do not receive notifications when the grain state changes."
  },
  "Documentation/index.html": {
    "href": "Documentation/index.html",
    "title": "Introduction | Microsoft Orleans 中文文档",
    "keywords": "Orleans是一个用于构建健壮、可伸缩的分布式应用程序的跨平台框架 Orleans建立在.NET开发人员生产力的基础上，并将其带入了分布式应用程序的世界，例如云服务。 Orleans可从单个本地服务器扩展到云中全局分布的高可用性应用程序。 Orleans采用了对象，接口，async/await和try/catch等熟悉的概念，并将其扩展到多服务器环境。这样，它可以帮助具有单服务器应用程序经验的开发人员过渡到构建弹性，可扩展的云服务和其他分布式应用程序。因此，Orleans通常被称为“分布式.NET”。 它是由 Microsoft Research 创建的，并介绍了 Virtual Actor Model 作为一种新方法来构建面向云时代的新一代分布式系统。 Orleans的核心贡献是它的编程模型，它在不限制功能，以及对开发人员施加繁重约束的情况下，降低了高并发分布式系统固有的复杂性。 Grains 任何Orleans应用程序的基本构建块都是 grain . grains是由用户定义的身份、行为和状态组成的实体。grains标识是用户定义的键，使grains始终可供调用。Grains可以通过强类型通信接口(contract)被其他Grains或Web前端等外部客户端调用。每个grains都是实现一个或多个这些接口的类的一个实例。 Grains可以具有挥发性和/或持久化状态，可以存储在任何存储系统中。因此，grains隐式地划分应用程序状态，从而实现自动可伸缩性并简化故障恢复。当Grain处于活动状态时，Grain状态被保存在内存中，从而降低了延迟和数据存储的负载。 grains的实例化由Orleans运行时根据需要自动执行。暂时不使用的grains会自动从内存中删除以释放资源。这是有可能的，因为它们具有稳定的身份，允许调用grains，不管它们是否已经加载到内存中。这还允许透明地从失败中恢复，因为调用方不需要知道在任何时间点在哪个服务器上实例化了一个grain。Grains有一个受管理的生命周期，Orleans运行时负责激活/停用Grains，并根据需要存储/定位Grains。这允许开发人员编写代码，就好像所有的grains总是在内存中一样。 总的来说，稳定的标识、有状态性和可管理的生命周期是构建在Orleans之上的系统可伸缩、高性能的核心因素，&可靠，不必强迫开发人员编写复杂的分布式系统代码。 示例：物联网云后端 考虑一个云后端 物联网 系统。此应用程序需要处理传入的设备数据、筛选、聚合和处理这些信息，并允许向设备发送命令。在Orleans，人们很自然地用一种Grains来模拟每一种设备，这种Grains变成了 数码双胞胎 它所对应的物理设备。这些grains将最新的设备数据保存在内存中，这样就可以快速地查询和处理它们，而不需要直接与物理设备通信。通过观察来自设备的时间序列数据流，grains可以检测条件的变化，例如测量值超过阈值，并触发一个动作。 一个简单的恒温器可以建模如下： public interface IThermostat : IGrainWithStringKey { Task<List<Command>> OnUpdate(ThermostatStatus update); } 从Web前端从恒温器到达的事件可以通过调用 OnUpdate 方法，它可以选择将命令返回给设备。 var thermostat = client.GetGrain<IThermostat>(id); return await thermostat.OnUpdate(update); 相同的恒温器grains可实现单独的接口，以便控制系统与： public interface IThermostatControl : IGrainWithStringKey { Task<ThermostatStatus> GetStatus(); Task UpdateConfiguration(ThermostatConfiguration config); } 这两个接口( IThermostat 和 IThermostatControl )由单个实现类实现： public class ThermostatGrain : Grain, IThermostat, IThermostatControl { private ThermostatStatus _status; private List<Command> _commands; public Task<List<Command>> OnUpdate(ThermostatStatus status) { _status = status; var result = _commands; _commands = new List<Command>(); return Task.FromResult(result); } public Task<ThermostatStatus> GetStatus() => Task.FromResult(_status); public Task UpdateConfiguration(ThermostatConfiguration config) { _commands.Add(new ConfigUpdateCommand(config)); return Task.CompletedTask; } } 上面的Grains类不会保持其状态。 文档 中提供了演示状态持久化的更彻底的示例。 Orleans运行时 Orleans运行时为应用程序运行时的主要组件是 silos ，负责寄存Grains。通常，一组silos作为集群运行，以实现可伸缩性和容错性。当作为集群运行时，silos相互协调以分配工作、检测并从故障中恢复。运行时使集群中托管的grains能够像在单个进程中一样相互通信。 除了核心编程模型之外，silos还为grains提供了一组运行时服务，例如计时器、提醒(persistent timers)、持久化、事务、流等。见 特色部分 下面是更多细节。 Web前端和其他外部客户端使用客户端库调用集群中的grains，该库自动管理网络通信。为了简单起见，客户端也可以与silos在同一进程中共同托管。 Orleans与.NET Standard 2.0及更高版本兼容，运行在Windows、Linux和macOS上，采用完整的.NET Framework或.NET核心。 特征 持久化 Orleans提供了一个简单的持久化模型，确保在处理请求之前，状态对grain是可用的，并且保持一致性。Grains可以有多个命名的持久化数据对象，例如，一个名为“profile”的用户概要文件，一个名为“inventory”的存储。此状态可以存储在任何存储系统中。例如，配置文件数据可以存储在一个数据库中，而库存存储在另一个数据库中。当一个grain正在运行时，这个状态被保存在内存中，这样就可以在不访问存储器的情况下处理读请求。当grains更新其状态时 state.WriteStateAsync() call确保备份存储的持久化和一致性得到更新。有关详细信息，请参见 Grains持久化 文档。 分布式ACID事务 除了上面描述的简单持久化模型之外，grains还可以 事务状态 . 多个grains可以参与 酸性 不管事务的状态最终存储在何处。Orleans的事务是分布式和分散的(没有中央事务管理器或事务协调器)，并且 可串行隔离 . 有关Orleans交易的更多信息，请参阅 文档 以及 微软研究院技术报告 . Streams 流帮助开发人员以近乎实时的方式处理一系列数据项。Orleans的Streams 管理 ：在Grain或客户端发布到流或订阅流之前，不需要创建或注册流。这使得流生产者和消费者之间以及与基础设施之间的更大程度的分离。流处理是可靠的：grains可以存储检查点(游标)，并在激活期间或之后的任何时间重置为存储的检查点。Streams支持向使用者批量传递消息，以提高效率和恢复性能。流由排队服务支持，如Azure事件中心、Amazon Kinesis等。可以将任意数量的流多路复用到较小数量的队列上，并且处理这些队列的责任在集群中均衡。 计时器&提醒 提醒是一种持久的Grains调度机制。它们可用于确保在将来某个时间点完成某些操作，即使此时grains当前未激活。计时器是非持久化的提醒物，可用于不需要可靠性的高频事件。有关详细信息，请参见 计时器和提醒 文档。 灵活的Grains存储 当一个Grains在Orleans被激活时，运行时决定在哪个服务器(silos)上激活该Grains。这就是所谓的Grains存储。Orleans的布局过程是完全可配置的：开发人员可以从一组现成的布局策略中进行选择，例如随机、首选本地和基于负载的，或者可以配置自定义逻辑。这样就可以充分灵活地决定在哪里产生grains。例如，可以将Grain存储在服务器上，靠近它们需要操作的资源或与之通信的其他Grain。 Grains版本化&异构集群 应用程序代码会随着时间的推移而发展，以安全地解释这些更改的方式升级实时生产系统可能是一项挑战，尤其是在有状态的系统中。Orleans的Grains接口可以选择性地进行版本控制。集群维护了一个映射，映射出集群中的哪些Silo上有哪些grain实现以及这些实现的版本。运行时将此版本信息与存储策略结合使用，以便在将调用路由到grains时做出存储决策。除了安全地更新版本化的grains之外，这还支持异构集群，其中不同的silo具有不同的grain实现集。有关详细信息，请参见 Grains版本化 文档。 弹性伸缩性&容错 Orleans的设计是弹性伸缩的。当silos加入集群时，它能够接受新的激活，当silos离开集群时(由于规模缩小或机器故障)，在该silos上激活的Grains将根据需要在其余silos上重新激活。一个Orleans集群可以缩小到一个silos。支持弹性伸缩性的相同属性也支持容错：集群自动检测并从故障中快速恢复。 运行在任何地方 Orleans运行任何支持.NETCore或.NETFramework的地方。这包括在Linux、Windows和macOS上托管，并部署到Kubernetes、虚拟机或物理机、本地或云中，以及PaaS服务(如Azure云服务)。 无状态工作者 无状态工作者是特殊标记的grains，没有任何关联状态，可以同时在多个silos上激活。这样就可以提高无状态函数的并行性。有关详细信息，请参见 无状态工作者Grains 文档。 Grains拦截器 许多Grains的共同逻辑可以表示为 Grains拦截器 . Orleans支持传入和呼出的过滤器。过滤器的一些常见用例有：授权、日志记录和遥测以及错误处理。 请求上下文 元数据和其他信息可以通过使用 请求上下文 . 请求上下文可用于打孔分布式跟踪信息或任何其他用户定义的值。 入门 请看 入门教程 . 构建 在Windows上，运行 build.cmd 脚本在本地构建NuGet包，然后从中引用所需的NuGet包 /Artifacts/Release/* . 你可以跑了 Test.cmd 运行所有BVT测试，以及 TestAll.cmd 同时运行功能测试。 在Linux和macOS上，运行 build.sh 脚本或 dotnet build ./OrleansCrossPlatform.sln 构建Orleans。 官方构建 最新的稳定，生产质量发布 在这里 . 夜间生成发布到 https://dotnet.myget.org/gallery/orleans-ci . 这些构建通过了所有的功能测试，但是没有像发布到NuGet的稳定版本或预发布版本那样进行彻底测试。 在项目中使用夜间构建包 要在项目中使用夜间生成，请使用以下任一方法添加MyGet提要： 更改.csproj文件以包含此节： <RestoreSources> $(RestoreSources); https://dotnet.myget.org/F/orleans-ci/api/v3/index.json; </RestoreSources> 或 创建 NuGet.config文件 包含以下内容的解决方案目录中的文件： <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <clear /> <add key=\"orleans-ci\" value=\"https://dotnet.myget.org/F/orleans-ci/api/v3/index.json\" /> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> </configuration> 社区 提问方式 在GitHub上打开问题 或者在 堆栈溢出 在Gitter上聊天 Orleans博客 跟随 @Orleans小姐 Orleans公告的Twitter帐户。 OrleansContrib-面向Orleans社区附加组件的GitHub组织 各种社区项目，包括监视、设计模式、存储提供程序等。 开发人员希望 为Orleans贡献代码更改 . 我们还鼓励您报告错误或通过启动新的 会话 在GitHub上。 许可证 本项目根据 MIT license . 快速链接 Microsoft研究项目主页 技术报告： 可编程性和可扩展性的分布式虚拟参与者 Orleans文件 贡献 Orleans的起源 Orleans创建于 微软研究并设计用于云计算 . 自2011年以来，它已被多家微软产品集团广泛应用于云计算和内部部署，其中最著名的是游戏工作室，如343 Industries和联盟作为Halo 4和5、Gears of War 4背后的云服务平台，以及其他一些。 Orleans于2015年1月开放源码，吸引了许多开发商成立 是.NET生态系统中最具活力的开源社区之一 . 在开发人员社区和微软Orleans团队的积极合作中，每天都会添加和改进特性。微软研究院继续与Orleans团队合作，推出新的主要功能，如 地理分布 , 索引 ，和 分布式事务 ，推动了最新技术的发展。对于许多.NET开发人员来说，Orleans已经成为构建分布式系统和云服务的首选框架。"
  },
  "index.html": {
    "href": "index.html",
    "title": "Orleans是一个跨平台框架，用于构建健壮，可扩展的分布式应用程序 | Microsoft Orleans 中文文档",
    "keywords": "Orleans是一个跨平台框架，用于构建健壮，可扩展的分布式应用程序 Orleans建立在.NET开发人员生产力的基础上，并将其带入了分布式应用程序的世界，例如云服务。 Orleans可从单个本地服务器扩展到云中全局分布的高可用性应用程序。 Orleans采用了对象，接口，async/await和try/catch等熟悉的概念，并将其扩展到多服务器环境。这样，它可以帮助具有单服务器应用程序经验的开发人员过渡到构建弹性，可扩展的云服务和其他分布式应用程序。因此，Orleans通常被称为“分布式.NET”。 它是由 Microsoft Research 创建的，并介绍了 Virtual Actor Model 作为一种新方法来构建面向云时代的新一代分布式系统。 Orleans的核心贡献是它的编程模型，它在不限制功能，以及对开发人员施加繁重约束的情况下，降低了高并发分布式系统固有的复杂性。 文档位于 此处 。 文档说明 Orleans中文文档，是通过机器翻译，加上人工校对而成，因为个人精力有限，校对工作目前只做了一部分，但会继续利用闲暇时间做下去，也欢迎各位读者积极参与进来。 中文文档目前位于个人仓库 sheng-jie/orleans docs分支的zh-cn目录下 ，其中1.5下的文件夹未翻译。 一些专业术语因无合适翻译予以保留，例如：Orleans，Silo，Grain，Actor 等等。 计划是在维护一段时间后，文档翻译通顺后再提PR合并到Orlans官方仓库下。 [doc] Multiple language support 。 如有兴趣加入Orleans中国社区交流群，可以扫码加我微信，我邀请您进群。 贡献指引 感谢您的参与，主要有两种方式可以参与到文档改进中： 点击文档网页右上方 [Improve this Doc] 链接，即可打开GitHub中对应当前文档的原生Markdown页面，再点击页面上的[🖍]铅笔图标，即可进行在线修改，修改完毕，提交创建PR即可。 Fork仓库 sheng-jie/orleans 并Clone到本地目录，签出docs分支（ checkout docs ），进入 zh-cn 目录，即可修改，修改完毕后，创建PR即可。"
  },
  "1.5/Documentation/Deployment-and-Operations/Troubleshooting-Deployments.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Troubleshooting-Deployments.html",
    "title": "Troubleshooting Deployments | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Troubleshooting Deployments This page gives some general guidelines for troubleshooting any issues that occur while deploying to Azure Cloud Services. These are very common issues to watch out for. Be sure to check the logs for more information. Getting a SiloUnavailableException First check to make sure that you are actually starting the silos before attempting to initialize the client. Sometimes the silos take a long time to start so it can be beneficial to try to initialize the client multiple times. If it still throws an exception, then there might be another issue with the silos. Check the silo configuration and make sure that the silos are starting up properly. Common Connection String Issues Using the local connection string when deploying to Azure – the website will fail to connect Using different connection strings for the silos and the front end (web and worker roles) – the website will fail to initialize the client because it cannot connect to the silos The connection string configuration can be checked in the Azure Portal. The logs may not display properly if the connection strings are not set up correctly. Modifying the Configuration Files Improperly Make sure that the proper endpoints are configured in the ServiceDefinition.csdef file or else the deployment will not work. It will give errors saying that it cannot get the endpoint information. Missing Logs Make sure that the connection strings are set up properly. It is likely that the Web.config file in the web role or the app.config file in the worker role were modified improperly. Incorrect versions in these files can cause issues with the deployment. Be careful when dealing with updates. Version Issues Make sure that the same version of Orleans is used in every project in the solution. Not doing this can lead to the worker role recycling. Check the logs for more information. Visual Studio provides some silo startup error messages in the deployment history. Role Keeps Recycling Check that all the appropriate Orleans assemblies are in the solution and have Copy Local set to True. Check the logs to see if there is an unhandled exception while initializing. Make sure that the connection strings are correct. Check the Azure Cloud Services troubleshooting pages for more information. How to Check Logs Use the cloud explorer in Visual Studio to navigate to the appropriate storage table or blob in the storage account. The WADLogsTable is a good starting point for looking at the logs. You might only be logging errors. If you want informational logs as well, you will need to modify the configuration to set the logging severity level. Programmatic configuration: When creating a ClusterConfiguration object, set config.Defaults.DefaultTraceLevel = Severity.Info . When creating a ClientConfiguration object, set config.DefaultTraceLevel = Severity.Info . Declarative configuration: Add <Tracing DefaultTraceLevel=\"Info\" /> to the OrleansConfiguration.xml and/or the ClientConfiguration.xml files. In the diagnostics.wadcfgx file for the web and worker roles, make sure to set the scheduledTransferLogLevelFilter attribute in the Logs element to Information , as this is an additional layer of trace filtering that defines which traces are sent to the WADLogsTable in Azure Storage. You can find more information about this in the Configuration Guide . Compatibility with ASP.NET The razor view engine included in ASP.NET uses the same code generation assemblies as Orleans ( Microsoft.CodeAnalysis and Microsoft.CodeAnalysis.CSharp ). This can present a version compatibility problem at runtime. To resolve this, try upgrading Microsoft.CodeDom.Providers.DotNetCompilerPlatform (this is the NuGet package ASP.NET uses to include the above assemblies) to the latest version, and setting binding redirects like this: <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "1.5/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html",
    "title": "Getting Started using Azure Web Apps | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Getting Started using Azure Web Apps If you would like to connect to an Azure Silo from an Azure Web App rather than a Web Role hosted within the same cloud service you can. For this to work securely you will need to assign both the Azure Web App and the Worker Role hosting the Silo to an Azure Virtual Network . First we'll setup the Azure Web App, you can follow this guide which will create the virtual network and assign it to the Azure Web App. Now we can assign the cloud service to the virtual network by modifying the ServiceConfiguration file. <NetworkConfiguration> <VirtualNetworkSite name=\"virtual-network-name\" /> <AddressAssignments> <InstanceAddress roleName=\"role-name\"> <Subnets> <Subnet name=\"subnet-name\" /> </Subnets> </InstanceAddress> </AddressAssignments> </NetworkConfiguration> Also make sure the Silo endpoints are configured. <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> Finally, you need to specify the same deployment id for Silos and the Web App Client. You can now use the GrainClient to make a connection from the Web App to the Silo. Potential Issues If the Web App is having difficulty connecting to the Silo: Make sure you have at least two roles , or two instances of one role in your Azure Cloud Service, or the InternalEndpoint firewall rules may not be generated. Check that both the Web App and the Silo are using the same DeploymentId . Make sure the network security group is set up to allow internal virtual network connections. If you haven't got one you can create and assign one easily using the following PowerShell : New-AzureNetworkSecurityGroup -Name \"Default\" -Location \"North Europe\" Get-AzureNetworkSecurityGroup -Name \"Default\" | Set-AzureNetworkSecurityGroupToSubnet -VirtualNetworkName \"virtual-network-name\" -SubnetName \"subnet-name\""
  },
  "1.5/Documentation/Deployment-and-Operations/Service-Fabric.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Service-Fabric.html",
    "title": "Service Fabric Hosting | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Service Fabric Hosting Overview Orleans can be hosted on Service Fabric. There are currently two points of integration with Service Fabric: Hosting : Silos can be hosted on Service Fabric inside of a Service Fabric Reliable Service. Silos should be hosted as unpartitioned, stateless services since Orleans manages distribution of grains itself using fine-grained, dynamic distribution. Other hosting options (partitioned, stateful) are currently untested and unsupported. Clustering (beta): Silos and clients can leverage Service Fabric's Service Discovery mechanisms to form clusters. This option requires Service Fabric Hosting, however Service Fabric Hosting does not require Service Fabric Clustering. A sample which demonstrates hosting and clustering is present at Samples/ServiceFabric . Hosting Hosting support is available in the Microsoft.Orleans.Hosting.ServiceFabric package. It allows an Orleans Silo to run as a Service Fabric ICommunicationListener . The Silo lifecycle follows the typical communication listener lifecycle: it is initialized via the ICommunicationListener.OpenAsync method and is gracefully terminated via the ICommunicationListener.CloseAsync method or abruptly terminated via the ICommunicationListener.Abort method. OrleansCommunicationListener provides the ICommunicationListener implementation. The recommended approach is to create the communication listener using OrleansServiceListener.CreateStateless(Action<StatelessServiceContext, ISiloHostBuilder> configure) in the Orleans.Hosting.ServiceFabric namespace. This ensures that the listener has the endpoint name required by Clustering (described below). Each time the communication listener is opened, the configure delegate passed to CreateStateless is invoked to configure the new Silo. Hosting can be used in conjunction with the Service Fabric Clustering provider, however other clustering providers can be used instead. Example: Configuring Service Fabric hosting. The following example demonstrates a Service Fabric StatelessService class which hosts an Orleans silo. The full sample can be found in the Samples/ServiceFabric directory of the Orleans repository. internal sealed class StatelessCalculatorService : StatelessService { public StatelessCalculatorService(StatelessServiceContext context) : base(context) { } protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners() { // Listeners can be opened and closed multiple times over the lifetime of a service // instance. A new Orleans silo will be both created and initialized each time the // listener is opened and will be shutdown when the listener is closed. var listener = OrleansServiceListener.CreateStateless( (serviceContext, builder) => { // Optional: use Service Fabric for cluster membership. builder.UseServiceFabricClustering(serviceContext); // Alternative: use Azure Storage for cluster membership. builder.UseAzureTableMembership(options => { /* Configure connection string*/ }); // Optional: configure logging. builder.ConfigureLogging(logging => logging.AddDebug()); var config = new ClusterConfiguration(); config.Globals.RegisterBootstrapProvider<BootstrapProvider>(\"poke_grains\"); config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.ReminderTableGrain; // Service Fabric manages port allocations, so update the configuration using // those ports. config.Defaults.ConfigureServiceFabricSiloEndpoints(serviceContext); // Tell Orleans to use this configuration. builder.UseConfiguration(config); // Add your application assemblies. builder.ConfigureApplicationParts(parts => { parts.AddApplicationPart(typeof(CalculatorGrain).Assembly).WithReferences(); // Alternative: add all loadable assemblies in the current base path // (see AppDomain.BaseDirectory). parts.AddFromApplicationBaseDirectory(); }); }); return new[] { listener }; } protected override async Task RunAsync(CancellationToken cancellationToken) { while (true) { cancellationToken.ThrowIfCancellationRequested(); await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken); } } } Clustering (beta) Note: it is currently recommended to use a storage-backed clustering provider such as SQL, ZooKeeper, Consul, or Azure Tables in production while this feature is in beta. Support to use Service Fabric's Service Discovery (Naming Service) mechanism for cluster membership is available in the Microsoft.Orleans.Clustering.ServiceFabric package. The implementation requires that the Service Fabric Hosting support is also used and that the Silo endpoint is named \"Orleans\" in the value returned from StatelessService.CreateServiceInstanceListeners() . The simplest way to ensure this is to use the OrleansServiceListener.CreateStateless(...) method as described in the previous section. Service Fabric Clustering is enabled with the ISiloHostBuilder.UseServiceFabricClustering(ServiceContext) extension method on the silo and the IClientBuilder.UseServiceFabricClustering(Uri) extension method on the client. The current recommendation is to use a storage-backed clustering provider for production services, such as SQL, ZooKeeper, Consul, or Azure Storage. These providers (particularly SQL and Azure Storage) are sufficiently well tested for production use."
  },
  "1.5/Documentation/Orleans-Streams/Streams-Quick-Start.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Quick-Start.html",
    "title": "Orleans Streams Quick Start | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Quick Start This guide will show you a quick way to setup and use Orleans Streams. To learn more about the details of the streaming features, read other parts of this documentation. Required Configurations In this guide we'll use a Simple Message based Stream which uses grain messaging to send stream data to subscribers. We will use the in-memory storage provider to store lists of subscriptions so it is not a wise choise for real production applications. <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"PubSubStore\" /> </StorageProviders> <StreamProviders> <Provider Type=\"Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider\" Name=\"SMSProvider\"/> </StreamProviders> Now we can create streams, send data using them as producers and also receive data as subscribers. Producing Events Producing events for streams is relatively easy. You should first get access to the stream provider which you defined in the config above ( SMSProvider ) and then choose a stream and push data to it. //Pick a guid for a chat room grain and chat room stream var guid = some guid identifying the chat room //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); As you can see our stream has a GUID and a namespace. This will make it easy to identify unique streams. For example, in a chat room namespace can \"Rooms\" and GUID be the owning RoomGrain's GUID. Here we use the GUID of some known chat room. Now using the OnNext method of the stream we can push data to it. Let's do it inside a timer and using random numbers. You could use any other data type for the stream as well. RegisterTimer(s => { return stream.OnNextAsync(new System.Random().Next()); }, null, TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000)); Subscribing and receiving streaming data For receiving data we can use implicit/explicit subscriptions, which are fully described in other pages of the manual. Here we use implicit subscriptions which are easier. When a grain type wants to implicitly subscribe to a stream it uses the attribute ImplicitStreamSubscription (namespace)] . For our case we'll define a ReceiverGrain like this: [ImplicitStreamSubscription(\"RANDOMDATA\")] public class ReceiverGrain : Grain, IRandomReceiver Now whenever some data is pushed to the streams of namespace RANDOMDATA as we have in the timer, a grain of type ReceiverGrain with the same guid of the stream will receive the message. Even if no activations of the grain currently exist, the runtime will automatically create a new one and send the message to it. In order for this to work however, we need to complete the subscription process by setting our OnNext method for receiving data. So our ReceiverGrain should call in its OnActivateAsync something like this //Create a GUID based on our GUID as a grain var guid = this.GetPrimaryKey(); //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); //Set our OnNext method to the lambda which simply prints the data, this doesn't make new subscriptions await stream.SubscribeAsync<int>(async (data, token) => Console.WriteLine(data)); We are all set now. The only requirement is that something triggers our producer grain's creation and then it will registers the timer and starts sending random ints to all interested parties. Again, this guide skips lots of details and is only good for showing the big picture. Read other parts of this manual and other resources on RX to gain a good understanding on what is available and how. Reactive programming can be a very powerful approach to solve many problems. You could for example use LINQ in the subscriber to filter numbers and do all sorts of interesting stuff. Next Orleans Streams Programming APIs"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Extensibility.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Extensibility.html",
    "title": "Orleans Streams Extensibility | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Extensibility There are three ways developers can extend the currently implemented behaviour of Orleans Streaming: Utilize or extend Stream Provider Configuration. Write a Custom Queue Adapter. Writ a New Stream Provider We will describe those below. Please read the Orleans Streams Implementation before reading this section to have a high level view of the internal implementation. Stream Provider Configuration Currently implemented stream providers support a number of configuration options. Simple Message Stream Provider Configuration . SMS Stream Provider currently supports only a single configuration option: FireAndForgetDelivery : this option specifies if the messages sent by SMS stream producer are sent as fire and forget without the way to know if they were delivered or not. When FireAndForgetDelivery is set to false (messages are sent not as FireAndForget), the stream producer's call stream.OnNext() returns a Task that represents the processing status of the stream consumer. If this Task succeeds, the producer knows for sure that the message was delivered and processed successfully. If FireAndForgetDelivery is set to true, the returned Task only expresses that the Orleans runtime has accepted the message and queued it for further delivery. The default value for FireAndForgetDelivery is false. Persistent Stream Provider Configuration . All persistent stream providers support the following configuration options: GetQueueMessagesTimerPeriod - how much time the pulling agents wait after the last attempt to pull from the queue that did not return any items before the agent attempts to pull again. Default is 100 milliseconds. InitQueueTimeout - how much time the pulling agents waits for the adapter to initialize the connection with the queue. Default is 5 seconds. QueueBalancerType - the type of balancing algorithm to be used to balance queues to silos and agents. Default is ConsistentRingBalancer. Azure Queue Stream Provider Configuration . Azure Queue stream provider supports the following configuration options, in addition to what is supported by Persistent Stream Provider: DataConnectionString - the Azure Queue storage connection string. DeploymentId - the deployment id of this Orleans cluster (usually similar to Azure Deployment Id). CacheSize - the size of the persistent provider cache that is used to store stream message for further delivery. Default is 4096. It would be totally possible and a lot of times easy to provide additional configuration options. For example, in some scenarios developers might want more control over queue names used by the Queue Adapter. This is currently abstracted away with IStreamQueueMapper , but there is currently no way to configure which IStreamQueueMapper to use without writing a new code. We would be happy to provide such an option, if needed. So please consider adding more configuration options to existing stream providers before writing a completely new provider. Writing a Custom Queue Adapter If you want to use a different queueing technology, you need to write a queue adapter that abstracts away the access to that queue. Below we provide details on how this should be done. Please refer to AzureQueueAdapterFactory for an example. Start by defining a MyQueueFactory class that implements IQueueAdapterFactory . You need to: a. Initialize the factory: read the passed config values, potentially allocate some data structures if you need to, etc. b. Implement a method that returns your IQueueAdapter . c. Implement a method that returns IQueueAdapterCache . Theoretically, you can build your own IQueueAdapterCache , but you don't have to. It is a good idea just to allocate and return an Orleans SimpleQueueAdapterCache . d. Implement a method that returns IStreamQueueMapper . Again, it is theoretically possible to build your own IStreamQueueMapper , but you don't have to. It is a good idea just to allocate and return an Orleans HashRingBasedStreamQueueMapper . Implement MyQueueAdapter class that implements the IQueueAdapter interface, which is an interfaces that manages access to a sharded queue . IQueueAdapter manages access to a set of queues/queue partitions (those are the queues that were returned by IStreamQueueMapper ). It provides an ability to enqueue a message in a specified the queue and create an IQueueAdapterReceiver for a particular queue. Implement MyQueueAdapterReceiver class that implements the IQueueAdapterReceiver , which is an interfaces that manages access to one queue (one queue partition) . In addition to initialization and shutdown, it basically provides one method: retrieve up to maxCount messages from the queue. Declare public class MyQueueStreamProvider : PersistentStreamProvider<MyQueueFactory> . This is your new Stream Provider. Configuration : in order to load and use you new stream provider you need to configure it properly via silo config file. If you need to use it on the client, you need to add a similar config element to the client config file. It is also possible to configure the stream provider programmatically. Below is an example of silo configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StreamProviders> <Provider Type=\"My.App.MyQueueStreamProvider\" Name=\"MyStreamProvider\" GetQueueMessagesTimerPeriod=\"100ms\" AdditionalProperty=\"MyProperty\"/> </StreamProviders> </Globals> </OrleansConfiguration> Writing a Completely New Stream Provider It is also possible to write a completely new Stream Provider. In such a case there is very little integration that needs to be done from Orleans perspective. You just need to implement the IStreamProviderImpl interface, which is a thin interface that allows application code to get a handle to the stream. Beyond that, it is totally up to you how to implement it. Implementing a completely new Stream Provider might turn to be a rather complicated task, since you might need access to various internal runtime components, some of which may have internal access. We currently do not envision scenarios where one would need to implement a completely new Stream Provider and could not instead achieve his goals through the two options outlined above: either via extended configuration or by writing a Queue Adapter. However, if you think you have such a scenario, we would like to hear about it and work together on simplifying writing new Stream Providers."
  },
  "1.5/Documentation/Orleans-Streams/Streams-Programming-APIs.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Programming-APIs.html",
    "title": "Orleans Streams Programming APIs | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Programming APIs Applications interact with streams via APIs that are very similar to the well known Reactive Extensions (Rx) in .NET . The main difference is that Orleans stream extensions are asynchronous , to make processing more efficient in Orleans' distributed and scalable compute fabric. Async Stream An application starts by using a stream provider to get a handle to a stream. You can read more about stream providers here , but for now you can think of it as stream factory that allows implementers to customize streams behavior and semantics: IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(Guid, \"MyStreamNamespace\"); Application can get a reference to the stream provider either by calling the GetStreamProvider method on the Grain class when inside a grain, or by calling GrainClient.GetStreamProvider() method when on the client. Orleans.Streams.IAsyncStream<T> is a logical, strongly-typed handle to a virtual stream . It is similar in spirit to Orleans Grain Reference. Calls to GetStreamProvider and GetStream are purely local. The arguments to GetStream are a GUID and an additional string that we call a stream namespace (which can be null). Together the GUID and the namespace string comprise the stream identity (similar in sprit to the arguments to GrainFactory.GetGrain ). The combination of GUID and namespace string provide extra flexibility in determining stream identities. Just like grain 7 may exist within the Grain type PlayerGrain and a different grain 7 may exist within the grain type ChatRoomGrain , Stream 123 may exist with the stream namespace PlayerEventsStream and a different stream 123 may exist within the stream namespace ChatRoomMessagesStream . Producing and Consuming IAsyncStream<T> implements both Orleans.Streams.IAsyncObserver<T> and Orleans.Streams.IAsyncObservable<T> interfaces. That way an application can use the stream either to produce new events into the stream by using Orleans.Streams.IAsyncObserver<T> or to subscribe to and consume events from a stream by using Orleans.Streams.IAsyncObservable<T> . public interface IAsyncObserver<in T> { Task OnNextAsync(T item, StreamSequenceToken token = null); Task OnCompletedAsync(); Task OnErrorAsync(Exception ex); } public interface IAsyncObservable<T> { Task<StreamSubscriptionHandle<T>> SubscribeAsync(IAsyncObserver<T> observer); } To produce events into the stream, an application just calls await stream.OnNextAsync<T>(event) To subscribe to a stream, an application calls StreamSubscriptionHandle<T> subscriptionHandle = await stream.SubscribeAsync(IAsyncObserver) The argument to SubscribeAsync can either be an object that implements the IAsyncObserver interface or a combination of lambda functions to process incoming events. More options for SubscribeAsync are available via AsyncObservableExtensions class. SubscribeAsync returns a StreamSubscriptionHandle<T> , which is an opaque handle that can be used to unsubscribe from the stream (similar in spirit to an asynchronous version of IDisposable ). await subscriptionHandle.UnsubscribeAsync() It is important to note that the subscription is for a grain, not for an activation . Once the grain code subscribed to the stream, this subscription surpasses the life of this activation and stays durable forever, until the grain code (potentially in a different activation) explicitly unsubscribes. This is the heart of a virtual stream abstraction : not only all the streams always exists, logically, but also that a stream subscription is durable and lives beyond a particular physical activation that issued this subscription. Multiplicity An Orleans stream may have multiple producers and multiple consumers. A message published by a producer will be delivered to all consumers that were subscribed to the stream before the message was published. In addition, the consumer can subscribe to the same stream multiple times. Each time it subscribes it gets back a unique StreamSubscriptionHandle<T> . If a grain (or client) is subscribed X times to the same stream, it will receive the same event X times, once for each subscription. The consumer can also unsubscribe from an individual subscription or find out all its current subscriptions, by calling: IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() Recovering From Failures If the producer of a stream dies (or its grain is deactivated), there is nothing it needs to do. Next time this grain wants to produce more events it can get the stream handle again and produce new events in the same way. Consumer logic is a little bit more involved. As we said before, once consumer grain subscribed to a stream, this subscription is valid until it explicitly unsubscribes. If the consumer of the stream dies (or its grain is deactivated) and new event is generated on the stream, the consumer grain will be automatically re-activated (just like any regular Orleans grain is automatically activated upon message to it). The only thing that the grain code needs to do now is to provide a IAsyncObserver<T> to process the data. The consumer basically need to re-attach processing logic as part of OnActivateAsync method. To do that it can call: StreamSubscriptionHandle<int> newHandle = await subscriptionHandle.ResumeAsync(IAsyncObserver) The consumer uses the previous handle it got when it first subscribed in order to \"resume processing\". Notice that ResumeAsync merely updates an existing subscription with the new instance of IAsyncObserver logic and does not change the fact that this consumer is already subscribed to this stream. How the consumer has an old subscriptionHandle? There are 2 options. The consumer may have persisted the handle it was given back from the original SubscribeAsync operation and can use it now. Alternatively, if the consumer does not have the handle, it can ask the IAsyncStream<T> for all its active subscription handles, by calling: IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() The consumer can now resume all of them, or unsubscribe from some if he wishes to. COMMENT: If the consumer grain implements the the IAsyncObserver interface directly ( public class MyGrain<T> : Grain, IAsyncObserver<T> ), it should in theory not be required to re-attach the IAsyncObserver and thus will not need to call ResumeAsync . The streaming runtime should be able to automatically figure out that the grain already implements IAsyncObserver and will just invoke those IAsyncObserver methods. However, the streaming runtime currently does not support this and the grain code still needs to explicitly call ResumeAsync , even if the grain implements IAsyncObserver directly. Supporting this is on our TODO list. Explicit and Implicit Subscriptions By default, stream consumer has to explicitly subscribe to the stream. This subscription would usually be triggered by some external message that the grain (or client) receive that instructs them to subscribe. For example, in a chat service when user joins a chat room his grain receives a JoinChatGroup message with the chat name and it will cause the user grain to subscribe to this chat stream. In addition, Orleans Streams also support \"Implicit Subscriptions\" . In this model the grain does not explicitely subscribe to the stream. This grain is subscribed automatically, implicitly, just based on its grain identity and an ImplicitStreamSubscription attribute. Implicit subscriptions main value is allowing the stream activity to trigger the grain activation (hence triggering the subscription) automaticaly. For example, using SMS streams, if one grain wanted to produce a stream and another grain process this stream, the producer would need to know the identity of the consumer grain and make a grain call to it telling it to subscribe to the stream. Only after that it can start sending events. Instead, using implicit subscriptions, the producer can just start producing events onto a stream, and the consumer grain will automatically be activated and subscribe to the stream. In that case, the producer doesn't care at all who is reading the events Grain implementation class of type MyGrainType can declare an attribute [ImplicitStreamSubscription(\"MyStreamNamespace\")] . This tells the streaming runtime that when an event is generated on a stream whose identity is GUID XXX and \"MyStreamNamespace\" namespace, it should be delivered to grain whose identity is XXX of type MyGrainType . That is, the runtime maps stream <XXX, MyStreamNamespace> to consumer grain <XXX, MyGrainType> . The presence of ImplicitStreamSubscription causes the streaming runtime to automatically subscribe this grain to a stream and deliver the stream events to it. However, the grain code still needs to tell the runtime how it wants events to be processed. Essentially, it need to attach the IAsyncObserver . Therefore, when the grain is activated, the grain code inside OnActivateAsync needs to call: IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(this.GetPrimaryKey(), \"MyStreamNamespace\"); StreamSubscriptionHandle<T> subscription = await stream.SubscribeAsync(IAsyncObserver<T>); Writing Subscription Logic Below are the guidelines on how to write the subscription logic for various cases: explicit and implicit subscriptions, rewindable and non-rewindable streams. The main difference between explicit and implicit subscriptions is that for implicit the grain always has exactly one implicit subscription for every stream namespace, there is no way to create multiple subscriptions (there is no subscription multiplicity), there is no way to unsubscribe, and the grain logic always only needs to attach the processing logic. That also means that for implicit subscriptions there is never a need to Resume a subscription. On the other hand, for explicit subscriptions, one needs to Resume the subscription, otherwise if the grain subscribes again it will result in the grain being subscribed multiple times. Implicit Subscriptions: For implicit subscriptions the grain needs to subscribe to attach the processing logic. This should be done in the grain's OnActivateAsync method. The grain should simply execute await stream.SubscribeAsync(OnNext ...) in its OnActivateAsync method. That will cause this particular activation to attach the OnNext function to process that stream. The grain can optionally specify the StreamSequenceToken as an argument to SubscribeAsync , which will cause this implicit subscription to start consuming from that token. There is never a need for implicit subscription to call ResumeAsync . public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); await stream.SubscribeAsync(OnNextAsync) } Explicit Subscriptions: For explicit subscriptions, a grain must call SubscribeAsync to subscribe to the stream. This creates a subscription, as well as attaches the processing logic. The explicit subscription will exist until the grain unsubscribes, so if a grain gets deactivated and reactivated, the grain is still explicitly subscribed, but no processing logic will be attached. In this case the grain needs to re-attach the processing logic. To do that, in its OnActivateAsync , the grain first needs to find out what subscriptions it has, by calling stream.GetAllSubscriptionHandles() . The grain must execute ResumeAsync on each handle it wishes to continue processing or UnsubscribeAsync on any handles it is done with. The grain can also optionally specify the StreamSequenceToken as an argument to the ResumeAsync calls, which will cause this explicit subscription to start consuming from that token. public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); var subscriptionHandles = await stream.GetAllSubscriptionHandles(); if (!subscriptionHandles.IsNullOrEmpty()) subscriptionHandles.ForEach(async x => await x.ResumeAsync(OnNextAsync)); } Stream Order and Sequence Tokens The order of events delivery between an individual producer and an individual consumer depends on a stream provider. With SMS the producer explicitly controls the order of events seen by the consumer by controlling the way he publishes them. By default (if the FireAndForget options for SMS provider is set to false) and if the producer awaits every OnNextAsync call, the events arrive in FIFO order. In SMS it is up to the producer to decide how to handle delivery failures that will be indicated by a broken Task returned by the OnNextAsync call. Azure Queue streams do not guarantee FIFO order, since the underlying Azure Queues do not guarantee order in failure cases (they do guarantee FIFO order in failure free executions). When a producer produces the event into Azure Queue, if the enqueue operation failed, it is up to the producer to attempt another enqueue and later on deal with potential duplicates messages. On the delivery side, Orleans Streaming runtime dequeues the event from the Azure Queue and attempts to deliver it for processing to consumers. Orleans Streaming runtime deletes the event from the queue only upon successful processing. If the delivery or processing failed, the event is not delete from the queue and will automatically re-appear in the queue much later. The Streaming runtime will try to deliver it again, thus potentially breaking the FIFO order. The described behaivour matches the regular semantics of Azure Queues. Application Defined Order : To deal with the above ordering issues, application can optionally specify its own ordering. This is achived via a notion of StreamSequenceToken . StreamSequenceToken is an opaque IComparable object that can be used to order events. A producer can pass an optional StreamSequenceToken to the OnNext call. This StreamSequenceToken will be passed all the way to the consumer and will be delivered together with the event. That way, application can reason and reconstruct it's order independently from the streaming runtime. Rewindable Streams Some streams only allow application to subscribe to them starting at the latest point in time, while other streams allow \"going back in time\". The latter capability is dependent on the underlying queuing technology and the particular stream provider. For example, Azure Queues only allow consuming the latest enqueued events, while EventHub allows replaying events from an arbitrary point in time (up to some expiration time). Streams that support going back in time are called Rewindable Streams . The consumer of a rewindable stream can pass a StreamSequenceToken to the SubscribeAsync call and the runtime will deliver events to it starting from that StreamSequenceToken (a null token means the consumer wants to receive events starting from the latest). The ability to rewind a stream is very useful in recovery scenarios. For example, consider a grain that subscribes to a stream and periodically checkpoints its state together with the latest sequence token. When recovering from a failure, the grain can re-subscribe to the same stream from the latest checkpointed sequence token, thereby recovering without losing any events that were generated since the last checkpoint. Event Hubs provider is rewindable. You can find its code here . SMS and Azure Queue providers are not rewindable. Stateless Automatically Scaled-Out Processing By default Orleans Streaming is targeted to support a large number of relatively small streams, each is processed by one or more statefull grains. Collectively, the processing of all the streams together is sharded among a large number of regular (statefull) grains. The application code controls this sharding by assigning stream ids, grain ids and explicitly subscribing. The goal is sharded statefull processing . However, there is also an interesting scenario of automatically scaled-out stateless processing . In this scenario application has a small number of streams (or even one large stream) and the goal is stateless processing. For example, a global stream of all messages for all events and the processing involving some kind of decoding/deciphering and potentially forwarding them for further statefull processing into another set of streams. The stateless scaled-out stream processing can be supported in Orleans via StatelessWorker grains. Current Status of Stateless Automatically Scaled-Out Processing: This is currently not implemented (due to priority constrains). An attempt to subscribe to a stream from a StatelessWorker grain will result in undefined behavior. We are currently considering to support this option . Grains and Orleans Clients Orleans streams work uniformly across grains and Orleans clients . That is, exactly the same APIs can be used inside a grain and in an Orleans client to produce and consume events. This greatly simplifies the application logic, making special client-side APIs, such as Grain Observers, redundant. Fully Managed and Reliable Streaming Pub-Sub To track stream subscriptions, Orleans uses a runtime component called Streaming Pub-Sub which serves as a rendezvous point for stream consumers and stream producers. Pub Sub tracks all stream subscriptions, persists them, and matches stream consumers with stream producers. Applications can choose where and how the Pub-Sub data is stored. The Pub-Sub component itself is implemented as grains (called PubSubRendezvousGrain ) and it is using Orleans Declarative Persistence for those grain. PubSubRendezvousGrain uses storage provider named PubSubStore . As with any grain, you can designate an implementation for a storage provider. For Streaming Pub-Sub you can change the implementation of the PubSubStore in the config file: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"PubSubStore\" /> </StorageProviders> </Globals> </OrleansConfiguration> That way Pub-Sub data will be durably stored in Azure Table. For initial development you can use the memory storage as well. In addition to the Pub-Sub, Orleans Streaming Runtime delivers events from producers to consumers, manages all runtime resources allocated to actively used streams, and transparently garbage collects runtime resources from unused streams. Configuration In order to use streams you need to enable stream providers via configuration. You can read more about stream providers here . Sample stream providers configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StreamProviders> <Provider Type=\"Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider\" Name=\"SMSProvider\"/> <Provider Type=\"Orleans.Providers.Streams.AzureQueue.AzureQueueStreamProvider\" Name=\"AzureQueueProvider\"/> </StreamProviders> </Globals> </OrleansConfiguration> It is also possible to register a stream provider programmatically, via calling one of the RegisterStreamProvider methods on the Orleans.Runtime.Configuration.GlobalConfiguration or Orleans.Runtime.Configuration.ClientConfiguration classes. public void RegisterStreamProvider(string providerTypeFullName, string providerName, IDictionary<string, string> properties = null) public void RegisterStreamProvider<T>(string providerName, IDictionary<string, string> properties = null) where T : IStreamProvider Next Orleans Stream Providers"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Why.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Why.html",
    "title": "Why Orleans Streams? | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Why Orleans Streams? There are already a wide range of technologies that allow you to build stream processing systems. Those include systems to durably store stream data (e.g., Event Hubs and Kafka ) and systems to express compute operations over stream data (e.g., Azure Stream Analytics , Apache Storm , and Apache Spark Streaming ). Those are great systems that allow you to build efficient data stream processing pipelines. Limitations of Existing Systems However, those systems are not suitable for fine-grained free-form compute over stream data . The Streaming Compute systems mentioned above all allow you to specify a unified data-flow graph of operations that are applied in the same way to all stream items . This is a powerful model when data is uniform and you want to express the same set of transformation, filtering, or aggregation operations over this data. But there are other use cases where you need to express fundamentally different operations over different data items. And in some of them as part of this processing you occasionally need to make an external call, such as invoke some arbitrary REST API. The unified data-flow stream processing engines either do not support those scenarios, support them in a limited and constrained way, or are inefficient in supporting them. This is because they are inherently optimized for a large volume of similar items, and usually limited in terms of expressiveness, processing . Orleans Streams target those other scenarios. Motivation It all started with requests from Orleans users to support returning a sequence of items from a grain method call. As you can imagine, that was only the tip of the iceberg. They actually needed much more than that. A typical scenario for Orleans Streams is when you have per user streams and you want to perform different processing for each user , within the context of an individual user. We may have millions of users but some of them are interested in weather and can subscribe to weather alerts for a particular location, while some are interested in sports events; somebody is tracking status of a particular flight. Processing those events requires different logic, but you don't want to run two independent instances of stream processing. Some users are interested in only a particular stock and only if certain external condition applies, condition that may not necessarily be part of the stream data (thus needs to be checked dynamically at runtime as part of processing). Users change their interests all the time, hence their subscriptions to specific streams of events come and go dynamically, thus the streaming topology changes dynamically and rapidly . On top of that, the processing logic per user evolves and changes dynamically as well, based on user state and external events . External events may modify the processing logic for a particular user. For example, in a game cheating detection system, when a new way to cheat is discovered the processing logic needs to be updated with the new rule to detect this new violation. This needs to be done of course without disrupting the ongoing processing pipeline . Bulk data-flow stream processing engines were not build to support such scenarios. It goes almost without saying that such a system has to run on a number of network-connected machines, not on a single node. Hence, the processing logic has to be distributed in a scalable and elastic manner across a cluster of servers. New Requirements We identified 4 basic requirements for our Stream Processing system that will allow it to target the above scenarios. Flexible stream processing logic Support for highly dynamic topologies Fine-grained stream granularity Distribution Flexible stream processing logic We want the system to support different ways of expressing the stream processing logic. The existing systems we mentioned above require the developer to write a declarative data-flow computation graph, usually by following a functional programming style. This limits the expressiveness and flexibility of the processing logic. Orleans streams are indifferent to the way processing logic is expressed. It can be expressed as a data-flow (e.g., by using Reactive Extensions (Rx) in .NET ); as a functional program; as a declarative query; or in a general imperative logic. The logic can be stateful or stateless, may or may not have side effects, and can trigger external actions. All power goes to the developer. Support for dynamic topologies We want the system to allow for dynamically evolving topologies. The existing systems we mentioned above are usually limited to only static topologies that are fixed at deployment time and cannot evolve at runtime. In the following example of a dataflow expression everything is nice and simple until you need to change it. Stream.GroupBy(x=> x.key).Extract(x=>x.field).Select(x=>x+2).AverageWindow(x, 5sec).Where(x=>x > 0.8) * Change the threshold condition in the Where filter, add an additional Select statement or add another branch in the data-flow graph and produce a new output stream. In existing systems this is not possible without tearing down the entire topology and restarting the data-flow from scratch. Practically, those systems will checkpoint the existing computation and will be able to restart from the latest checkpoint. Still, such a restart is disruptive and costly to an online service that produces results in real time. Such a restart becomes especially impractical when we are talking about a large number of such expressions being executed with similar but different (per-user, per-deveice, et.) parameters and that keep constantly changing. We want the system to allow for evolving the stream processing graph at runtime, by adding new links or nodes to the computation graph, or by changing the processing logic within the computation nodes. Fine grained stream granularity In the existing systems, the smallest unit of abstraction is usually the whole flow (topology). However, many of our target scenarios require individual node/link in the topology to be a logical entity by itself. That way each entity can be potentially managed independently. For example, in the big stream topology comprising of multiple links, different links can have different characteristics and can be implemented over different physical transports. Some links can go over TCP sockets, while others over reliable queues. Different links can have different delivery guarantees. Different nodes can have different checkpointing strategies, and their processing logic can be expressed in different models or even different languages. Such flexibility is usually not possible in existing systems. The unit of abstraction and flexibility argument is similar to comparison of SoA (Service Oriented Architectures) vs. Actors. Actor systems allow more flexibility, since each is essentially an independently managed ''tiny service''. Similarly, we want the system to allow for such a fine grained control. Distribution And of course, our system should have all the properties of a \"good distributed system\" . That includes: Scalability - supports large number of streams and compute elements. Elasticity - allows to add/remove resources to grow/shrink based on load. Reliability - be resilient to failures Efficiency - use the underlying resources efficiently Responsiveness - enable near real time scenarios. These were the requirements we had in mind for building Orleans Streaming . Clarificaton : Orleans currently does not directly support writing declarative dataflow expressions like in the example above. The current Orleans Streaming APIs are more low level building blocks, as described here . Providing declarative dataflow expressions is our future goal. Next Orleans Streams Programming APIs"
  },
  "1.5/Documentation/Samples-Overview/Storage-Providers.html": {
    "href": "1.5/Documentation/Samples-Overview/Storage-Providers.html",
    "title": "Storage Providers | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Storage Providers Note : This sample requires the \"Official MongoDB C# Driver\" NuGet package from 10gen, Inc. If you want to run the sample and store data using MongoDB, you will also need to download and install MongoDB. Custom storage providers allow you to extend the capabilities of Orleans to store application data in new storage services. In this sample, we have code to store data in a file system (presumably networked) and in MongoDB. While binary formatting is almost always better to use for persistent storage, this sample chooses to use JSON as the external format for one reason: it's easier to read and verify, which is a good thing in a sample. As you adopt the sample code for more realistic use, you will probably want to switch to something else than JSON as the external format. Running the sample The sample solution consists of four projects -- the storage provider library, and three test libraries, with the same client+server structure that the Hello World sample has. Edit the DevTestServerConfiguration.xml file in the Test.Client project, uncommenting the element of the file-storage provider. <!-- To test the sample storage providers, uncomment one of the following two lines: <Provider Type=\"Samples.StorageProviders.MongoDBStorage\" Name=\"TestStore\" Database=\"orleanssamples\" ConnectionString=\"mongodb://localhost:27017/\" /> --> <Provider Type=\"Samples.StorageProviders.OrleansFileStorage\" Name=\"TestStore\" RootDirectory=\".\\Samples.FileStorage\"/> Build the solution. This will move everything where it needs to go, including the MongoDB client libraries that NuGet brought in. Set the 'Test.Client' project as the startup project and hit F5. Right before it stops spitting out text, it will have this to say: Successfully started Orleans silo 'host-001' as a Primary node. We just wrote something to the persistent store. Please verify! Orleans Silo is running. Press Enter to terminate... Stop the program and open a command line windows, move to the bin\\Debug folder of the Test.Client project. There should be a folder called Samples.FileStorage there. In that folder, you should find a single file: >>dir Directory: c:\\Orleans\\Samples\\StorageProviders\\Test.Client\\bin\\Debug\\Samples.FileStorage Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 3/26/2014 19:50 48 0000...003ffffffc0950639.PersonState If you look at the contents of that file, you should see some JSON text: >> more .\\Samples.FileStorage\\0000000000000000000000000000000003ffffffc0950639.PersonState {\"FirstName\":\"John\",\"LastName\":\"Doe\",\"Gender\":0} Now, run the program again. It's written to detect that state already exists, so this time, it will have something else to say: Successfully started Orleans silo host-001' as a Primary node. This was found in the persistent store: John, Doe, Male Orleans Silo is running. Press Enter to terminate... If you have MongoDB installed , you can repeat this procedure to test the other storage provider. Just change which XML element in the configuration file that is uncommented and ensure that the mongod.exe process is running. When you inspect the data with the MongoDB shell (mongo.exe), it should look something like this: MongoDB shell version: 2.4.6 connecting to: test > use orleanssamples switched to db orleanssamples > db.PersonState.find() { \"_id\" : ObjectId(\"533391afcf20b011307a82bf\"), \"FirstName\" : \"John\", \"LastName\" : \"Doe\", \"Gender\" : 0, \"key\" : \"0000000000000000000000000000000003ffffffc0950639\" } > Design Since both concrete storage providers use JSON, we place the serialization and deserialization code in a base class, BaseJSONStorageProvider . It contains the logic for Init() , ReadStateAsync() , WriteStateAsync() and ClearStateAsync() , the main interface methods of IStorageProvider. The logic to deal with the underlying store is delegated to a DataManager class hiearchy: IJSONStateDataManager , GrainFileStateManager , and GrainStateMongoDataManager . Their methods Delete() , Read() and Write() correspond directly to the methods defined in the storage provider classes. In this description, we won't go into the details of interacting with the file system or MongoDB via .NET, that is described in detail elsewhere. A couple of things in the code requires explanation, though. In both cases, the name of the grain type is used as name for the collection of instances; in the file storage provider case, the collection name is mapped to the folder that data is stored in, while the primary key is used to identify the actual instance; in the MongoDB case, the type name denotes a database collection, while the primary key is used as the document name. In the MongoDB case, the JSON structure is augmented during a write operation with another element, key, which contains the Orleans grain key and allows us to query for that document when reading. Care is also taken to maintain the Mongo-internal _id document identity. public Task Write(string collectionName, string key, string entityData) { var collection = GetOrCreateCollection(collectionName); var query = Query.EQ(\"key\", key); var existing = collection.FindOne(query); var doc = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(entityData); doc[\"key\"] = key; if ( existing == null ) { collection.Insert(doc); } else { doc[\"_id\"] = existing[\"_id\"]; collection.Update(query, Update.Replace(doc)); } return TaskDone.Done; } On read, the _id field is removed from the JSON document that is passed back to the caller, since that is not part of the Orleans data model. public Task<string> Read(string collectionName, string key) { var collection = GetCollection(collectionName); if (collection == null) return Task.FromResult<string>(null); var query = Query.EQ(\"key\", key); var existing = collection.FindOne(query); if (existing == null) return Task.FromResult<string>(null); existing.Remove(\"_id\"); existing.Remove(\"key\"); var strwrtr = new System.IO.StringWriter(); var writer = new MongoDB.Bson.IO.JsonWriter(strwrtr, new MongoDB.Bson.IO.JsonWriterSettings()); MongoDB.Bson.Serialization.BsonSerializer.Serialize<BsonDocument>(writer, existing); return Task.FromResult(strwrtr.ToString()); }"
  },
  "1.5/Documentation/Samples-Overview/Chirper.html": {
    "href": "1.5/Documentation/Samples-Overview/Chirper.html",
    "title": "Chirper | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Chirper A simple social network pub/sub system, with short text messages being sent between users. Publishers send out short \"Chirp\" messages (not to be confused with \"Tweets\", for a variety of legal reasons! ;) to any other users that are following them. Instructions Build Chirper.sln Start your local Silo from a command window using command file #1. The loader script, #2 Start the Chirper client #3 Start a second Chirper client as a publisher #4 Type a comment into the publisher client window, and see it displayed on the other client console window. Overview The NetworkLoader program reads a graphml data file containing a description of a network of Users and Followers. The NetworkLoader program sets up a network of ChirperAccount (aka \"users\") grains based on the input data file, one grain for each user defined in the network. It then creates the follower links between those users by calling the FollowUserId method on the appropriate user grain. For this demo, we use a simplified network of 1,000 Users with a total of 27,000 Follower links connecting those Users, but other network data files can be created with the NetworkGenerator program, or with a normal text / XML editor. The ChirperClient program connects to the Chirper network as a user specified on the cmd line. It then listens for any new Chirps that might be sent out by the other users they follow. When you type a comment into the publisher window, the text is sent as a Chirp message to all followers of that user, including the first client console window, as well as being echo'ed on the publisher's window. Why Orleans? Orleans allows the network of Chirper users to be described via very simple C# code whilst allowing it to easily scale out to handle increasing number of users and volume of chirp messages. How is it modeled? Chirper users are modeled as grains, which provides a very natural mapping of concepts. These grains allow to distribute the load for handling the message throughput, with each grain handling the forwarding of messages generated by that user to any other users that are following them. The grains implement three different grain interfaces to represent the three functional facets of those entities -- IChirperPublisher , IChirperSubscriber and IChirperAccount There is also an IChirperViewer observer interface for applications to subscribe for status changes from a particular Chirper user without becoming a Follower. This observer interface is typically used when writing client UI applications such as ChirperClient . Things for you to do if you are so inclined: Connect more clients to see the Chirper broadcast behavior. Make the network of users much bigger. Make the rate of generating messages higher."
  },
  "1.5/Documentation/Samples-Overview/Adventure.html": {
    "href": "1.5/Documentation/Samples-Overview/Adventure.html",
    "title": "Adventure | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Adventure A simple multiplayer text adventure game inspired by old-fashioned, text-based adventure games. Instructions: Build Adventure.sln Start your local Silo from a command window using command file #1. The game map initialization script, #2 Start the client #3 Reminisce about the good old days before graphical user interfaces Overview The AdventureSetup program reads a game description (\"map\") from AdventureConfig.txt. It sets up a series of \"rooms\" e.g. forest, beach, caves, a clearing etc . These locations are connected to other rooms to model the places and layout of the game. The sample configuration describes only a handful of locations. Rooms can contain \"things\" such as keys, swords etc. The AdventureClient program sets up your player and provides a simple text based user interface to allow you to play the game. You can move around rooms and interact with things using a simple command language, saying things such as \"go north\" or \"take brass key\". Why Orleans? Orleans allows the game to be described via very simple C# code while allowing it to scale to a massive multiplayer game. For this motivation to be meaningful, the labyrinth of rooms needs to be very large and need to support a large number of simultaneous players. One value of Orleans is that the service can be designed for growth, the overhead of running it at a small scale is not significant, and you can remain confident that it will scale if the need arises. How is it modeled? Player and Rooms are modeled as grains. These grains allow us to distribute the game with each grain modelling state and functionality. Things such as keys are modeled as plain old objects - they are really just simple immutable data structures that move around rooms and among players; they don't need to be grains. Things for you to do if you are so inclined Make the map much, much, bigger Make the brass key unlock something Allow players to message each other Make eating food and drinking water possible and meaningful"
  },
  "1.5/Documentation/Samples-Overview/Twitter-Sentiment.html": {
    "href": "1.5/Documentation/Samples-Overview/Twitter-Sentiment.html",
    "title": "Twitter Sentiment | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Twitter Sentiment The Twitter Sentiment application records Twitter sentiment by consuming the Twitter streaming API, calulates a sentiment score for each tweet (i.e. is it a positive/negative/neutral tone of lanuage), and then records that sentiment against each hashtag in the tweet using an Orleans grain to maintain a total score for each unique hashtag. The sample illustrates using Orleans to manipulate data with high volumes of input traffic, where each grain owns a row in a table (or a key in a key/value store, or a document in a document store) and all updates go through one single grain, reducing contention for individual rows, keys, or documents. Client The sentiment processing on each tweet is performed in a Node.js application, in server.js, and uses the sentiment library to perform the analysis, which uses key words to determine sentiment. The sentiment score and the actual tweet are posted to the ASP.NET MVC program for processing. The ASP.NET MVC application serves two main roles. It acts as the end point to post sentiment scores into Orleans, and it provides the UI to view hashtag sentiment scores from Orleans. When updating a sentiment score, the SetScore function in GrainContoller.cs gets a handle for a stateless TweetDispatcher grain, and calls its AddScore method. The GetScores method retrieves the score for an arbitrary list of hashtags, each score being expressed as a combination of the overall positive sentiment score, the overall negative sentiment score, and the total number of tweets tracked containing that hashtag. Recall that some sentiment analysis will often result in a neutral weighting, so it is good to track the total number of tweets containing the hashtag. The controller also retrieves a count of the total number of hashtags that the system is tracking, to help give a sense of the scale of data coming in from the Twitter fire hose. Orleans There are three main Orleans grains in the sample. The TweetDispatcher is the public “endpoint” for sentiment analysis. [StatelessWorker] public interface ITweetDispatcherGrain : Orleans.IGrain { Task AddScore(int score, string[] hashtags, string tweet); Task<Totals[]> GetTotals(string[] hashtags); } Note that it is a stateless grain, and its main role is to pass the work to stateful grains for processing. AddScore takes a tweet, and parses out each hashtag for processing by the appropriate grain. GetTotals retrieves get the number of tweets that have included a specific list of hashtags. This grain exists in part to support the “batch processing” of several hashtags within a single tweet. One Orleans grain is created for each unique hashtag, and this grain is used to track the current sentiment score. [ExtendedPrimaryKey] public interface IHashtagGrain : Orleans.IGrain { Task AddScore(int score, string lastTweet); Task<Totals> GetTotals(); } Note that the ExtendedPrimaryKey attribute indicates that a string, in this case the twitter hashtag, is being used as a composite key for the grain, instead of the more usual Guid or long, which is a more natural fit for grains that have strings rather than numeric keys. The AddMethod updates the current state with the latest sentiment score, and GetTotals returns a Totals structure, with the breakdown of the sentiment analysis, along with the date stamp for the last processed tweet, and the test of the last tweet. The last tweet is kept just to allow the UI to display it, to help give the sentiment more context. When first activated, the grain tracks this activation by calling the IncrementCounter method on a Counter grain. public interface ICounter : Orleans.IGrain { Task IncrementCounter(); Task ResetCounter(); Task<int> GetTotalCounter(); } To increase performance, the counter grain only persists its internal state periodically, in this case, every 100 calls. The running total does not have to be one hundred percent accurate, so if the data were lost due to a silo failure between updates, that would not be critical. If this grain were to be called repeatedly from other grains, it could become a bottleneck, and some form of aggregation pattern would be needed, but as its only called once from each grain, upon grain initialization, this should not be an issue. Prerequisites The following must be installed prior to running the sample: Visual Studio 2013 Orleans SDK Node.js Tools for Visual Studio . Make sure to read the instructions and also install Node.js, not just the VS tools! A Windows Azure storage account A Twitter account and Twitter application development credentials. Sign up as a Twitter Developer and create an application. Make a note of the 'API key', 'API secret', 'Access token' and 'Access secret'. It is important to set the application permissions to include all rights, and then regenerating the keys and tokens before using them. If you don't, the client will silently fail. Running the Sample Open the OrleansTwitterDemo.sln file in Visual Studio 2013, and build the solution. Enter the details from Twitter into the TwitterClient\\app.js file. Start Azure Storage Emulator or replace \"UseDevelopmentStorage=true\" in DevTestServerConfiguration.xml in the Host project with your Azure Storage account Start the local Orleans Silo by running the Host project. Start the TwitterClient project. The Twitter Client should start, showing you every tweet it is consuming. Start the TwitterWebApplication project. Your browser should open on http://localhost:5190/ showing you a few preset hashtags you can monitor. Try adding a couple of hashtags to track using the browser UI. Got get a cup of coffee or do something else for a while, because it may take some time before the tags you care about are seen in the feed."
  },
  "1.5/Documentation/Samples-Overview/index.html": {
    "href": "1.5/Documentation/Samples-Overview/index.html",
    "title": "Samples Overview | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Samples Overview What do I need? To productively use the Orleans samples, please follow the Prerequisites section for the supported versions of the .NET framework, Visual Studio and Azure SDK. An Azure subscription will help with some of the samples, but is not required. For the Azure-based samples, you will need to install the SDK. The samples themselves can be downloaded from GitHub . Hello World This is the Orleans version of an old classic. It demonstrates that while there is no such thing as \"trivial\" when you are dealing with distributed computing, Orleans makes it pretty straight-forward. Azure Web Sample An Azure-hosted version of Hello World. Adventure Before there was graphical user interfaces, before the era of game consoles and massive-multiplayer games, there were VT100 terminals and there was Colossal Cave Adventure . Possibly lame by today's standards, back then it was a magical world of monsters, chirping birds, and things you could pick up. It's the inspiration for this sample. Presence Service This sample shows the principles behind a typical (though much simplified) presence service, such as you would find in online games and other social applications. Tic Tac Toe This is a simple online version of the classic board game. Chirper A simple social network pub/sub system, with chirp messages being sent from publishers to followers. Twitter Sentiment This sample uses Orleans to aggregate and analyze twitter data for a simple sentiment dashboard. Twitter Sentiment relies on a Node.js project for some of its functionality, as well as Twitter developer credentials. To use this sample, you will need to: Get the Node.js Tools for Visual Studio Get a Twitter account Sign up as a Twitter Developer. GPS Tracker A combination of Orleans and SignalR is used to simulate GPS devices tracked as they move around San Francisco, updating their locations as they change. Storage Providers This sample contains sample code for two Orleans storage providers: one that stores data in a regular file system, one that connects to MongoDB."
  },
  "1.5/Documentation/Samples-Overview/Hello-World.html": {
    "href": "1.5/Documentation/Samples-Overview/Hello-World.html",
    "title": "Hello World | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Hello World In this sample, a client connects with an Orleans grain instance, sends it a greeting and receives a greeting back. The client then prints that greeting and that's that. Simple enough in theory, but since there's distribution involved, there's a bit more to it. There are three projects involved -- one for declaring the communication interfaces, one for the grain implementations, and one for the client, which also hosts the Orleans silo that loads the grain when activated. There's only one communication interface, in IHello.cs: public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } This is simple enough, and we can see that all replies must be represented as a Task or Task in communication interfaces. The implementation, found in HelloGrain.cs, is similarly trivial: public class HelloGrain : Orleans.Grain, HelloWorldInterfaces.IHello { Task<string> HelloWorldInterfaces.IHello.SayHello(string greeting) { return Task.FromResult(\"You said: '\" + greeting + \"', I say: Hello!\"); } } The class inherits from an Orleans-defined base class, and implements the communication interface defined earlier. Since there is nothing that the grain needs to wait on, the method is not declared async and instead returns its value using Task.FromResult() . The client, which orchestrates the grain code and is found in Program.cs, looks like this: Orleans.GrainClient.Initialize(\"DevTestClientConfiguration.xml\"); var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello(\"Good morning!\").Result); There's other code in the method, too, but that is unrelated to the client logic, it's hosting the Orleans silo."
  },
  "1.5/Documentation/Core-Features/StatelessWorker.html": {
    "href": "1.5/Documentation/Core-Features/StatelessWorker.html",
    "title": "Stateless Worker Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Stateless Worker Grains By default, the Orleans runtime creates no more than one activation of a grain within the cluster. This is the most intuitive expression of the Virtual Actor model with each grain corresponding to an entity with a unique type/identity. However, there are also cases when an application needs to perform functional stateless operations that are not tied to a particular entity in the system. For example, if client sends requests with compressed payloads that need to be decompressed before they could be routed to the target grain for processing, such decompression/routing logic is not tied to a specific entity in the application, and can easily scale out. When the [StatelessWorker] attribute is applied to a grain class, it indicates to the Orleans runtime that grains of that class should be treated as Stateless Worker grains. Stateless Worker grains have the following properties that make their execution very different from that of normal grain classes. The Orleans runtime can and will create multiple activations of a Stateless Worker grain on different silos of the cluster. Requests made to Stateless Worker grains are always executed locally, that is on the same silo where the request originated, either made by a grain running on the silo or received by the silo's client gateway. Hence, calls to Stateless Worker grains from other grains or from client gateways never incur a remote message. The Orleans Runtime automatically creates additional activations of a Stateless Worker grain if the already existing ones are busy. The maximum number of activations of a Stateless Worker grain the runtime creates per silo is limited by default by the number of CPU cores on the machine, unless specified explicitly by the optional maxLocalWorkers argument. Because of 2 and 3, Stateless Worker grain activations are not individually addressable. Two subsequent requests to a Stateless Worker grain may be processed by different activations of it. Stateless Worker grains provide a straightforward way of creating an auto-managed pool of grain activations that automatically scales up and down based on the actual load. The runtime always scans for available Stateless Worker grain activations in the same order. Because of that, it always dispatches a requests to the first idle local activation it can find, and only gets to the last one if all previous activations are busy. If all activations are busy and the activation limit hasn't been reached, it creates one more activation at the end of the list, and dispatches the request to it. That means that when the rate of requests to a Stateless Worker grain increases, and existing activations are all currently busy, the runtime expands the pool of its activations up to the limit. Conversely, when the load drops, and it can be handled by a smaller number of activations of the Stateless Worker grain, the activations at the tail of the list will not be getting requests dispatched to them. They will become idle, and eventually deactivated by the standard activation collection process. Hence, the pool of activations will eventually shrink to match the load. The following example defines a Stateless Worker grain class MyStatelessWorkerGrain with the default maximum activation number limit. [StatelessWorker] public class MyStatelessWorkerGrain : Grain, IMyStatelessWorkerGrain { ... } Making a call to a Stateless Worker grain is the same as to any other grain. The only difference is that in most cases a single grain ID is used, 0 or Guid.Empty . Multiple grain IDs can be used when having multiple Stateless Worker grain pools, one per ID, is desirable. var worker = GrainFactory.GetGrain<IMyStatelessWorkerGrain>(0); await worker.Process(args); This one defines a Stateless Worker grain class with no more than one grain activation per silo. [StatelessWorker(1)] // max 1 activation per silo public class MyLonelyWorkerGrain : ILonelyWorkerGrain { ... } Note that [StatelessWorker] attribute does not change reentrancy of the target grain class. Just like any other grains, Stateless Worker grains are non-reentrant by default. They can be explicitly made reentrant by adding a [Reentrant] attribute to the grain class. State The \"Stateless\" part of \"Stateless Worker\" does not mean that a Stateless Worker cannot have state and is limited only to executing functional operations. Like any other grain, a Stateless Worker grain can load and keep in memory any state it needs. It's just because multiple activations of a Stateless Worker grain can be created on the same and different silos of the cluster, there is no easy mechanism to coordinate state held by different activations. There are several useful patterns that involve Stateless Worker holding state. Scaled out hot cache items For hot cache items that experience high throughput, holding each such item in a Stateless Worker grain makes it a) automatically scale out within a silo and across all silos in the cluster; and b) makes the data always locally available on the silo that received the client request via its client gateway, so that the requests can be answered without an extra network hop to another silo. Reduce style aggregation In some scenarios applications need to calculate certain metrics across all grains of a particular type in the cluster, and report the aggregates periodically. Examples are reporting number of players per game map, average duration of a VoIP call, etc. If each of the many thousands or millions of grains were to report their metrics to a single global aggregator, the aggregator would get immediately overloaded unable to process the flood of reports. The alternative approach is to turn this task into a 2 (or more) step reduce style aggregation. The first layer of aggregation is done by reporting grain sending their metrics to a Stateless Worker pre-aggregation grain. The Orleans runtime will automatically create multiple activations of the Stateless Worker grain with each silo. Since all such calls will be processed locally with no remote calls or serialization of the messages, the cost of such aggregation will be significantly less than in a remote case. Now each of the pre-aggregation Stateless Worker grain activations, independently or in coordination with other local activations, can send their aggregated reports to the global final aggregator (or to another reduction layer if necessary) without overloading it."
  },
  "1.5/Documentation/Event-Sourcing/GrainStateAPI.html": {
    "href": "1.5/Documentation/Event-Sourcing/GrainStateAPI.html",
    "title": "JournaledGrain API | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . JournaledGrain Basics Journaled grains derive from <JournaledGrain<StateType,EventType> , with the following type parameters: The StateType represents the state of the grain. It must be a class with a public default constructor. EventType is a common supertype for all the events that can be raised for this grain, and can be any class or interface. All state and event objects should be serializable (because the log-consistency providers may need to persist them, and/or send them in notification messages). For grains whose events are POCOs (plain old C# objects), JournaledGrain<StateType> can be used as a shorthand for JournaledGrain<StateType,Object> . Reading the Grain State To read the current grain state, and determine its version number, the JournaledGrain has properties GrainState State { get; } int Version { get; } The version number is always equal to the total number of confirmed events, and the state is the result of applying all the confirmed events to the initial state. The initial state, which has version 0 (because no events have been applied to it), is determined by the default constructor of the GrainState class. Important: The application should never directly modify the object returned by State . It is meant for reading only. Rather, when the application wants to modify the state, it must do so indirectly by raising events. Raising Events Raising events is accomplished by calling the RaiseEvent function. For example, a grain representing a chat can raise a PostedEvent to indicate that a user submitted a post: RaiseEvent(new PostedEvent() { Guid = guid, User = user, Text = text, Timestamp = DateTime.UtcNow }); Note that RaiseEvent kicks off a write to storage access, but does not wait for the write to complete. For many applications, it is important to wait until we have confirmation that the event has been persisted. In that case, we always follow up by waiting for ConfirmEvents : RaiseEvent(new DepositTransaction() { DepositAmount = amount, Description = description }); await ConfirmEvents(); Note that even if you don't explicitly call ConfirmEvents , the events will eventually be confirmed - it happens automatically in the background. For more discussion on this topic, see Immediate vs. Delayed Confirmation . State Transition Methods The runtime updates the grain state automatically whenever events are raised. There is no need for the application to explicitly update the state after raising an event. However, the application still has to provide the code that specifies how to update the state in response to an event. This can be done in two ways. (a) The GrainState class can implement one or more Apply methods on the StateType . Typically, one would create multiple overloads, and the closest match is chosen for the runtime type of the event: class GrainState { Apply(E1 @event) { // code that updates the state } Apply(E2 @event) { // code that updates the state } } (b) The grain can override the TransitionState function: protected override void TransitionState(State state, EventType @event) { // code that updates the state } The transition methods are assumed to have no side effects other than modifying the state object, and should be deterministic (otherwise, the effects are unpredictable). If the transition code throws an exception, that exception is caught and included in a warning in the Orleans log, issued by the log-consistency provider. When, exactly, the runtime calls the transition methods depends on the chosen log consistency provider and its configuration. It is best for applications not to rely on a particular timing, except when specifically guaranteed by the log consistency provider. Some providers, such as the LogStorage log-consistency provider, replay the event sequence every time the grain is loaded. Therefore, as long as the event objects can still be properly deserialized from storage, it is possibly to radically modify the GrainState class and the transition methods. But for other providers, such as the StateStorage log-consistency provider, only the GrainState object is persisted, so developers must ensure that it can be deserialized correctly when read from storage. Raising Multiple Events It is possible to make multiple calls to RaiseEvent before calling ConfirmEvents: RaiseEvent(e1); RaiseEvent(e2); await ConfirmEvents(); However, this is likely to cause two successive storage accesses, and it incurs a risk that the grain fails after writing only the first event. Thus, it is usually better to raise multiple events at once, using RaiseEvents(IEnumerable<EventType> events) This guarantees that the given sequence of events is written to storage atomically. Note that since the version number always matches the length of the event sequence, raising multiple events increases the version number by more than one at a time. Retrieving the Event Sequence The following method from the base JournaledGrain class allows the application to retrieve a specified segment of the sequence of all confirmed events: Task<IReadOnlyList<EventType>> RetrieveConfirmedEvents(int fromVersion, int toVersion) However, it is not supported by all log consistency providers. If not supported, or if the specified segment of the sequence is no longer available, a NotSupportedException is thrown. To retrieve all events up to the latest confirmed version, one would call await RetrieveConfirmedEvents(0, Version); Only confirmed events can be retrieved: an exception is thrown if toVersion is larger than the current value of the property Version . Since confirmed events never change, there are no races to worry about, even in the presence of multiple instances or delayed confirmation . However, in such situations, it is possible that the value of the property Version is larger by the time the await resumes than at the time RetrieveConfirmedEvents is called, so it may be advisable to save its value in a variable. See also the section on Concurrency Guarantees ."
  },
  "1.5/Documentation/Event-Sourcing/Diagnostics.html": {
    "href": "1.5/Documentation/Event-Sourcing/Diagnostics.html",
    "title": "JournaledGrain Diagnostics | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . JournaledGrain Diagnostics Monitoring Connection Errors By design, log consistency providers are resilient under connection errors (including both connections to storage, and connections between clusters). But just tolerating errors is not enough, as applications usually need to monitor any such issues, and bring them to the attention of an operator if they are serious. JournaledGrain subclasses can override the following methods to receive notifiations when there are connection errors observed, and when those errors are resolved: protected override void OnConnectionIssue(ConnectionIssue issue) { /// handle the observed error described by issue } protected override void OnConnectionIssueResolved(ConnectionIssue issue) { /// handle the resolution of a previously reported issue } ConnectionIssue is an abstract class, with several common fields describing the issue, including how many times it has been observed since the last time connection was successful. The actual type of connection issue is defined by subclasses. Connection issues are categorized into types, such as PrimaryOperationFailed or NotificationFailed , and sometimes have extra keys (such as RemoteCluster ) that further narrow the category. If the same category of issue happens several times (for example, we keep getting a NotificationFailed that targets the same RemoteCluster ), it is reported each time by OnConnectionIssue . Once this category of issue is resolved (for example, we are finally successful with sending a notification to this RemoteCluster ), then OnConnectionIssueResolved is called once, with the same issue object that was last reported by OnConnectionIssue . Connection issues, and their resolution, for independent categories, are reported independently. Simple Statistics We currently offer a simple support for basic statistics (in the future, we will probably replace this with a more standard telemetry mechanism). Statistics collection can be enabled or disabled for a JournaledGrain by calling void EnableStatsCollection() void DisableStatsCollection() The statistics can be retrieved by calling LogConsistencyStatistics GetStats()"
  },
  "1.5/Documentation/Event-Sourcing/Configuration.html": {
    "href": "1.5/Documentation/Event-Sourcing/Configuration.html",
    "title": "Configuration | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Configuration Configuring Project References Grain Interfaces As before, interfaces depend only on the Microsoft.Orleans.Core package, because the grain interface is independent of the implementation. Grain Implementations JournaledGrains need to derive from JournaledGrain<S,E> or JournaledGrain<S> , which is defined in the Microsoft.Orleans.EventSourcing package. Log-Consistency Providers We currently include three log-consistency providers (for state storage, log storage, and custom storage). All three are contained in the Microsoft.Orleans.EventSourcing package as well. Therefore, all Journaled Grains already have access to those. For a description of what these providers do and how they differ, see Included Log-Consistency Providers . Cluster Configuration Log-consistency providers are configured just like any other Orleans providers. For example, to include all three providers (of course, you probably won't need all three), add this to the <Globals> element of the configuration file: <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.StateStorage.LogConsistencyProvider\" Name=\"StateStorage\" /> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"LogStorage\" /> <Provider Type=\"Orleans.EventSourcing.CustomStorage.LogConsistencyProvider\" Name=\"CustomStorage\" /> </LogConsistencyProviders> The same can be achieved programmatically. Assuming the project contains the Microsoft.Orleans.EventSourcing package, and config is a ClusterConfiguration object: using Orleans.Runtime.Configuration; // pick up the necessary extension methods config.AddLogStorageBasedLogConsistencyProvider(\"LogStorage\"); config.AddStateStorageBasedLogConsistencyProvider(\"StateStorage\"); config.AddCustomStorageBasedLogConsistencyProvider(\"CustomStorage\"); Grain Class Attributes Each journaled grain class must have a LogConsistencyProvider attribute to specify the log-consistency provider. Some providers additionally require a StorageProvider attribute. LogConsistencyProvider Attributes To specify the log-consistency provider, add a [LogConsistencyProvider(ProviderName=...)] attribute to the grain class, and give the name of the provider as configured by the Cluster Configuration. For example: [LogConsistencyProvider(ProviderName = \"CustomStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain, ICustomStorage { ... } StorageProvider Attributes Some log-consistency providers (including LogStorage and StateStorage ) use a standard StorageProvider to communicate with storage. This provider is specified using a separate StorageProvider attribute, as follows: [LogConsistencyProvider(ProviderName = \"LogStorage\")] [StorageProvider(ProviderName = \"AzureBlobStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain { ... } Default Providers It is possible to omit the LogConsistencyProvider and/or the StorageProvider attributes, if a default is specified in the configuration. This is done by using the special name Default for the respective provider. For example: <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"Default\" /> </LogConsistencyProviders> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> </StorageProviders>"
  },
  "Documentation/deployment/index.html": {
    "href": "Documentation/deployment/index.html",
    "title": "Running the Application | Microsoft Orleans 中文文档",
    "keywords": "Orleans应用 典型的Orleans应用程序由一组服务器进程(silo)和一组客户端进程(通常是web服务器)组成，这些进程接收外部请求，将它们转换为grain方法调用，并返回结果。因此，运行Orleans应用程序首先需要启动一个silos集群。出于测试目的，集群可以由单个silos组成。对于可靠的生产部署，我们显然希望集群中有多个silos用于容错和扩展。 集群运行后，我们可以启动一个或多个客户端进程，这些进程连接到集群并可以向grains发送请求。客户端连接到silos-gateway上的特殊tcp端点。默认情况下，群集中的每个silos都启用了客户端网关。因此，客户可以同时连接到所有silos，以获得更好的性能和弹性。 配置和启动silos silos通过 群集配置 反对。它可以直接实例化和填充，从文件中加载设置，或者使用多个适用于不同部署环境的可用帮助器方法创建。对于本地测试，最简单的方法是使用 clusterconfiguration.localhostprimarysilo() 助手方法。然后将配置对象传递给 silos 类，可以在该类之后初始化和启动。 您可以创建一个空的控制台应用程序项目，目标是.NETFramework4.6.1或更高版本，用于托管silos。添加 Microsoft.Orleans.Server 项目的nuget元包。 PM> Install-Package Microsoft.Orleans.Server 以下是如何启动本地silos的示例： var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"Test Silo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Press Enter to close.\"); // wait here Console.ReadLine(); // shut the silo down after we are done. silo.ShutdownOrleansSilo(); 配置和连接客户端 通过一个 客户端配置 对象和 客户端生成器 是的。 客户端配置 对象可以直接实例化和填充，从文件加载设置，或者使用多个适用于不同部署环境的可用帮助器方法创建。对于本地测试，最简单的方法是使用 clientconfiguration.localhostsilo() 助手方法。然后将配置对象传递给 客户端生成器 上课。 客户端生成器 公开配置其他客户端功能的更多方法。之后 建立 方法 客户端生成器 调用对象以获取 IClusterClient 接口。最后，我们调用 连接() 方法连接到群集。 您可以创建一个空的控制台应用程序项目，目标是.net framework 4.6.1或更高版本以运行客户端，或者重用为托管silos而创建的控制台应用程序项目。添加 Microsoft.Orleans.client 项目的nuget元包。 PM> Install-Package Microsoft.Orleans.Client 以下是客户端如何连接到本地silos的示例： var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder().UseConfiguration(config). var client = builder.Build(); await client.Connect(); 生产配置 我们在这里使用的配置示例用于测试与 本地服务器 是的。在生产环境中，silos和客户端通常运行在不同的服务器上，并使用可靠的群集配置选项之一进行配置。您可以在《配置指南》](../clusters\\u and\\u clients/configuration\\u guide/index.md)和 群集管理 是的。"
  },
  "Documentation/tutorials_and_samples/tutorial_1.html": {
    "href": "Documentation/tutorials_and_samples/tutorial_1.html",
    "title": "Tutorial One | Microsoft Orleans 中文文档",
    "keywords": "教程一-创建极简的Orleans应用程序 本教程提供有关创建基本运行的Orleans应用程序的逐步说明。它被设计为自包含且极简的，具有以下特征： 它仅依赖NuGet软件包 已使用Orleans 2.2.0在Visual Studio 2017中进行了测试 它不依赖外部存储 请记住，这只是一个教程，缺少适当的错误处理和其他对生产环境有用的东西。但是，它可以帮助读者真正了解Orleans的结构，并使他们将继续学习的重点放在与他们最相关的部分上。 项目搭建 在本教程中，我们将创建4个项目： 一个包含Grains接口的库 一个包含Grains类的库 一个控制台应用程序来托管我们的silos 一个控制台应用程序来托管我们的客户端 遵循本教程之后，完整的解决方案应如下所示： 在Visual Studio中创建这样的项目结构 注意：在这些项目的每个项目，您可以使用C#的默认项目类型。然后您在下面为每个项目提供的代码替换默认代码。您可能还需要添加 using 语句。 首先在新解决方案中创建一个控制台应用程序(.NET Core)项目。项目命名为 Silo 并命名解决方案为 Orleans Basics 。 添加另一个控制台应用程序(.NET Core)项目并将其命名 Client 。 添加一个类库(.NET Standard)并命名 GrainInterfaces 。 添加另一个类库(.NET Standard)并命名 Grains 。 删除默认源文件 删除Grains中的Class1.cs 删除GrainInterfaces的Class1.cs 添加项目引用 Grains 引用 GrainInterfaces 。 Silo 引用 GrainInterfaces 和 Grains 。 Clinet 引用 GrainInterfaces 。 添加Orleans相关的NuGet包 在 Silo 项目中，添加 Microsoft.Orleans.Server NuGet包。 在客户端项目中，添加 Microsoft.Orleans.Client NuGet包。 在 GrainInterfaces 和 Grains 项目中，添加 Microsoft.Orleans.Core.Abstractions 和 Microsoft.Orleans.CodeGenerator.MSBuild 包。 在 Grains 项目中，添加 Microsoft.Extensions.Logging.Abstractions 用于记录日志的包。 在 Client 和 Silo 项目中，添加 Microsoft.Extensions.Logging.Console ，以便他们可以在控制台窗口中打印日志。 Microsoft.Orleans.Server 和 Microsoft.Orleans.Client 是元软件包，它们带来了在silos和客户端最可能需要的依赖关系。 Microsoft.Orleans.Core.Abstractions 在任何地方都需要。两者都包含 Microsoft.Orleans.Server 和 Microsoft.Orleans.Client 。 Microsoft.Orleans.CodeGenerator.MSBuild 自动生成调用Grains通过机器边界所需的代码。所以两者都需要 GrainInterfaces 和 Grains 项目。 定义grains接口 在GrainInterfaces项目中，添加一个 IHello.cs 代码文件，并在其中定义以下IHello接口： using System.Threading.Tasks; namespace OrleansBasics { public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } } 定义一个Grains类 在Grains项目中，添加一个 HelloGrain.cs 代码文件，并在其中定义以下类： using Microsoft.Extensions.Logging; using System.Threading.Tasks; namespace OrleansBasics { public class HelloGrain : Orleans.Grain, IHello { private readonly ILogger logger; public HelloGrain(ILogger<HelloGrain> logger) { this.logger = logger; } Task<string> IHello.SayHello(string greeting) { logger.LogInformation($\"\\n SayHello message received: greeting = '{greeting}'\"); return Task.FromResult($\"\\n Client said: '{greeting}', so HelloGrain says: Hello!\"); } } } 创建silos– Program.cs 在这一步，我们添加代码用于初始化一个服务-silos，这个服务将托管和运行我们的Grains。我们将在此处使用开发群集提供程序，以便我们可以在本地运行所有内容，而无需依赖外部存储系统。您可以在 本地开发配置 Orleans文档的页面。我们将在其中运行带有单个silos的集群。 将以下代码添加到Silo项目的Program.cs中： using System; using System.Threading.Tasks; using Microsoft.Extensions.Logging; using Orleans; using Orleans.Configuration; using Orleans.Hosting; namespace OrleansBasics { public class Program { public static int Main(string[] args) { return RunMainAsync().Result; } private static async Task<int> RunMainAsync() { try { var host = await StartSilo(); Console.WriteLine(\"\\n\\n Press Enter to terminate...\\n\\n\"); Console.ReadLine(); await host.StopAsync(); return 0; } catch (Exception ex) { Console.WriteLine(ex); return 1; } } private static async Task<ISiloHost> StartSilo() { // define the cluster configuration var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"OrleansBasics\"; }) .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences()) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } } 创建客户端– Program.cs 最后，我们需要配置一个客户端与我们的Grains进行通信，将其连接到集群(其中只有单个silos)，然后调用Grains。请注意，群集配置必须与我们用于silos的配置匹配。有关客户端的更多信息，请参见 集群和客户端 Orleans文档中的部分。 using Microsoft.Extensions.Logging; using Orleans; using Orleans.Configuration; using System; using System.Threading.Tasks; namespace OrleansBasics { public class Program { static int Main(string[] args) { return RunMainAsync().Result; } private static async Task<int> RunMainAsync() { try { using (var client = await ConnectClient()) { await DoClientWork(client); Console.ReadKey(); } return 0; } catch (Exception e) { Console.WriteLine($\"\\nException while trying to run client: {e.Message}\"); Console.WriteLine(\"Make sure the silo the client is trying to connect to is running.\"); Console.WriteLine(\"\\nPress any key to exit.\"); Console.ReadKey(); return 1; } } private static async Task<IClusterClient> ConnectClient() { IClusterClient client; client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"OrleansBasics\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); await client.Connect(); Console.WriteLine(\"Client successfully connected to silo host \\n\"); return client; } private static async Task DoClientWork(IClusterClient client) { // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, HelloGrain!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); } } } 运行应用程序 构建解决方案并运行 Silo 项目，在收到确认信息后，表示正在运行 Silo (“按Enter键以终止...”)，然后运行 Client 项目。成功看起来像这样： 进一步阅读 Orleans包清单 Orleans配置指南 Orleans最佳实践"
  },
  "Documentation/tutorials_and_samples/overview_helloworld.html": {
    "href": "Documentation/tutorials_and_samples/overview_helloworld.html",
    "title": "Tutorial 1 Hello World | Microsoft Orleans 中文文档",
    "keywords": "概述：Hello World 此概述与可用的Hello World示例应用程序相关联 这里 。 Orleans的主要概念包括silos，客户和一种或多种Grains。创建Orleans应用程序涉及配置silos，配置客户端和编写Grain。 配置silos 通过以下方式以编程方式配置silos SiloHostBuilder 和许多补充期权类别。可以找到所有选项的列表 这里。 [...] private static async Task<ISiloHost> StartSilo() { // define the cluster configuration var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences()) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } 选项 用于 .UseLocalhostClustering() 将客户端配置为连接到本地主机上的silos。 集群选项 ClusterId是Orleans群集的名称，对于silos和客户端，名称必须相同，以便彼此对话。ServiceId是用于应用程序的ID，并且在部署之间不得更改 EndpointOptions 这告诉silos在哪里听。在此示例中，我们使用了 回送 。 配置应用程序部件 将Grain类和接口程序集作为应用程序部分添加到您的orleans应用程序中。 加载配置后，将构建SiloHost，然后异步启动。 配置客户端 与silos类似，客户端通过以下方式配置 ClientBuilder 以及类似的期权类别集合。 private static async Task<IClusterClient> StartClientWithRetries() { attempt = 0; IClusterClient client; client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); await client.Connect(RetryFilter); Console.WriteLine(\"Client successfully connect to silo host\"); return client; } 选项 用于 .UseLocalhostClustering() 与SiloHost相同 集群选项 与SiloHost相同 可以找到有关配置客户端的更深入的指南 在配置指南的客户端配置部分中。 写一粒 Grains是Orleans编程模型的关键原语。Grains是Orleans应用程序的基础，它们是隔离，分布和持久化的原子单位。Grains是代表应用程序实体的对象。就像经典的面向对象编程一样，grain封装了实体的状态，并在代码逻辑中对其行为进行了编码。Grains可以相互保持引用，并可以通过调用彼此通过接口公开的方法进行交互。 您可以在 Orleans文档的“核心概念”部分。 这是Hello World Grain的代码主体： [...] namespace HelloWorld.Grains { public class HelloGrain : Orleans.Grain, IHello { Task<string> IHello.SayHello(string greeting) { logger.LogInformation($\"SayHello message received: greeting = '{greeting}'\"); return Task.FromResult($\"You said: '{greeting}', I say: Hello!\"); } } } 您可以阅读，grain类实现一个或多个grain接口 在这里，在Grains部分。 ) [...] namespace HelloWorld.Interfaces { public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } } 零件如何协同工作 建立此编程模型是我们分布式面向对象编程的核心概念的一部分。SiloHost首先启动。然后，启动OrleansClient程序。OrleansClient的Main方法调用启动客户端的方法， StartClientWithRetries()。 客户端被传递给 DoClientWork() 方法。 private static async Task DoClientWork(IClusterClient client) { // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, my friend!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); } 此时，OrleansClient创建对IHellograins的引用，并通过其接口IHello调用其SayHello()方法。此调用激活silos中的Grains。OrleansClient向激活的Grains发送问候语。Grains返回问候作为对OrleansClient的响应，OrleansClient在控制台上显示该问候。 运行示例应用 要运行示例应用程序，请参阅 自述文件。"
  },
  "Documentation/tutorials_and_samples/Adventure.html": {
    "href": "Documentation/tutorials_and_samples/Adventure.html",
    "title": "Adventure | Microsoft Orleans 中文文档",
    "keywords": "冒险 一个简单的多人文本冒险游戏，的灵感来自老式的、基于文本的冒险游戏。 说明书 在 Visual Studio 打开 OrleansAdventure.sln 项目。你可以 在这里 找到他。 启动“AdventureSetup”项目。 当AdventureSetup运行成功后，启动“AdventureClient”项目。 然后系统会提示您在命令行中输入您的姓名。进入并开始游戏。 概述 AdventureSetup程序从 AdventureConfig.txt 中读取游戏配置(\"地图\")。 它设置了一系列的“房间”，如森林、海滩、洞穴、空地等。这些位置连接到其他房间，以模拟游戏的位置和布局。该示例配置仅描述了少数位置。 房间里可以放钥匙、剑等“东西”。 AdventureClient程序设置您的播放器，并提供一个简单的基于文本的用户界面，允许您玩游戏。 您可以使用简单的命令语言在房间中移动并与事物进行交互，例如说“go north”或“take brass key”。 为什么使用Orleans？ Orleans允许游戏通过非常简单的C#代码来描述游戏，同时允许它扩展到大型多人游戏。为了使这个动机有意义，房间的迷宫需要非常大，并且需要同时支持大量玩家。使用Orleans的一个优点是，该服务可以应对增量而设计，以小规模运行它的开销并不显著，而且您可以确信，当需要时它将是可以扩展的。 它是如何建模的？ 玩家和房间被建模为Grains。这些Grains使我们能够用每个Grains模型状态和功能来分发游戏。 像密钥这样的东西被建模为“plain old objects”——它们实际上只是简单的不可变的数据结构，并且可以在房间里和玩家之间移动，所以它们不需要设计为Grains。 可能的改进 把地图弄得更大，更大 让铜钥匙打开什么东西 允许玩家互相留言 使食物和饮用水成为可能和有实际的作用。"
  },
  "Documentation/tutorials_and_samples/index.html": {
    "href": "Documentation/tutorials_and_samples/index.html",
    "title": "Samples Overview | Microsoft Orleans 中文文档",
    "keywords": "讲解 教程1：Orleans基础知识 教程1指导您完成创建结构并设置第一个Orleans应用程序的包和🚰的步骤。 样品 你需要什么 除非另有说明，否则样品均为自包含的示例。对于某些示例，您可能需要Azure订阅。对于基于Azure的示例，您将需要安装SDK。 可以从以下位置下载示例 的GitHub 。 Hello，World 经典的Hello World应用程序的Orleans版本。这个示例在处理分布式计算时，没有“琐碎”的东西，Orleans使它变得直接明了。 MathGrains 这是一个使用Orleans核心组件封装功能的简单计算器。 冒险 在没有图形用户接口之前，在游戏机和大型多人游戏时代之前，有VT100终端，并且有 巨大的洞穴冒险 。按照今天的标准，这可能是la脚的，那时候是一个神奇的世界，里面有怪物、,叫的鸟以及可以捡到的东西。这是此示例的灵感。"
  },
  "Documentation/tutorials_and_samples/Hello-World.html": {
    "href": "Documentation/tutorials_and_samples/Hello-World.html",
    "title": "Hello World | Microsoft Orleans 中文文档",
    "keywords": "你好，世界 运行Hello World示例 运行此示例的一种方法是从以下位置下载HelloWorld的本地副本 Samples / 2.0 / HelloWorld /文件夹 。 打开两个命令提示符窗口，然后在每个窗口中导航到HelloWorld文件夹。 生成项目。 使用以下命令在一个窗口中启动silos： dotnet run --project src\\SiloHost silos运行后，使用以下命令在另一个窗口中启动客户端： dotnet run --project src\\OrleansClient silos窗口和客户端窗口将相互显示问候。 Orleans怎么说 在此示例中，客户端与Grains连接，向其发送问候并接收回问候。客户然后打印该问候，仅此而已。理论上很简单，但是由于涉及分布，因此还有更多内容。 涉及四个项目-一个用于声明Grain接口，一个用于Grain实现，一个用于客户端，一个用于silos主机。 IHello.cs中有一个Grains接口： public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } 这很简单，我们可以看到所有回复都必须表示为一个任务或一个任务 在通信接口中。在HelloGrain.cs中找到的实现也很简单： public class HelloGrain : Orleans.Grain, HelloWorldInterfaces.IHello { Task<string> HelloWorldInterfaces.IHello.SayHello(string greeting) { return Task.FromResult($\"You said: '{greeting}', I say: Hello!\"); } } 该类从基类继承 grain ，并实现之前定义的通信接口。由于没有什么需要等待的Grains，因此不会声明该方法async而是使用返回值 Task.FromResult() 。 编排Grains代码并在OrleansClient项目中找到的客户端如下所示： //configure the client with proper cluster options, logging and clustering client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); //connect the client to the cluster, in this case, which only contains one silo await client.Connect(); ... // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, my friend!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); SiloHost项目中的silos主机(用于配置和启动silos)如下所示： //define the cluster configuration var builder = new SiloHostBuilder() //configure the cluster with local host clustering .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureLogging(logging => logging.AddConsole()); //build the silo var host = builder.Build(); //start the silo await host.StartAsync();"
  },
  "Documentation/tutorials_and_samples/testing.html": {
    "href": "Documentation/tutorials_and_samples/testing.html",
    "title": "单元测试 | Microsoft Orleans 中文文档",
    "keywords": "单元测试 本教程显示如何对Grains进行单元测试，以确保它们的行为正确。对Grains进行单元测试的主要方法有两种，选择的方法将取决于要测试的功能类型。的 微软Orleans测试主机 NuGet包可用于为Grains创建测试silos，也可以使用模拟框架，例如 起订量 模拟您与之交互的Orleans运行时的各个部分。 使用TestCluster 的 微软Orleans测试主机 NuGet软件包包含 测试集群 可以用来创建一个内存集群，默认情况下它由两个silos组成，可以用来测试Grains。 using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } 由于启动内存集群的开销，您可能希望创建一个 测试集群 并在多个测试案例中重复使用。例如，可以使用xUnit的类或集合夹具来完成此操作(请参见 https://xunit.github.io/docs/shared-context.html 更多细节)。 为了分享一个 测试集群 在多个测试用例之间，首先创建一个夹具类型： public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } 接下来创建一个集合夹具： [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } 您现在可以重复使用 测试集群 在您的测试用例中： using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); Assert.Equal(\"Hello, World\", greeting); } } } xUnit将调用 处理 的方法 集群固定 当所有测试都已完成并且在内存中群集孤岛将停止时，请键入。 测试集群 也有一个接受的构造函数 TestClusterOptions 可用于配置集群中的孤岛。 如果您在silos中使用依赖注入来使服务可用于Grains，则也可以使用以下模式： public class ClusterFixture : IDisposable { public ClusterFixture() { var builder = new TestClusterBuilder(); builder.AddSiloBuilderConfigurator<TestSiloConfigurations>(); this.Cluster = builder.Build(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } public class TestSiloConfigurations : ISiloBuilderConfigurator { public void Configure(ISiloHostBuilder hostBuilder) { hostBuilder.ConfigureServices(services => { services.AddSingleton<T, Impl>(...); }); } } 使用嘲弄 Orleans还使模拟系统的许多部分成为可能，并且在许多情况下，这是对grains进行单元测试的最简单方法。这种方法确实有局限性(例如，围绕调度重入和序列化)，并且可能要求Grain包含仅由单元测试使用的代码。的 OrleansTestKit 提供了一种替代方法，可以绕开许多这些限制。 例如，让我们想象一下我们正在测试的Grains与其他Grains相互作用。为了能够模拟其他Grains，我们还需要模拟 grain工厂 被测Grains的成员。默认 grain工厂 是正常的 受保护的 属性，但大多数模拟框架要求将属性设置为 上市 和 虚拟 才能嘲笑他们。所以我们要做的第一件事就是 grain工厂 都 上市 和 虚拟 属性： public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } 现在，我们可以在Orleans运行时之外创建Grains，并使用模拟来控制 grain工厂 ： using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); worker .Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())) .Returns(journal.Object); await worker.DoWork(data) journal.Verify(x => x.Record(data), Times.Once()); } } } 在这里，我们创建受测Grains 工人粮 ，使用Moq表示我们可以覆盖 grain工厂 以便它返回一个模拟 IJournalGrain 。然后，我们可以验证我们的 工人粮 与 IJournalGrain 如我们所料。"
  },
  "Documentation/implementation/testing.html": {
    "href": "Documentation/implementation/testing.html",
    "title": "单元测试 | Microsoft Orleans 中文文档",
    "keywords": "单元测试 本教程显示如何对Grains进行单元测试，以确保它们的行为正确。对Grains进行单元测试的主要方法有两种，选择的方法将取决于要测试的功能类型。的 微软Orleans测试主机 NuGet包可用于为Grains创建测试silos，也可以使用模拟框架，例如 起订量 模拟您与之交互的Orleans运行时的各个部分。 使用TestCluster 的 微软Orleans测试主机 NuGet软件包包含 测试集群 可以用来创建一个内存集群，默认情况下它由两个silos组成，可以用来测试Grains。 using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } 由于启动内存集群的开销，您可能希望创建一个 测试集群 并在多个测试案例中重复使用。例如，可以使用xUnit的类或集合夹具来完成此操作(请参见 https://xunit.github.io/docs/shared-context.html 更多细节)。 为了分享一个 测试集群 在多个测试用例之间，首先创建一个夹具类型： public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } 接下来创建一个集合夹具： [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } 您现在可以重复使用 测试集群 在您的测试用例中： using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHell(); Assert.Equal(\"Hello, World\", greeting); } } } xUnit将调用 处理 的方法 集群固定 当所有测试都已完成并且在内存中群集孤岛将停止时，请键入。 测试集群 也有一个接受的构造函数 TestClusterOptions 可用于配置集群中的孤岛。 如果您在silos中使用依赖注入来使服务可用于Grains，则也可以使用以下模式： public class ClusterFixture : IDisposable { public ClusterFixture() { var builder = new TestClusterBuilder(); builder.AddSiloBuilderConfigurator<TestSiloConfigurations>(); this.Cluster = builder.Build(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } public class TestSiloConfigurations : ISiloBuilderConfigurator { public void Configure(ISiloHostBuilder hostBuilder) { hostBuilder.ConfigureServices(services => { services.AddSingleton<T, Impl>(...); }); } } 使用嘲弄 Orleans还使模拟系统的许多部分成为可能，并且在许多情况下，这是对grains进行单元测试的最简单方法。这种方法确实有局限性(例如，围绕调度重入和序列化)，并且可能要求Grain包含仅由单元测试使用的代码。的 OrleansTestKit 提供了一种替代方法，可以绕开许多这些限制。 例如，让我们想象一下我们正在测试的Grains与其他Grains相互作用。为了能够模拟其他Grains，我们还需要模拟 grain工厂 被测Grains的成员。默认 grain工厂 是正常的 受保护的 属性，但大多数模拟框架要求将属性设置为 上市 和 虚拟 才能嘲笑他们。所以我们要做的第一件事就是 grain工厂 都 上市 和 虚拟 属性： public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } 现在，我们可以在Orleans运行时之外创建Grains，并使用模拟来控制 grain工厂 ： using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); worker .Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())) .Returns(journal.Object); await worker.DoWork(data) journal.Verify(x => x.Record(data), Times.Once()); } } } 在这里，我们创建受测Grains 工人粮 ，使用Moq表示我们可以覆盖 grain工厂 以便它返回一个模拟 IJournalGrain 。然后，我们可以验证我们的 工人粮 与 IJournalGrain 如我们所料。"
  },
  "Documentation/implementation/orleans_lifecycle.html": {
    "href": "Documentation/implementation/orleans_lifecycle.html",
    "title": "Orleans Lifecycle | Microsoft Orleans 中文文档",
    "keywords": "Orleans生命周期 总览 Orleans的某些行为非常复杂，因此需要有序地启动和关闭。具有此类行为的某些组件包括Grains，silos和客户。为了解决这个问题，引入了通用组件生命周期模式。此模式包括一个可观察的生命周期，该生命周期负责在组件启动和关闭的各个阶段发出信号，而生命周期观察器则负责在特定阶段执行启动或关闭操作。 也可以看看 Grains生命周期 和 silos生命周期 。 可观察的生命周期 需要顺序启动和关闭的组件可以使用可观察的生命周期，该周期可允许其他组件观察LiveCycle并在启动或关闭过程中到达某个阶段时接收通知。 public interface ILifecycleObservable { IDisposable Subscribe(string observerName, int stage, ILifecycleObserver observer); } 订阅访问在启动或停止时达到阶段时会注册观察者以进行通知。观察者名称用于报告。指示在启动/关闭顺序中的哪一点将通知观察者的阶段。生命周期的每个阶段都是可观察的。当开始和停止到达阶段时，将通知所有观察者。阶段以升序开始，以降序停止。观察者可以通过处置返回的IDisposable物品来退订。 生命周期观察者 需要参与另一个组件生命周期的组件需要为其启动和关闭行为提供挂钩，并订阅可观察到的生命周期的特定阶段。 public interface ILifecycleObserver { Task OnStart(CancellationToken ct); Task OnStop(CancellationToken ct); } OnStart / OnStop 在启动/关闭期间达到订阅的阶段时将调用。 实用工具 为了方便起见，已经为常见的生命周期使用模式创建了辅助功能。 扩展名 存在用于订阅可观察生命周期的扩展功能，这些功能不需要订阅组件实现ILifecycleObserver。而是，这些允许组件传递lambda或在预订阶段调用成员函数。 IDisposable Subscribe(this ILifecycleObservable observable, string observerName, int stage, Func<CancellationToken, Task> onStart, Func<CancellationToken, Task> onStop); IDisposable Subscribe(this ILifecycleObservable observable, string observerName, int stage, Func<CancellationToken, Task> onStart); 类似的扩展功能允许使用通用类型参数来代替观察者名称。 IDisposable Subscribe<TObserver>(this ILifecycleObservable observable, int stage, Func<CancellationToken, Task> onStart, Func<CancellationToken, Task> onStop); IDisposable Subscribe<TObserver>(this ILifecycleObservable observable, int stage, Func<CancellationToken, Task> onStart); 生命周期参与 一些可扩展性点需要一种方法来识别哪些组件对参与生命周期感兴趣。为此，引入了生命周期参与者标记接口。探索silos和Grains的生命周期时，将详细介绍如何使用它。 public interface ILifecycleParticipant<TLifecycleObservable> where TLifecycleObservable : ILifecycleObservable { void Participate(TLifecycleObservable lifecycle); } 例 根据我们的生命周期测试，以下是在生命周期的多个阶段参与可观察生命周期的组件示例。 enum TestStages { Down, Initialize, Configure, Run, } class MultiStageObserver : ILifecycleParticipant<ILifecycleObservable> { public Dictionary<TestStages,bool> Started { get; } = new Dictionary<TestStages, bool>(); public Dictionary<TestStages, bool> Stopped { get; } = new Dictionary<TestStages, bool>(); private Task OnStartStage(TestStages stage) { this.Started[stage] = true; return Task.CompletedTask; } private Task OnStopStage(TestStages stage) { this.Stopped[stage] = true; return Task.CompletedTask; } public void Participate(ILifecycleObservable lifecycle) { lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Down, ct => OnStartStage(TestStages.Down), ct => OnStopStage(TestStages.Down)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Initialize, ct => OnStartStage(TestStages.Initialize), ct => OnStopStage(TestStages.Initialize)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Configure, ct => OnStartStage(TestStages.Configure), ct => OnStopStage(TestStages.Configure)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Run, ct => OnStartStage(TestStages.Run), ct => OnStopStage(TestStages.Run)); } }"
  },
  "Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html": {
    "href": "Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html",
    "title": "Silo Error Code Monitoring | Microsoft Orleans 中文文档",
    "keywords": "silos错误代码监视 群组 日志类型 日志代码值 门槛 说明 azure问题 警告或错误 100800至100899 任何错误或警告 读取或写入azure表存储的暂时性问题将记录为警告。将自动重试临时读取错误。最后一条错误日志消息意味着连接到azure表存储存在实际问题。 成员连接问题 警告或错误 100600-100699 任何错误或警告 警告日志是网络连接问题和/或silos重启/迁移的早期指示。ping超时和silo死投票将显示为警告消息。silo detesting it was voted dead将显示为错误消息。 Grains访问超时 警告 100157个 短时间内记录多个警告 Grains调用超时问题通常由临时网络连接问题或silos重新启动/重新启动问题引起。系统应在短时间后恢复(取决于活动配置设置)，此时应清除超时。理想情况下，仅监视批量日志代码600157这些警告的种类就应该足够了。 silos重启/迁移 警告 100601或100602 任何警告 当silos检测到它在同一台计算机{100602)上重新启动或迁移到不同的计算机(100601)时打印警告 网络套接字问题 警告或错误 101000至101999、100307100015、100016 任何错误或警告 插座断开记录为警告消息。打开套接字或在消息传输期间出现的问题记录为错误。 grain问题 警告或错误 101534个 任何错误或警告 检测非重入grains的“卡住”请求。每次请求执行时间超过5倍请求超时时，都会报告错误代码。"
  },
  "Documentation/clusters_and_clients/monitoring/index.html": {
    "href": "Documentation/clusters_and_clients/monitoring/index.html",
    "title": "Runtime Monitoring | Microsoft Orleans 中文文档",
    "keywords": "运行时监视 Orleans通过 ITelemetryConsumer 接口。应用程序可以向一个或多个遥测用户注册它们的silos和客户端，以接收Orleans Runtime Periotic发布的统计信息和度量。它们可以是流行的遥测分析解决方案的消费者，也可以是任何其他目的地和用途的自定义解决方案的消费者。三个遥测用户目前包含在Orleans代码库中。 它们作为单独的nuget包发布： Microsoft.Orleans.OrleanstelemtryConsumers.ai 发布到 应用洞察 是的。 Microsoft.Orleans.OrleanstelemtryConsumers.Counters 用于发布到Windows性能计数器。Orleans运行时会不断更新其中的一些。CounterControl.exe工具，包含在 Microsoft.Orleans.CounterControl nuget包，帮助注册必要的性能计数器类别。它必须以提升的权限运行。可以使用任何标准监视工具监视性能计数器。 microsoft.orleans.orleanstelemtryconsumers.newrelic ，用于发布到 新文物 是的。 要将silos和客户端配置为使用遥测用户，silos配置代码如下所示： var siloHostBuilder = new SiloHostBuilder(); //configure the silo with AITelemetryConsumer siloHostBuilder.AddApplicationInsightsTelemetryConsumer(\"INSTRUMENTATION_KEY\"); 客户端配置代码如下所示： var clientBuilder = new ClientBuilder(); //configure the clientBuilder with AITelemetryConsumer clientBuilder.AddApplicationInsightsTelemetryConsumer(\"INSTRUMENTATION_KEY\");"
  },
  "Documentation/clusters_and_clients/monitoring/client_error_code_monitoring.html": {
    "href": "Documentation/clusters_and_clients/monitoring/client_error_code_monitoring.html",
    "title": "Client Error Code Monitoring | Microsoft Orleans 中文文档",
    "keywords": "客户端错误代码监视 群组 日志类型 日志代码值 门槛 说明 azure问题 警告或错误 100800至100899 任何错误或警告 读取或写入azure表存储的暂时性问题将记录为警告。将自动重试临时读取错误。最后一条错误日志消息意味着连接到azure表存储存在实际问题。 网关连接问题 警告或错误 100901-100904、100912、100913、100921、100923、100158、100161、100178、101313 任何错误或警告 连接到网关时出现问题。azure表中没有活动网关。与活动网关的连接丢失。 Grains访问超时 警告 100157个 短时间内记录多个警告 Grains调用超时问题通常由临时网络连接问题或silos重新启动/重新启动问题引起。系统应在短时间后恢复(取决于活动配置设置)，此时应清除超时。理想情况下，仅监视批量日志代码600157这些警告的种类就应该足够了。 网络套接字问题 警告或错误 101000至101999、100307、100015、100016 任何错误或警告 插座断开记录为警告消息。打开套接字或在消息传输期间出现的问题记录为错误。 大容量日志消息压缩 任何 500000或更高 基于批量消息阈值设置的消息摘要 如果同一日志代码的多个日志在指定的时间间隔内出现(默认值为1分钟内>5)，则具有该日志代码的其他日志消息将被抑制，并作为日志代码等于原始日志代码+500000的“批量”条目输出。例如，多个100157条目将在日志中显示为每分钟5 x 100157+1 x 600157个日志条目。"
  },
  "Documentation/clusters_and_clients/configuration_guide/list_of_options_classes.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/list_of_options_classes.html",
    "title": "List of Options Classes | Microsoft Orleans 中文文档",
    "keywords": "选项类列表 用于配置Orleans的所有选项类都应该在 Orleans。配置 命名空间。他们中的许多人在 Orleans。接待 命名空间。 iclientbuilder和isilohostbuilder的通用核心选项 选项类型 用于 离合器选项 设置 棒状的 以及 服务ID 网络选项 为套接字和打开的连接设置超时值 序列化提供程序选项 设置序列化提供程序 类型管理选项 设置类型映射的刷新周期(请参阅异构silos和版本控制) iclientbuilder特定选项 选项类型 用于 客户信息选项 设置要保持打开的连接数，并指定要使用的网络接口 客户统计选项 设置与统计输出相关的各种设置 网关选项 设置可用网关列表的刷新周期 StaticGatewayListProviderOptions 设置客户端用于连接到群集的uri IsiloHostBuilder特定选项 选项类型 用于 ClusterMembership选项 群集成员身份的设置 一致性选项 一致散列算法的配置选项，用于平衡集群中的资源分配。 端点选项 设置silos终结点选项 GrainCollection选项 Grains垃圾收集选项 grains转化选项 管理异构部署中的Grain实现选择 加载选项 减载配置设置。必须有 ihostenvironmentstatistics 例如通过 builder.UsePerfCounterEnvironmentStatistics() (仅限Windows)用于 减载 发挥作用。 多色光 配置多群集支持的选项 性能调整选项 性能调整选项(网络、线程数) 进程Exthand选项 在进程出口配置silos行为 计划选项 配置计划程序行为 Silomessagingoptions 配置与silos相关的全局消息传递选项。 silos选项 设置silos的名称 silos统计选项 设置与统计输出相关的各种设置 遥测选项 设置遥测用户设置"
  },
  "Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html",
    "title": "Shutting down Orleans | Microsoft Orleans 中文文档",
    "keywords": "本文档解释了如何在应用程序出口之前优雅地关闭Orleanssilos，首先是作为控制台应用程序，然后作为一个反编译容器应用程序。 正常关机-控制台应用程序 下面的代码显示了如何在用户按下ctrl+c时优雅地关闭Orleans思洛控制台应用程序，这将生成 控制台取消按键 事件 通常，当事件处理程序返回时，应用程序将立即退出，导致灾难性的Orleanssilos崩溃和内存状态丢失。但是在下面的示例代码中，我们设置 a.取消=真； 以防止应用程序在Orleanssilos完成正常关闭之前关闭。 using Microsoft.Extensions.Logging; using Orleans.Configuration; using Orleans.Hosting; using System; using System.Net; using System.Threading; using System.Threading.Tasks; namespace MySiloHost { class Program { static readonly ManualResetEvent _siloStopped = new ManualResetEvent(false); static ISiloHost silo; static bool siloStopping = false; static readonly object syncLock = new object(); static void Main(string[] args) { SetupApplicationShutdown(); silo = CreateSilo(); silo.StartAsync().Wait(); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); } static void SetupApplicationShutdown() { /// Capture the user pressing Ctrl+C Console.CancelKeyPress += (s, a) => { /// Prevent the application from crashing ungracefully. a.Cancel = true; /// Don't allow the following code to repeat if the user presses Ctrl+C repeatedly. lock (syncLock) { if (!siloStopping) { siloStopping = true; Task.Run(StopSilo).Ignore(); } } /// Event handler execution exits immediately, leaving the silo shutdown running on a background thread, /// but the app doesn't crash because a.Cancel has been set = true }; } static ISiloHost CreateSilo() { return new SiloHostBuilder() .Configure(options => options.ClusterId = \"MyTestCluster\") /// Prevent the silo from automatically stopping itself when the cancel key is pressed. .Configure<ProcessExitHandlingOptions>(options => options.FastKillOnProcessExit = false) .UseDevelopmentClustering(options => options.PrimarySiloEndpoint = new IPEndPoint(IPAddress.Loopback, 11111)) .ConfigureLogging(b => b.SetMinimumLevel(LogLevel.Debug).AddConsole()) .Build(); } static async Task StopSilo() { await silo.StopAsync(); _siloStopped.Set(); } } } 当然，还有很多其他方法可以达到同样的目标。下面是一个方式，流行的在线，误导，这是不正常的工作。它不起作用，因为它在试图退出的两种方法之间设置一个竞争条件： 控制台取消按键 事件处理程序方法，以及 静态void main(字符串[]参数) 方法。当事件处理方法首先完成时，至少发生一半的时间，应用程序将挂起而不是顺利退出。 class Program { static readonly ManualResetEvent _siloStopped = new ManualResetEvent(false); static ISiloHost silo; static bool siloStopping = false; static readonly object syncLock = new object(); static void Main(string[] args) { Console.CancelKeyPress += (s, a) => { Task.Run(StopSilo); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); /// Now race to finish ... who will finish first? /// If I finish first, the application will hang! :( }; silo = CreateSilo(); silo.StartAsync().Wait(); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); /// Now race to finish ... who will finish first? } static async Task StopSilo() { await silo.StopAsync(); _siloStopped.Set(); } } 正常关机-Docker应用程序 待完成。"
  },
  "Documentation/clusters_and_clients/configuration_guide/local_development_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/local_development_configuration.html",
    "title": "Local development configuration | Microsoft Orleans 中文文档",
    "keywords": "本地开发配置 有关针对Orleans 2.0的工作示例应用程序，请参见： https://github.com/dotnet/orleans/tree/master/samples/2.0/helloworld网站 此示例托管了在不同平台上工作的.NET Core控制台应用程序中的客户端和silos，但对于.NET Framework 4.6.1+控制台应用程序(仅在Windows上工作)也可以这样做。 silos配置 对于本地开发，请参阅下面的示例，了解如何为这种情况配置silos。它配置并启动一个silos，分别作为silos和网关端口监听“环回”地址和11111和30000。 添加 Microsoft.Orleans.Server 项目的nuget元包。在您熟悉了api之后，可以选择包含在 Microsoft.Orleans.Server 你真的需要，并参考他们。 PM> Install-Package Microsoft.Orleans.Server 您需要配置 离合器选项 通过 ISiloBuilder.Configure 方法，指定您想要的 发展集群 将此silos作为主要的群集选择，然后配置silos终结点。 配置应用程序部件 call显式地将具有grain类的程序集添加到应用程序设置中。它还添加任何引用的程序集，因为 有参考文献 分机。完成这些步骤后，将生成silos主机并启动silos。 您可以创建一个空的控制台应用程序项目，目标是.NETFramework4.6.1或更高版本，用于托管silos和.NETCore控制台应用程序。 以下是如何启动本地silos的示例： public class Program { public static async Task Main(string[] args) { try { var host = await StartSilo(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); await host.StopAsync(); return; } catch (Exception ex) { Console.WriteLine(ex); return; } } private static async Task<ISiloHost> StartSilo() { var builder = new SiloHostBuilder() // Use localhost clustering for a single local silo .UseLocalhostClustering() // Configure ClusterId and ServiceId .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"MyAwesomeService\"; }) // Configure connectivity .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) // Configure logging with any logging framework that supports Microsoft.Extensions.Logging. // In this particular case it logs using the Microsoft.Extensions.Logging.Console package. .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } 客户端配置 对于本地开发，请参阅下面的示例，了解如何为这种情况配置客户端。它配置将连接到 回送 silos。 添加 Microsoft.Orleans.client 项目的nuget元包。在您熟悉了api之后，可以选择包含在 Microsoft.Orleans.client 你真的需要，并参考他们。 PM> Install-Package Microsoft.Orleans.Client 您需要配置 客户端生成器 使用与为本地silos指定的群集ID匹配的群集ID，并将静态群集指定为指向silos网关端口的群集选择 配置应用程序部件 call显式地将具有grain接口的程序集添加到应用程序设置中。 完成这些步骤后，我们可以构建客户端并 连接() 方法连接到群集。 您可以创建一个空的控制台应用程序项目，目标是.net framework 4.6.1或更高版本以运行客户端，或者重用为托管silos而创建的控制台应用程序项目。 以下是客户端如何连接到本地silos的示例： client = new ClientBuilder() // Use localhost clustering for a single local silo .UseLocalhostClustering() // Configure ClusterId and ServiceId .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"MyAwesomeService\"; }) .ConfigureLogging(logging => logging.AddConsole()) var client = builder.Build(); await client.Connect();"
  },
  "Documentation/clusters_and_clients/configuration_guide/startup_tasks.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/startup_tasks.html",
    "title": "Startup Tasks | Microsoft Orleans 中文文档",
    "keywords": "启动任务 在许多情况下，某些任务需要在silos可用时自动执行。 启动任务 提供此功能。 一些用例包括但不限于： 启动后台计时器以执行定期内务处理任务 使用从外部备份存储下载的数据预加载一些缓存grains 启动期间从启动任务引发的任何异常都将在silos日志中报告，并将停止silos。 这种快速故障方法是Orleans处理silos启动问题的标准方法，其目的是允许在测试阶段轻松检测silos配置和/或引导逻辑的任何问题，而不是在silos生命周期的后期被忽略并导致意外问题。 配置启动任务 启动任务可以使用 IsiloHostBuilder 通过注册要在启动期间调用的委托，或通过注册 伊斯塔普塔斯克 是的。 示例：注册委托 siloHostBuilder.AddStartupTask( async (IServiceProvider services, CancellationToken cancellation) => { // Use the service provider to get the grain factory. var grainFactory = services.GetRequiredService<IGrainFactory>(); // Get a reference to a grain and call a method on it. var grain = grainFactory.GetGrain<IMyGrain>(0); await grain.Initialize(); }); 示例：注册 伊斯塔普塔斯克 实施 首先，我们必须定义 伊斯塔普塔斯克 以下内容： public class CallGrainStartupTask : IStartupTask { private readonly IGrainFactory grainFactory; public CallGrainStartupTask(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Execute(CancellationToken cancellationToken) { var grain = this.grainFactory.GetGrain<IMyGrain>(0); await grain.Initialize(); } } 然后必须在 IsiloHostBuilder 以下内容： siloHostBuilder.AddStartupTask<CallGrainStartupTask>();"
  },
  "Documentation/resources/orleans_architecture_principles_and_approach_I.html": {
    "href": "Documentation/resources/orleans_architecture_principles_and_approach_I.html",
    "title": "Orleans Architecture - Principles and Approach I | Microsoft Orleans 中文文档",
    "keywords": "既然Orleans(最终)可以作为开源使用，那么了解促成Orleans背后的设计决策的目标和原则很重要，这样新的变化要么适合该框架，要么明确地并有意地修改那些目标和原则。 在我加入Orleans项目时，我们同意目标是建立一个框架，使主流开发人员可以轻松构建可扩展的分布式(云)应用程序。要对此进行细分： 目标读者不应排除尚未完成分布式系统开发的程序员 。我们希望使所有开发人员，无论是云专家还是云初学者，都可以专注于他们的应用程序逻辑和功能(即真正提供业务价值的内容)，而不是通用的分布式系统问题。 目的是让他们轻松构建云应用程序 。轻松地意味着，他们不必比绝对需要多考虑分配。轻松地也意味着Orleans应该尽可能向开发人员展示熟悉的外观；在.NET上下文中，这意味着C＃对象和接口。 这些应用程序应该是*“默认情况下可扩展” *。由于我们的目标用户不一定是分布式系统专家，因此我们希望为他们提供一个框架，使他们无需明确考虑即可构建可扩展的应用程序。这意味着该框架必须为它们做出很多决定，以确保可接受的可扩展性程度，即使这意味着可扩展性并非对每个应用程序都是最佳的。 我们通过一系列架构原则对这一目标进行了补充： 我们专注于80％的案例 。当然，有些应用程序不适合Orleans使用；没关系。有一些Orleans适合的应用程序，但是通过Orleans不允许的大量手动调整，您可以在其中获得更好的性能。也可以Orleans的80％可以很好地拟合并在许多有趣的应用程序上表现出色，我们宁愿80％上做得很好，也不愿99％上做得不好。 可扩展性至关重要 。如果可以更好地进行扩展，我们将权衡原始性能。 可用性至关重要 。云应用程序应该像实用程序：随时随地都可以使用。 检测并修复问题 ，不要以为您可以100％阻止它们。在云规模上，坏事经常发生，甚至不可能发生的坏事也很少发生。这导致了我们通常被称为“面向恢复的计算”，而不是试图做到容错。我们的经验表明，容错能力很弱，而且常常是虚幻的。即使是经过数学验证的协议也无法防止内存或磁盘控制器中的随机位翻转在报告成功时失败，这是我在职业生涯中已经看到的真实示例。 以上导致我们采取了某些做法： API优先设计 ：如果我们不知道如何向开发人员公开功能，那么我们就不会构建它。当然，最好的方法是使功能完全不接触开发人员。 轻松做正确的事 ：要使事情尽可能简单(但不要简单)，如果螺丝刀是正确的工具，请不要用锤子砸。正如我们的早期采用者之一所说的那样，我们试图帮助客户“落入成功之坑”。如果有一个标准模式可以很好地适合80％的应用程序，那么不必担心启用所有可能的替代方法。Orleans对异步的拥护就是一个很好的例子。 使开发人员轻松扩展框架而不破坏框架 。自定义序列化和持久化提供程序就是其中的几个示例。某种自定义任务计划扩展将是反示例。 遵循最少惊喜的原则 ：尽可能使事物熟悉，但一切都应按照外观进行。 下一篇文章将开始将这些原理应用于当前的Orleans设计，并逐步探究我们做出的某些特定决策的动机。 谢谢阅读！ 艾伦·盖勒 艾伦·盖勒， http://research.microsoft.com/en-us/people/ageller/ ，在Microsoft Research从事量子计算。从2008年到2012年，他是Orleans的主要架构师之一。在此之前，从2004年到2008年，他是Amazon Web Services的平台架构师，在此之前，他在电信和金融服务领域构建了各种大型生产分布式系统。"
  },
  "Documentation/resources/frequently_asked_questions.html": {
    "href": "Documentation/resources/frequently_asked_questions.html",
    "title": "Frequently Asked Questions | Microsoft Orleans 中文文档",
    "keywords": "常见问题解答 可利用性 我可以在我的项目中免费使用Orleans吗？ 当然。源代码已经在 麻省理工学院执照 . NuGet包发布于 nuget.org网站 . Orleans的生产准备好了吗？我听说这是一个研究项目。 实际上，Orleans最初是作为微软研究院的一个研究项目开始的。它后来成长为一种产品，自2011年起在微软内部投入生产，并在2015年公开发布后被其他使用。Orleans已经做好了生产准备，为许多高可用性系统和云服务提供了动力。 微软支持Orleans吗？ Orleans的源代码已经在麻省理工学院授权下发布 GitHub . 微软继续在Orleans投资，并接受社区对代码库的贡献。 定位 Orleans是服务器产品吗？我如何管理Orleans？ Orleans是一个框架，一组库，可以帮助您构建应用程序。基于Orleans的应用程序可以在各种托管环境中运行，在云端或本地集群中，甚至在一台机器上。应用程序开发人员负责在其目标宿主环境中构建、部署和运行基于Orleans的应用程序。 我在哪里可以跑Orleans？ Orleans可以在任何.NET应用程序可以运行的环境中运行。在Orleans 2.0之前，它需要完整的.NET框架。从2.0开始，Orleans遵循.NET标准2.0，因此可以在支持.NETCore的Windows和非Windows环境中运行.NETCore。 Orleans是为蔚蓝而建的吗？ 不，我们相信你应该可以在任何你需要的地方，以你需要的方式管理Orleans。Orleans非常灵活，并且有许多可选的提供商帮助在云环境中托管它，比如Azure、AWS或GCP，或者本地集群，可以选择支持Orleans集群协议的技术。 Orleans和其他actor语言和框架(比如Erlang或Akka)有什么区别？ 虽然基于Actor模型的相同基本原则，但Orleans向前迈进了一步，引入了虚拟参与者的概念，该概念极大地简化了开发人员的体验，并且更适合于云服务和高规模系统。 设计 在我的应用程序中，Grains应该有多大或多小？ grains隔离模型使它们能够很好地表示独立的状态和计算上下文。在大多数情况下，grains自然地映射到用户、会话、帐户等应用程序实体。这些实体通常彼此隔离，可以独立访问和更新，并公开一组定义良好的受支持操作。这与直观的“一个实体-一个纹理”模型很好地配合使用。 如果一个应用程序实体封装了太多的状态，那么它可能太大，无法用单个grains有效地表示，因此必须处理对它的高速率请求。尽管一个单独的grain通常每秒可以处理几千个琐碎的调用，但经验法则是要警惕单个grain每秒接收数百个请求。这可能是Grains太大的迹象，将其分解成一组更小的grains可能会导致一个更稳定和平衡的系统。 一个应用程序实体可能太小而不能成为一个Grain，如果这会导致其他Grain与之持续交互，并因此导致太多的消息传递开销。在这种情况下，让那些相互作用密切的实体成为单个grains的一部分，这样它们就可以直接相互调用了。 如何避免grain热点？ Grains的吞吐量受单个线程的限制，该线程的激活可以在该线程上执行。因此，建议避免一个单独的Grain接收到不相称的请求份额或参与处理对其他Grain的请求的设计。有多种模式可以帮助防止单个grains过载，即使在逻辑上它是通信的中心点。 例如，如果一个grain是由大量grain定期报告的一些计数器或统计信息的聚合器，一种行之有效的方法是添加控制数量的中间聚合器Grain，并将每个报告Grain(使用键上的模或散列)分配给中间聚合器，以便负载或多或少地均匀分布在所有中间聚集grains上，这些中间聚集grains定期向中央聚集grains报告部分聚集物。 如何 我怎样才能撕下一粒Grains？ 一般来说，不需要应用程序逻辑来强制取消激活grain，因为Orleans运行时会自动检测并停用grain的空闲激活以回收系统资源。让Orleans这样做更有效，因为它批处理停用操作，而不是逐个执行它们。在极少数情况下，当您认为确实需要加快grains的失活，可以通过调用 base.DeactivateOnIdle() 方法。 我能告诉Orleans在哪里激活Grains吗？ 使用限制性的布局策略是可以做到的，但我们通常认为这是一种非常先进的模式，需要仔细考虑。通过按照问题的建议来做，应用程序将承担资源管理的负担，而不一定要有足够的关于系统全局状态的信息来做到这一点。在silos重启的情况下，这种情况尤其适得其反，在云环境中，操作系统补丁可能会定期发生这种情况。因此，特定位置可能会对应用程序的可伸缩性以及对系统故障的恢复能力产生负面影响。 也就是说，对于应用程序确实知道应该在何处激活特定grains的罕见情况，例如，如果它知道grain持久状态的位置，那么在1.5.0中，我们引入了自定义存储策略和控制器。 如何对grains进行版本设置或添加新的grain类和接口？ 您可以向正在运行的集群中添加具有新Grain类或现有Grain类的新版本的silos。 我能从公共互联网连接到Orleans的发射井吗？ Orleans被设计为作为服务的后端部分进行托管，您需要创建一个外部客户端将连接到的前端层。它可以是基于HTTP的webapi项目、socket服务器、signal服务器或其他任何适合应用程序需要的服务器。如果您将Silo的TCP端点暴露给它，您可以从Internet连接到Orleans，但是从安全性的角度来看，这不是一个好的实践。 如果在我的Grains调用返回对我的调用的响应之前发生故障，会发生什么情况？ 如果在grain调用过程中发生silos故障，您将收到一个异常，您可以在代码中捕获并重试，或者根据应用程序逻辑执行其他操作来处理错误。在silos中失败的Grains将在下次调用时自动重新实例化。Orleans运行时并不急于从一个失败的silos中重新创建Grains，因为它们中的许多可能不是立即需要的，或者根本就不需要。相反，运行时会单独地重新创建这些Grain，并且只有在针对特定Grain的新请求到达时。对于每一粒Grains，它从一个可用的silos中挑选一个作为新的寄主。 这种方法的好处是，回收过程只对实际使用的Grains执行，而且它会及时分布在所有可用的silos中，这提高了系统的响应能力和回收速度。还要注意，在silos发生故障和Orleans集群检测到故障之间存在延迟。延迟是检测速度和误报概率之间的可配置折衷。在此过渡期间，对Grains的所有调用都将失败，但在检测到故障后，将在另一个silos上创建一个新的Grains调用，因此它最终将可用。 如果Grains调用执行时间过长，会发生什么情况？ 由于Orleans使用一个协作的多任务模型，它不会自动抢占grain的执行，但是Orleans会为长时间执行的grain调用生成警告，以便您可以检测到它们。与抢占式多任务相比，协作多任务具有更好的吞吐量。请记住，grain调用不应同步执行任何长时间运行的任务，如IO操作，也不应阻塞其他要完成的任务。所有等待都应该使用异步方式完成await或其他异步关键字等待机制。Grains应该尽快返回，让其他Grains执行以获得最大吞吐量。"
  },
  "Documentation/resources/student_projects.html": {
    "href": "Documentation/resources/student_projects.html",
    "title": "Student Projects | Microsoft Orleans 中文文档",
    "keywords": "学生项目 我们为学生推荐两种类型的项目： 第一种类型包括探索性的，开放式的， 研究性项目 目标是在Orleans建立新的能力。这些项目的范围通常很广，适合硕士、博士或高级本科生最后一年的学习。这些项目的最终目标是为Orleans提供创意和设计。我们不一定期望在这些项目中生成的代码直接贡献到这个存储库中，但是这将是很好的。 第二种类型包括 学生教育理念 . 这些都是可以在Orleans之上构建的有趣应用程序的想法，或者是为Orleans开发的一些新功能。这些项目适合在高级本科或研究生课程中授课，学生们学习云计算和现代分布式技术，并希望获得构建云应用程序的实际动手经验。我们不希望在这些项目中生成的代码直接贡献给这个存储库。 研究项目： 自动缩放。 在这个项目中，学生可以从探索现有的自动伸缩机制开始，以控制windowsazure中的资源分配( 自动调整应用程序块 ). 下一步包括探索由Orleans收集的各种统计数据和资源消耗指标，并将它们用作Azure自动缩放的输入。该项目的高级阶段可能涉及改善Orleans内部对弹性变化作出反应的机制，例如通过实施实时演员迁移来减少利用新资源所需的时间。 为基于Orleans的云服务自动生成前端 . 这个项目将Orleans actor模型无缝地扩展到HTTP世界中。项目的升级部分包括根据参与者的.NET接口和元数据动态生成HTTP端点。主要部分包括自动生成前端以支持web套接字和双向数据流，这需要复杂的代码生成和优化以获得高性能。它还需要注意容错，在服务器重新启动、客户端重新连接和迁移过程中保持流式会话的高可用性，这是一个重大的研究挑战。 实体框架的存储提供程序 . 这个项目包括使Orleans对象能够将它们的状态存储在数据库中，并随后对其进行查询。这可能包括使用EntityFramework(EF)在SQLAzure数据库上添加对Orleans对象持久化的支持，EF是Microsoft针对.NET的开源对象关系映射器，并通过LINQ查询公开这些数据。可以使用标准数据库基准和/或定制的Orleans应用程序来评估和调整实现。 分布式系统基准测试 . 定义一个适用于像Orleans这样的分布式系统的基准测试列表。基准应用程序在精神上可能类似于 TPC数据库基准 或 UCB“平行矮星” 实施 在这里 可以用来描述分布式框架的性能和可伸缩性。例如，考虑为Orleans开发一个新的基准，以比较存储供应商的性能。 流上的声明性数据流语言 . 定义并构建 三叉戟风暴 就像OrleansStreams上的陈述性语言。开发一个优化程序来配置流处理以最小化总体成本。 客户端设备的编程模型 . 将Orleans扩展到客户端设备，如传感器、调用、平板电脑和台式机。启用Grain逻辑在客户端上执行。潜在地支持层分割，也就是说，动态地决定哪些部分的代码在设备上执行，哪些部分被卸载到云上。 对grain/actor类、二级索引的查询 . 建立一个分布式的、可扩展的、可靠的Grains指数。这包括正式定义查询模型和实现分布式索引。索引本身可以实现为OrleansGrains和/或存储在数据库中。 大规模模拟 . Orleans适合大规模的模拟建筑。探索Orleans在不同模拟中的应用，例如，蛋白质相互作用、网络模拟、模拟退火等。 课程项目： 物联网应用 . 例如，该应用程序可以使传感器/设备向云端报告其状态，在云中，每个设备都由Orleans的参与者表示。用户可以通过web浏览器连接到代表其设备的actor，并检查其状态或控制它。这个项目需要掌握许多现代云技术，包括 Windows Azure ，Orleans， 网络API 或者ASP.NET, 信号员 用于将命令从云端传输回设备，并编写传感器/设备/手机应用程序。 基于Orleans的云中类似Twitter的大型可伸缩聊天服务 . 每个用户都可以由一个Orleans演员代表，该演员包含其追随者列表。 基于Orleans的Faceboook类社交应用 . 每个用户可以由一个Orleans演员代表，其中包括一个朋友列表和朋友可以在上面写字的墙。 简单存储提供程序 . 为存储系统(如键值存储或数据库系统)添加存储提供程序。一个简单的人可以用 Orleans序列化程序 ，如现有的 Azure表存储提供程序 . 更复杂的方法是将Orleans类的状态变量映射到存储系统的细Grain结构。复杂的是上面提到的实体框架存储提供程序 研究项目 . 比较不同类型和大小的参与者状态的不同存储提供程序的性能。 与其他分布式应用框架的比较 . 以为另一个应用程序框架编写的示例应用程序为例，例如 谷歌应用引擎 或 阿克卡 把它翻译成Orleans。通过比较应用程序，总结每个框架的相对优势和劣势。 已完成的研究项目： 下面是一些以前成功的研究项目的例子。 分布式日志分析、关联与调试 . 大型分布式系统的调试是一项具有挑战性的任务，因为在不同进程和不同机器上运行的分布式组件之间存在着大量的数据和复杂的动态交互。本项目的目标是分析现有技术，提出解决方案，然后实现原型工具，用于收集、关联和分析多机器分布式应用程序运行时环境中的应用程序错误日志文件数据。这包括从多个角度探索问题空间，包括： a. Approaches to efficient logging, collection and analysis of failure information from various log-capture mechanisms in a distributed Orleans runtime environment. b. Possible applications of machine learning to find log patterns that signal serious production issues, and then detecting these patterns in near real time as a production monitoring utility. c. Ways to help individual developers perform real-time debugging of run-time issues with their applications. This project was performed successfully and result in a published paper [PAD: Performance Anomaly Detection in Multi-Server Distributed Systems](http://research.microsoft.com/apps/pubs/?id=217109) and a proof of concept implementation of a distributed log analysis tool. Horton-分布式图形数据库 . Horton是一个研究项目，目标是建立一个存储、管理和查询大规模分布式图形的系统。它完全是作为一个Orleans应用程序实现的。该项目的结果是 出版物 以及一些非常成功的学生项目。"
  },
  "Documentation/resources/index.html": {
    "href": "Documentation/resources/index.html",
    "title": "Resources | Microsoft Orleans 中文文档",
    "keywords": "资源资源 贡献 对于要为Orleans做贡献的开发人员的一些说明和准则。 文件指南 Orleans文档内置在Markdown中。我们使用一些简单的约定来确保整个文档的风格统一。 链接 链接到Orleans团队成员和其他人的文章。 简报 有关主题的PowerPoint演示文稿的集合，这些主题包括“Orleans最佳实践”，“平衡技术”和“流”。"
  },
  "Documentation/streaming/streams_why.html": {
    "href": "Documentation/streaming/streams_why.html",
    "title": "Why Orleans Streams? | Microsoft Orleans 中文文档",
    "keywords": "为什么是OrleansStreams？ 已经有很多技术可以让你构建流处理系统。这些系统包括 持久存储流数据 (例如。， 活动中心 和 卡夫卡 )以及要表达的系统 计算操作 过流数据(例如。， Azure流分析 , 阿帕奇风暴 ，和 Apache Spark流媒体 ). 这些都是很好的系统，允许您构建高效的数据流处理管道。 现有系统的局限性 但是，这些系统不适合 细Grain自由格式流上计算数据 . 上面提到的流计算系统都允许您指定 以相同方式应用于所有流项目的操作的统一数据流图 . 当数据是统一的，并且您希望对这些数据表示相同的转换、过滤或聚合操作时，这是一个功能强大的模型。但是还有一些用例需要在不同的数据项上表达根本不同的操作。在其中一些应用程序中，作为处理的一部分，您有时需要进行外部调用，例如调用任意restapi。统一数据流处理引擎要么不支持这些场景，要么以有限和受限的方式支持它们，要么效率低下。这是因为它们天生就针对 大量类似的物品，通常在表现力、加工方面受到限制 . OrleansStreams针对的是其他场景。 动机 这一切都是从Orleans用户请求支持从grain方法调用返回项目序列开始的。你可以想象，这只是冰山一角。他们实际上需要的远不止这些。 Orleans Streams的一个典型场景是当您有每个用户的流并且您希望执行 每个用户的不同处理 ，在单个用户的上下文中。我们可能有数百万用户，但他们中的一些人对天气感兴趣，可以订阅特定地点的天气预报，而有些人则对体育赛事感兴趣；还有人在跟踪某一航班的状态。处理这些事件需要不同的逻辑，但您不希望运行流处理的两个独立实例。一些用户只对特定的股票感兴趣，而且只有在应用某个外部条件时才感兴趣，这种情况可能不一定是流数据的一部分(因此需要在运行时作为处理的一部分进行动态检查)。 用户一直在改变他们的兴趣，因此他们对特定事件流的订阅是动态的，因此 流媒体的拓扑结构动态而快速地变化 . 除此之外， 每个用户的处理逻辑也会根据用户状态和外部事件动态地演化和更改 . 外部事件可以修改特定用户的处理逻辑。例如，在一个游戏作弊检测系统中，当发现一种新的作弊方式时，需要用新规则更新处理逻辑来检测这种新的违规行为。这当然需要做 不会中断正在进行的处理管道 . 批量数据流处理引擎并不是为了支持这样的场景而构建的。 几乎不用说，这样的系统必须运行在多台网络连接的机器上，而不是在一个节点上。因此，处理逻辑必须以可伸缩和弹性的方式分布在服务器集群上。 新要求 我们确定了流处理系统的4个基本需求，这将使它能够针对上述场景。 灵活的流处理逻辑 支持高度动态的拓扑 细Grain流Grain 分配 灵活的流处理逻辑 我们希望系统支持不同的方式来表达流处理逻辑。我们上面提到的现有系统要求开发人员编写一个声明性的数据流计算图，通常是遵循函数式编程风格。这限制了处理逻辑的表达能力和灵活性。Orleans流与处理逻辑的表达方式无关。它可以表示为一个数据流(例如，使用 NET中的无功扩展(Rx) )；作为一个函数程序；作为一个声明性查询；或者在一般的命令逻辑中。逻辑可以是有状态的或无状态的，可能有副作用，也可能没有副作用，并且可以触发外部操作。所有的权力都属于开发者。 支持动态拓扑 我们希望系统能够支持动态演化的拓扑结构。我们上面提到的现有系统通常仅限于静态拓扑，这些拓扑在部署时是固定的，并且不能在运行时演化。在下面的数据流表达式示例中，在需要更改之前，一切都很简单。 流.GroupBy(x=>x.key)。提取(x=>x.field)。选择(x=>x+2)。平均窗口(x，5秒)。其中(x=>x>0.8)* 在中更改阈值条件 在哪里？ 过滤器，添加额外的 选择 语句或在数据流图中添加另一个分支并生成新的输出流。在现有系统中，如果不拆除整个拓扑结构并从头开始重新启动数据流，这是不可能的。实际上，这些系统将检查现有的计算，并将能够从最新的检查点重新启动。尽管如此，这样的重新启动对于一个实时产生结果的在线服务来说是破坏性的和昂贵的。当我们在讨论大量这样的表达式时，这种重新启动变得特别不切实际，这些表达式使用相似但不同的(每个用户、每个设备等)参数执行，并且这些参数不断变化。 我们希望系统允许在运行时通过向计算图中添加新的链接或节点，或通过更改计算节点内的处理逻辑来进化流处理图。 细Grain流Grain 在现有系统中，最小的抽象单元通常是整个流(拓扑)。然而，我们的许多目标场景要求拓扑中的单个节点/链路本身就是一个逻辑实体。这样每个实体都可以独立管理。例如，在包含多个链路的大流拓扑中，不同的链路可以具有不同的特性，并且可以在不同的物理传输上实现。一些链接可以通过TCP套接字，而其他链接可以通过可靠队列。不同的链接可以有不同的交付保证。不同的节点可以有不同的检查点策略，它们的处理逻辑可以用不同的模型甚至不同的语言来表达。这种灵活性在现有系统中通常是不可能的。 抽象单元和灵活性的论据类似于SoA(面向服务的体系结构)与参与者的比较。Actor系统允许更大的灵活性，因为每个Actor本质上都是一个独立管理的“微型服务”。类似地，我们希望流系统允许这种细Grain的控制。 分配 当然，我们的系统应该具有 “良好的分布式系统” . 其中包括： 可扩展性 -支持大量流和计算元素。 弹性 -允许添加/删除资源以根据负载增长/收缩。 可靠性 -对失败有弹性 效率 -有效利用底层资源 响应性 -启用近实时场景。 这些都是我们在考虑建造的要求 Orleans流媒体 . 澄清 ：Orleans当前不支持像上面的示例那样直接编写声明性数据流表达式。如前所述，当前的Orleans流媒体api是更低级的构建块 在这里 . 提供声明性的数据流表达式是我们未来的目标。 下一个 Orleans流编程API"
  },
  "Documentation/streaming/streams_programming_APIs.html": {
    "href": "Documentation/streaming/streams_programming_APIs.html",
    "title": "Orleans Streams Programming APIs | Microsoft Orleans 中文文档",
    "keywords": "Orleans流编程API 应用程序通过与众所周知的API非常相似的API与流交互 NET中的无功扩展(Rx) . 主要的区别是Orleans河的延伸是 异步 ，以使处理在Orleans的分布式和可扩展计算结构中更高效。 异步流 应用程序通过使用 流提供程序 获取流的句柄。您可以阅读有关流提供程序的更多信息 在这里 ，但现在您可以将其视为允许实现者自定义流行为和语义的流工厂： IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(Guid, \"MyStreamNamespace\"); 应用程序可以通过调用 GetStreamProvider 方法 Grains 类，或者调用 GrainClient.GetStreamProvider() 方法。 Orleans.Streams.IAsyncStream<T> 是一个 虚拟流的逻辑强类型句柄 . 它在精神上类似于OrleansGrains引用。访问 GetStreamProvider 和 GetStream 完全是本地的。关于 GetStream 是一个GUID和一个额外的字符串，我们称之为流命名空间(可以为null)。GUID和名称空间字符串一起构成流标识(与 GrainFactory.GetGrain ). GUID和命名空间字符串的组合为确定流标识提供了额外的灵活性。就像Grains7可能存在于Grains类型中一样 播放器 而不同的grains7可能存在于该grains类型中 聊天室Grains ，流123可能与流命名空间一起存在 播放事件流 并且不同的流123可以存在于流命名空间中 聊天室消息流 . 生产和消费 IAsyncStream<T> 同时实现 Orleans.Streams.IAsyncObserver<T> 和 Orleans.Streams.IAsyncObservable<T> 接口。这样，应用程序就可以使用流通过使用 Orleans.Streams.IAsyncObserver<T> 或者使用 Orleans.Streams.IAsyncObservable<T> . public interface IAsyncObserver<in T> { Task OnNextAsync(T item, StreamSequenceToken token = null); Task OnCompletedAsync(); Task OnErrorAsync(Exception ex); } public interface IAsyncObservable<T> { Task<StreamSubscriptionHandle<T>> SubscribeAsync(IAsyncObserver<T> observer); } 为了在流中生成事件，应用程序只调用 await stream.OnNextAsync<T>(event) 为了订阅流，应用程序调用 StreamSubscriptionHandle<T> subscriptionHandle = await stream.SubscribeAsync(IAsyncObserver) 争论 订阅同步 可以是实现 IAsyncObserver服务器 接口或lambda函数的组合来处理传入事件。更多选项 订阅同步 可通过 AsyncObservableExtensions 班级。 订阅同步 返回 StreamSubscriptionHandle<T> ，这是一个不透明的句柄，可用于从流中取消订阅(在精神上类似于异步版本的 不可分解 ). await subscriptionHandle.UnsubscribeAsync() 需要注意的是 订阅是为了Grains，而不是为了激活 . 一旦grain代码被订阅到流中，这个订阅将超过这个激活的生命周期，并且永远保持持久，直到grain代码(可能在不同的激活中)显式取消订阅。这是一个 虚拟流抽象 ：不仅所有流在逻辑上始终存在，而且流订阅也是持久的，并且在创建订阅的特定物理激活之后仍然有效。 多重性 一条Orleans河可能有多个生产者和多个消费者。生产者发布的消息将被传递给在消息发布之前订阅流的所有使用者。 此外，消费者可以多次订阅同一个流。每次订阅它都会返回一个唯一的 StreamSubscriptionHandle<T> . 如果一个grain(或客户端)订阅同一个流X次，它将接收相同的事件X次，每次订阅一次。消费者还可以从单个订阅中取消订阅。它可以通过调用以下命令来查找其当前的所有订阅： IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() 从故障中恢复 如果流的生产者死了(或者它的grains被停用)，它就不需要做什么了。下次这个grain想要生成更多事件时，它可以再次获得流句柄，并以相同的方式生成新的事件。 消费者的逻辑更复杂一些。正如我们前面所说的，一旦消费者的Grains被订阅到一个流中，这个订阅在该Grains明确取消订阅之前是有效的。如果流的消费者死亡(或其Grain被停用)并且流上生成了一个新事件，消费Grain将被自动重新激活(就像任何普通的OrleansGrains在向其发送消息时自动激活一样)。grain代码现在只需要提供一个 IAsyncObserver<T> 处理数据。使用者基本上需要重新附加处理逻辑作为 非激活异步 方法。为此，它可以调用： StreamSubscriptionHandle<int> newHandle = await subscriptionHandle.ResumeAsync(IAsyncObserver) 消费者使用它第一次订阅时获得的前一个句柄来“继续处理”。注意到 恢复异步 仅使用的新实例更新现有订阅 IAsyncObserver服务器 逻辑，并不会改变此使用者已订阅此流的事实。 消费者如何获得旧的订阅句柄？有两种选择。消费者可能保留了从原始状态返回的句柄 订阅同步 操作，现在可以使用它。或者，如果消费者没有把手，它可以询问 IAsyncStream<T> 对于其所有活动订阅句柄，通过调用： IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() 消费者现在可以恢复所有这些服务，如果愿意，也可以取消订阅。 评论： 如果消费Grains实施 IAsyncObserver服务器 直接接口( 公共类MyGrain<T>：Grain，IAsyncObserver<T> )，理论上不应要求重新附加 IAsyncObserver服务器 因此不需要调用 恢复异步 . 流式运行时应该能够自动发现grain已经实现了 IAsyncObserver服务器 只会调用那些 IAsyncObserver服务器 方法。但是，流式运行时当前不支持此功能，并且grain代码仍然需要显式调用 恢复异步 即使Grains工具 IAsyncObserver服务器 直接。支持这一点是我们的待办事项。 显式和隐式订阅 默认情况下，流使用者必须显式订阅流。此订阅通常由grain(或客户端)收到的指示其订阅的外部消息触发。例如，在聊天服务中，当用户加入聊天室时，他的Grains收到 加入聊天组 带有聊天名称的消息，这将导致用户grain订阅此聊天流。 此外，OrleansStreams也支持 “隐式订阅” . 在这个模型中，grains并没有显式地订阅流。这个grain是自动的，隐式的，仅仅基于它的grain标识和 隐式itstreamsubscription 属性。隐式订阅的主要价值是允许流活动自动触发Grain激活(从而触发订阅)。例如，使用SMS流，如果一个grain要生成一个流，而另一个grain要处理这个流，则生产者需要知道消费Grains的身份，并对其进行grain调用，告诉它订阅流。只有在那之后，它才能开始发送事件。相反，使用隐式订阅，生产者只需开始为流生成事件，消费Grain将自动激活并订阅流。在这种情况下，制作人根本不在乎谁在看事件 类型的Grains实现类 我的grains类型 可以声明属性 [隐式itstreamsubscription(“MyStreamNamespace”)] . 这将告诉流式运行时，当在标识为GUID XXX和 “MyStreamNamespace” 命名空间，则应将其传递到标识为XXX类型的grains 我的grains类型 . 也就是说，运行时映射流 <XXX，MyStreamNamespace> 消费grain <XXX，我的grains类型> . 存在 隐式itstreamsubscription 使流式处理执行阶段自动将此grains订阅到流，并将流事件传递给它。但是，grain代码仍然需要告诉运行时它希望如何处理事件。本质上，它需要附加 IAsyncObserver服务器 . 因此，当Grains被激活时，里面的Grains代码 非激活异步 需要调用： IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(this.GetPrimaryKey(), \"MyStreamNamespace\"); StreamSubscriptionHandle<T> subscription = await stream.SubscribeAsync(IAsyncObserver<T>); 写入订阅逻辑 下面是关于如何为各种情况编写订阅逻辑的指南：显式和隐式订阅、可倒带和不可倒带流。显式订阅和隐式订阅的主要区别在于，对于隐式订阅，grain对于每个流命名空间始终只有一个隐式订阅；无法创建多个订阅(没有订阅多重性)，也无法取消订阅，而grain逻辑总是只需要附加处理逻辑。这也意味着对于隐式订阅，永远不需要恢复订阅。另一方面，对于显式订阅，需要恢复订阅，否则如果再次订阅Grain，则会导致订阅多次。 隐式订阅： 对于隐式订阅，grain需要订阅以附加处理逻辑。这应该在谷仓里做 非激活异步 方法。Grains应该简单地执行 等待流式订阅同步(下一页…) 在它的 非激活异步 方法。这将导致此特定激活附加 OnNext 函数来处理该流。grains可以选择指定 StreamSequenceToken 作为 订阅同步 ，这将导致此隐式订阅从该令牌开始使用。永远不需要隐式订阅来调用 恢复异步 . public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); await stream.SubscribeAsync(OnNextAsync) } 显式订阅： 对于显式订阅，grain必须调用 订阅同步 订阅流。这将创建一个订阅，并附加处理逻辑。显式订阅将一直存在，直到取消订阅该Grain，因此，如果某个Grain被停用并重新激活，则该Grain仍然显式订阅，但不会附加任何处理逻辑。在这种情况下，Grains需要重新附加处理逻辑。为了做到这一点 非激活异步 ，grain首先需要通过调用 stream.GetAllSubscriptionHandles() . Grains必须执行 恢复异步 对于每个句柄，它希望继续处理或取消订阅已处理的任何句柄的异步。grains也可以选择指定 StreamSequenceToken 作为 恢复异步 调用，这将导致此显式订阅从该令牌开始使用。 public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); var subscriptionHandles = await stream.GetAllSubscriptionHandles(); if (!subscriptionHandles.IsNullOrEmpty()) subscriptionHandles.ForEach(async x => await x.ResumeAsync(OnNextAsync)); } 流顺序和序列标记 单个生产者和单个消费者之间的事件传递顺序取决于流提供者。 对于SMS，生产者通过控制生产者发布事件的方式来显式地控制消费者看到的事件顺序。默认情况下(如果 火上浇油 SMS provider的选项设置为false)，并且如果生产者等待 OnNextAsync 访问，事件按先进先出顺序到达。在SMS中，由制作者决定如何处理将由中断表示的传递失败 Task 由 OnNextAsync 调用。 Azure队列流不保证FIFO顺序，因为底层的Azure队列不保证故障情况下的顺序。(它们确实保证了无故障执行中的先进先出顺序。)当生产者将事件生成到Azure队列中时，如果排队操作失败，则由生产者尝试另一次排队，然后再处理潜在的重复消息。在传递端，Orleans流式处理运行时将事件从队列中取出，并尝试将其传递给消费者进行处理。Orleans流式处理运行时仅在成功处理后从队列中删除事件。如果传递或处理失败，则不会从队列中删除事件，稍后将自动重新出现在队列中。流式运行时将再次尝试传递它，因此可能会破坏FIFO顺序。上面的行为符合Azure队列的正常语义。 应用程序定义的顺序 ：要处理上述排序问题，应用程序可以选择指定自己的排序。这是通过 StreamSequenceToken ，它是不透明的 i可比较 对象，可用于对事件排序。制作者可以通过一个可选的 StreamSequenceToken 致 OnNext 调用。这个 StreamSequenceToken 将一直传递给消费者，并与活动一起交付。这样，应用程序就可以独立于流式运行时推理和重建其顺序。 可倒流 有些流只允许应用程序从最新的时间点开始订阅它们，而其他流则允许“返回时间”。后一种功能取决于底层队列技术和特定的流提供程序。例如，Azure队列只允许使用最新的排队事件，而EventHub允许从任意时间点(直到某个过期时间)重放事件。支持时间倒流的流称为 可倒流 . 可倒带流的使用者可以传递 StreamSequenceToken 致 订阅同步 调用。运行时将从这个开始向它传递事件 StreamSequenceToken . 空令牌表示消费者希望接收从最新开始的事件。 回放流的能力在恢复场景中非常有用。例如，考虑订阅流并定期检查其状态和最新序列标记的Grain。当从失败中恢复时，grain可以从最新的检查点序列令牌重新订阅同一个流，从而恢复而不会丢失自上一个检查点以来生成的任何事件。 事件中心提供程序 可倒带。你可以找到它的代码 在这里 . 短讯服务 和 Azure队列 提供程序不可倒带。 无状态自动扩展处理 默认情况下，Orleans流的目标是支持大量相对较小的流，每个流由一个或多个有状态Grain处理。总的来说，所有流的处理在大量规则的(有状态的)grains之间被切分。应用程序代码通过分配流ID和GrainID以及显式订阅来控制这种分片。 目标是分片状态处理 . 然而，还有一个有趣的场景 自动扩展无状态处理 . 在这个场景中，应用程序有少量的流(甚至一个大的流)，目标是无状态处理。例如，事件的全局流，其中的处理涉及对每个事件进行解码，并可能将其转发到其他流以进行进一步的有状态处理。在Orleans，可以通过 无状态工作者 Grains。 无状态自动扩展处理的当前状态： 这还没有实施。从订阅流的尝试 无状态工作者 grains将导致未定义的行为。 我们正在考虑支持这一选择 . Grains和Orleans客户 OrleansStreams 在Grains和Orleans的客户中都是一致的 . 也就是说，可以在grain内部和Orleans客户端中使用完全相同的api来生成和消费事件。这大大简化了应用程序逻辑，使得特殊的客户端api(如Grain observer)变得多余。 全面管理和可靠的流媒体酒吧 为了跟踪流订阅，Orleans使用一个名为 流媒体酒吧 作为流消费者和流生产者的交汇点。Pub-Sub跟踪所有流订阅，持久化它们，并将流消费者与流生产者匹配。 应用程序可以选择发布订阅数据的存储位置和存储方式。Pub-Sub组件本身被实现为grains(称为 公共地下室 )，它使用Orleans声明性持久化。 公共地下室 使用名为的存储提供程序 PubSubStore酒店 . 与任何Grain一样，您可以为存储提供程序指定实现。对于流式发布订阅，您可以更改 PubSubStore酒店 在silos构建时，使用思洛主机生成器： 下面将Pub-Sub配置为将其状态存储在Azure表中。 hostBuilder.AddAzureTableGrainStorage(\"PubSubStore\", options=>{ options.ConnectionString = \"Secret\"; }); 这样，发布订阅数据将持久地存储在Azure表中。对于初始开发，您也可以使用内存存储。除了Pub-Sub之外，Orleans流媒体运行时还从生产者向消费者传递事件，管理分配给活动使用流的所有运行时资源，并透明地从未使用的流中垃圾收集运行时资源。 配置 为了使用流，您需要通过思洛主机或群集客户端构建器启用流提供程序。您可以阅读有关流提供程序的更多信息 在这里 . 示例流提供程序设置： hostBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\") .AddAzureQueueStreams<AzureQueueDataAdapterV2>(\"AzureQueueProvider\", optionsBuilder => optionsBuilder.Configure( options=>{ options.ConnectionString = \"Secret\"; })) .AddAzureTableGrainStorage(\"PubSubStore\", options=>{ options.ConnectionString = \"Secret\"; }); 下一个 Orleans河流供应商"
  },
  "Documentation/streaming/streams_quick_start.html": {
    "href": "Documentation/streaming/streams_quick_start.html",
    "title": "Orleans Streams Quick Start | Microsoft Orleans 中文文档",
    "keywords": "OrleansStreams快速入门 本指南将向您展示设置和使用Orleans Streams的快速方法。要了解有关流功能的详细信息，请阅读本文档的其他部分。 所需配置 在本指南中，我们将使用基于简单消息的流，该流使用Grains消息传递将流数据发送给订阅者。我们将使用内存中的存储提供程序来存储订阅列表，因此对于实际的生产应用程序来说，这不是明智的选择。 在silos上，其中hostBuilder是ISiloHostBuilder hostBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\") .AddMemoryGrainStorage(\"PubSubStore\"); 在群集客户端上，其中clientBuilder是IClientBuilder clientBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\"); 现在，我们可以创建流，使用它们作为生产者发送数据，也可以作为订阅者接收数据。 生产活动 为流生成事件相对容易。您应该首先访问在上述配置中定义的流提供程序( 短信提供商 )，然后选择一个流并将数据推送到该流。 //Pick a guid for a chat room grain and chat room stream var guid = some guid identifying the chat room //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); 如您所见，我们的流具有GUID和名称空间。这将使识别唯一流变得容易。例如，一个聊天室的名称空间可以是“ Rooms”，GUID可以是拥有的RoomGrain的GUID。 在这里，我们使用一些已知聊天室的GUID。现在使用 OnNext 流的方法，我们可以将数据推送到它。让我们在计时器内并使用随机数进行操作。您也可以对流使用任何其他数据类型。 RegisterTimer(s => { return stream.OnNextAsync(new System.Random().Next()); }, null, TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000)); 订阅和接收流数据 为了接收数据，我们可以使用隐式/显式订阅，这在手册的其他页面中有完整介绍。在这里，我们使用隐式订阅，这更容易。当Grains类型想要隐式订阅流时，它使用属性 ImplicitStreamSubscription(命名空间)] 。 对于我们的情况，我们将定义如下的ReceiverGrain： [ImplicitStreamSubscription(\"RANDOMDATA\")] public class ReceiverGrain : Grain, IRandomReceiver 现在，每当像计时器中一样将某些数据推送到名称空间RANDOMDATA的流中时， 接收器grain 具有相同GUID的流将接收到该消息。即使当前不存在任何激活的Grains，运行时也会自动创建一个新的Grains并将消息发送给它。 为了使其正常工作，我们需要通过设置我们的订阅来完成订阅过程 OnNext 接收数据的方法。所以我们 接收器grain 应该调用给它 OnActivateAsync 像这样的东西 //Create a GUID based on our GUID as a grain var guid = this.GetPrimaryKey(); //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); //Set our OnNext method to the lambda which simply prints the data, this doesn't make new subscriptions await stream.SubscribeAsync<int>(async (data, token) => Console.WriteLine(data)); 我们都准备好了。唯一的要求是，某些事情会触发我们的生产者Grains的创建，然后它将注册计时器并开始向所有感兴趣的方发送随机整数。 同样，本指南跳过了许多细节，仅适合于展示大图。阅读本手册的其他部分以及有关RX的其他资源，以更好地了解可用的内容和方法。 反应式编程可以是解决许多问题的非常有效的方法。例如，您可以在订户中使用LINQ来过滤数字并做各种有趣的事情。 下一个 Orleans流编程API"
  },
  "Documentation/streaming/index.html": {
    "href": "Documentation/streaming/index.html",
    "title": "Orleans Streams | Microsoft Orleans 中文文档",
    "keywords": "OrleansStreams Orleans v.1.0.0增加了对编程模型的流扩展的支持。流扩展提供了一组抽象和API，使对流的思考和使用变得更简单，更可靠。流扩展允许开发人员编写以结构化方式对一系列事件进行操作的响应式应用程序。流提供程序的可扩展性模型使编程模型可与多种现有排队技术兼容并可移植，例如 活动中心 ， 服务总线 ， Azure队列 和 阿帕奇·卡夫卡 。无需编写特殊代码或运行专用进程来与此类队列进行交互。 我为什么要在乎？ 如果您已经知道所有 流处理 并且熟悉诸如 活动中心 ， 卡夫卡 ， Azure流分析 ， 阿帕奇风暴 ， Apache Spark流 和 .NET中的反应性扩展(Rx) ，您可能会问为什么要关心。 为什么我们还需要另一个流处理系统，以及Actor与流之间的关系？ “为什么OrleansStreams？” 是要回答这个问题。 程式设计模型 Orleans Streams编程模型背后有许多原则。 OrleansStreams是 虚拟 。即，流始终存在。它不是显式创建或销毁的，它永远不会失败。 流是 由...确定 流ID，仅 逻辑名称 由GUID和字符串组成。 OrleansStreams允许 在时间和空间上将数据生成与其处理脱钩 。这意味着流生产者和流使用者可能位于不同的服务器上，处于不同的时间，并且将承受故障。 OrleansStreams是 轻巧而动态 。Orleans Streaming Runtime旨在处理大量高速率来来去去的流。 Orleans流 绑定是动态的 。Orleans Streaming Runtime旨在处理Grains以高速率连接到流或从流中断开的情况。 Orleans流媒体运行时 透明地管理流消耗的生命周期 。应用程序订阅流之后，从那时起，即使存在故障，它也将接收流的事件。 OrleansStreams 跨Grains和Orleans客户统一工作 。 编程API 应用程序通过与众所周知的API非常相似的API与流进行交互 .NET中的反应性扩展(Rx) ， 通过使用 Orleans.Streams.IAsyncStream <T> 实现\\ Orleans.Streams.IAsyncObserver <T> 和 Orleans.Streams.IAsyncObservable <T> 接口。 在下面的典型示例中，设备生成一些数据，这些数据作为HTTP请求发送到云中运行的服务。在前端服务器中运行的Orleans客户端收到此HTTP调用，并将数据发布到匹配的设备流中： public async Task OnHttpCall(DeviceEvent deviceEvent) { // Post data directly into device's stream. IStreamProvider streamProvider = GrainClient.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<DeviceEventData> deviceStream = streamProvider.GetStream<DeviceEventData>(deviceEvent.DeviceId); await deviceStream.OnNextAsync(deviceEvent.Data); } 在下面的另一个示例中，聊天用户(实现为Orleans Grain)加入聊天室，获取该房间中所有其他用户生成的聊天消息流的句柄并进行订阅。请注意，聊天用户不需要了解聊天室的Grain本身(我们的系统中可能没有这种Grain)或该组中产生消息的其他用户。不用说，要生成聊天流，用户无需知道当前订阅了谁。这说明了如何将聊天用户在时间和空间上完全分离。 public class ChatUser: Grain { public async Task JoinChat(string chatGroupName) { IStreamProvider streamProvider = base.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<string> chatStream = streamProvider.GetStream<string>(chatGroupName); await chatStream.SubscribeAsync((string chatEvent) => Console.Out.Write(chatEvent)); } } 快速入门样本 的 快速入门样本 是对在应用程序中使用流的总体工作流程的快速概述。阅读后，您应该阅读 流编程API 对概念有更深入的了解。 流编程API 一个 流编程API 提供了有关编程API的详细说明。 流提供者 流可以通过各种形状和形式的物理通道出现，并且可以具有不同的语义。Orleans Streaming旨在通过以下概念支持这种多样性 流提供者 ，这是系统中的可扩展点。Orleans目前有两个流提供程序的实现：基于TCP 简单消息流提供者 和基于Azure队列 Azure队列流提供程序 。有关Steam Providers的更多详细信息，请访问： 流提供者 。 流语义 流订阅语义 ：Orleans Streams保证Stream Subscription操作的顺序一致性。具体来说，当消费者订阅流时，一旦 Task 如果代表订阅操作已成功解决，则使用者将看到订阅后生成的所有事件。此外，可倒带流允许通过使用以下内容从过去的任意时间点进行订阅 StreamSequenceToken (可以找到更多详细信息 这里 )。 个人流事件交付保证 ：单个事件传递的保证取决于单个流提供者。一些提供仅尽最大可能的一次传送(例如简单消息流(SMS))，而其他一些提供至少一次的传送(例如Azure队列流)。甚至可以构建一个将保证一次交付的流提供程序(我们还没有这样的提供程序，但是可以构建一个)。 活动交付单 ：事件顺序还取决于特定的流提供程序。在SMS流中，生产者通过控制其发布方式来显式控制消费者看到的事件的顺序。Azure队列流不保证FIFO顺序，因为基础Azure队列在故障情况下不保证顺序。应用程序还可以通过使用以下命令控制自己的流交付顺序 StreamSequenceToken 。 流实施 的 Orleans流实施 提供了内部实现的高级概述。 代码样本 可以找到有关如何在Grains中使用流式API的更多示例。 这里 。我们计划在将来创建更多样本。 更多材料 关于流的Orleans虚拟聚会 虚拟聚会的Orleans流媒体演示"
  },
  "Documentation/streaming/stream_providers.html": {
    "href": "Documentation/streaming/stream_providers.html",
    "title": "Orleans Stream Providers | Microsoft Orleans 中文文档",
    "keywords": "流提供者 Streams可以有不同的形状和形式。一些流可能通过直接TCP链接传递事件，而另一些流则通过持久队列传递事件。不同的流类型可能使用不同的批处理策略，不同的缓存算法或不同的反压程序。为避免将流应用程序限制为仅这些行为选择的一部分， 流提供者 是Orleans Streaming Runtime的可扩展性点，允许用户实现任何类型的流。这个扩展点在精神上类似于 Orleans存储提供商 。Orleans目前与许多流提供程序一起提供，包括： 简单消息流提供者 和 Azure队列流提供程序 。 简单消息流提供者 简单消息流提供程序，也称为SMS提供程序，通过利用常规的OrleansGrains消息传递通过TCP传递事件。由于SMS中的事件是通过不可靠的TCP链接传递的，因此SMS可以 不 确保可靠的事件传递，并且不会自动重新发送SMS流失败的消息。默认情况下，生产者的调用 stream.OnNextAsync 返回一个 Task 代表流使用者的处理状态，它告诉生产者使用者是否成功接收并处理了事件。如果此任务失败，则生产者可以决定再次发送同一事件，从而在应用程序级别上实现可靠性。尽管流消息传递是尽力而为的，但SMS流本身是可靠的。也就是说，Pub-Sub执行的订户到生产者绑定是完全可靠的。 Azure队列(AQ)流提供程序 Azure队列(AQ)流提供程序通过Azure队列传递事件。在生产者端，AQ流提供程序将事件直接排队到Azure队列中。在消费者方面，AQ Stream Provider管理一组 拉剂 从一组Azure队列中提取事件，并将事件传递给使用事件的应用程序代码。可以将拉动代理视为一种分布式“微服务”，即一种分区的，高度可用的弹性分布式组件。牵引剂在承载应用程序Grain的相同silos中运行。因此，无需运行单独的Azure工作角色来从队列中拉出。拉动代理程序，它们的管理，背压，平衡它们之间的队列以及将队列从故障代理程序切换到另一个代理程序的存在由Orleans Streaming Runtime完全管理，并且对于使用流的应用程序代码是透明的。 队列适配器 通过持久队列传递事件的不同流提供程序表现出相似的行为，并受到相似的实现。因此，我们提供了通用的可扩展 PersistentStreamProvider 允许开发人员插入不同类型的队列，而无需从头开始编写全新的流提供程序。 PersistentStreamProvider 使用一个 IQueueAdapter 组件，它抽象特定的队列实现细节，并提供使事件入队和出队的方法。其余的全部由内部逻辑处理 PersistentStreamProvider 。上面提到的Azure队列提供程序也以这种方式实现：它是 PersistentStreamProvider 使用一个 AzureQueueAdapter 。 下一个 Orleans流实施细节"
  },
  "Documentation/whats_new_in_orleans.html": {
    "href": "Documentation/whats_new_in_orleans.html",
    "title": "What's new in Orleans | Microsoft Orleans 中文文档",
    "keywords": "Orleans有什么新鲜事？ v2.3.2版 2019年5月9日 三个错误修复。 v2.3.1版 2019年4月26日 一些改进，一个bug修复，以及批处理流API。 v2.3.0版 2019年3月20日 主要改进 支持ASP.NET核心托管API(Microsoft.Extensions.Hosting). 感谢@galvesribeiro！ 将命名选项的自定义实现替换为Microsoft.Extensions.Options. EventHub流提供程序已升级到EvenHub 2.2.1，并与3.0.0兼容。 集群成员关系表中的旧死条目现在会自动清理，这对于托管使用新IP端点来重新启动silos的环境很有帮助。 默认情况下，允许在思洛进程中有效托管前端代码的托管客户端。 支持 IHostEnvironmentStatistics 在Linux上，它支持CPU和内存指标以及负载削减。感谢@martinothamar！ v2.3.0-rc2版 2019年3月13日 重构流批处理行为以支持批处理消费。 (5425)是唯一的变化。虽然从技术上讲，由于批处理流API的更改，它正在崩溃，但它不应该破坏任何正在工作的应用程序代码，因为批处理功能以前没有完全连接。在有线协议或持久化方面没有突破性的变化。此版本与2.x版本向后兼容。 v2.3.0-rc1版 2019年3月5日 主要改进 支持ASP.NET核心托管API(Microsoft.Extensions.Hosting). 将命名选项的自定义实现替换为Microsoft.Extensions.Options. EventHub流提供程序已升级到EvenHub 2.2.1，并与3.0.0兼容。 集群成员关系表中的旧死条目现在会自动清理，这对于托管使用新IP端点来重新启动silos的环境很有帮助。 默认情况下，允许在思洛进程中有效托管前端代码的托管客户端。 1.5.7版 2019年2月28日 从v2.x后移植的两个修复程序 不间断的错误修复 修复了多群集支持(#3974) 添加GSI缓存维护和测试(#5184) 2.2.0版 2018年12月13日 这个版本主要是为了支持ACID跨Grain事务，以达到生产就绪的质量。 此版本不包含任何重大更改，并且与2.0.*版本向后兼容，允许对正在运行的群集进行就地升级。 v2.1.0版 2018年9月28日 重大变化 新建计划程序( #3792个 ) 托管客户端( #3362个 ) 分布式事务管理器( #3820个 , #4502个 , #4538个 , #4566个 , #4568 , #4591 , #4599 , #4613 , #4609 , #4616 , #4608 , #4628 , #4638 , #4685 , #4714 , #4739 , #4768 , #4799 , #4781 , #4810个 , #4820个 , #4838个 , #4831个 , #4871个 , #4887个 ) 新代码生成器( #4934个 , #5010号 , #5011号 ) 支持交易中的协调转移( #4860个 , #4894个 , #4949个 , #5026个 , ＃5024 ) v1.5.6 2018年9月27日 自1.5.5版以来的改进和错误修复。 不间断的改进 使SocketManager中的MaxSockets可配置 ＃5033 。 v2.1.0-rc2 2018年9月21日 主要变化 新代码生成器( ＃4934 ， ＃5010 ， ＃5011 )。 v2.1.0-rc1 2018年9月14日 主要变化 交易(beta2)( ＃4851 ， ＃4923 ， ＃4951 ， ＃4950 ， ＃4953 ) 支持交易中的协调转移( ＃4860 ， ＃4894 ， ＃4949 ) v1.5.5 2018年9月7日 自1.5.4版以来的改进和错误修复。 不间断的错误修复 修复程序化订阅错误( ＃4943 -- ＃3843 ) 将消息序列化错误传播给访问者( ＃4944 -- ＃4907 ) 漏洞修复 添加StreamSubscriptionHandleFactory以代表功能订阅( ＃4943 -- ＃3843 )。从技术上来说，这虽然是一项重大突破，但它只会影响通过解决该问题(尝试与该方案一起用于SMS流)的程序化订阅功能的用户。 ＃3843 )。 v2.0.4 2018年8月7日 不间断的错误修复 如果使用dotnet核心msbuild但以完整的.net为目标，则将netcoreapp2.0用于msbuild目标dll。 ＃4895 ) v2.1.0 2018年8月28日 主要变化 新的调度程序( ＃3792 ) 托管客户端( ＃3362 ) 分布式事务管理器(测试版)( ＃3820 ， ＃4502 ， ＃4538 ， ＃4566 ， ＃4568 ， ＃4591 ， ＃4599 ， ＃4613 ， ＃4609 ， ＃4616 ， ＃4608 ， ＃4628 ， ＃4638 ， ＃4685 ， ＃4714 ， ＃4739 ， ＃4768 ， ＃4799 ， ＃4781 ， ＃4810 ， ＃4820 ， ＃4838 ， ＃4831 ， ＃4871 ， ＃4887 ) v2.0.4 2018年8月7日 自2.0.3以来的改进和错误修复。 不间断的错误修复 在.NET Core上运行时CoreFx /＃30781的解决方法( ＃4736 ) 修复.NET Core 2.1构建时代码生成( ＃4673 ) v1.5.4 2018年6月13日 v2.0.3 2018年5月14日 这是具有部分构建的第一个修补程序版本-仅更新了9个NuGet软件包： Microsoft.Orleans.OrleansRuntime Microsoft.Orleans.OrleansServiceBus Microsoft.Orleans.Runtime.Legacy Microsoft.Orleans.OrleansCodeGenerator.Build 微软Orleans核心遗产 微软Orleans交易 Microsoft.Orleans.OrleansCodeGenerator 微软Orleans核心 微软Orleans测试主机 其余软件包均保持在2.0.0不变，除了 Microsoft.Orleans.ServiceFabric 元软件包，版本为2.0.2。 v2.0.0 2018年3月28日 主要更改(自2.0.0-rc2开始) 所有包含的提供程序都从全局ClusterOptions获得ServiceId和ClusterId，并且在其自己的选项类上没有那些属性(＃4235，＃4277、4290) 使用字符串作为ServiceId而不是Guid(＃4262) v2.0.0-rc2 2018年3月12日 主要更改(自2.0.0-rc1开始) 新的“外观” API可简化流提供者各个方面的配置：持久流配置器 v2.0.0-rc1 2018年2月27日 重大更改(自2.0.0-beta3开始) 新的提供者生命周期模型将取代旧的模型 构建器模式和基于选项的组件和扩展配置 v2.0.0-beta3 2017年12月21日 社区虚拟聚会＃15 Orleans2.0与核心团队 2017年12月13日 介绍 v2.0.0-beta2 2017年12月12日 v1.5.3 2017年12月8日 v2.0.0-beta1 2017年10月26日 主要新功能 现在，大多数软件包都针对.NET Standard 2.0(这意味着它们可以在.NET Framework或.NET Core 2.0中使用)以及在非Windows平台上使用。 v1.5.2 2017年10月17日 v1.5.1 2017年8月28日 v1.5.0 2017年7月6日 主要新功能 通过ClientBuilder的非静态Grains客户端可以从同一应用程序域连接到多个Orleans群集，并从一个silos中连接到其他群集。 支持用于非停机升级的grain接口的版本控制。 支持自定义Grains存储策略和导演。 支持基于散列的Grains存储。 v1.4.2 2017年6月9日 v1.4.1 2017年3月27日 社区虚拟聚会＃14 OrleansFSM 与 约翰·阿扎里亚(John Azariah) 2017年3月22日 v1.4.0 2017年2月21日 主要新功能 改进了JournaledGrain，用于事件源，并支持基于地理分布的基于日志的一致性提供程序。 具有固定存储的每仓库应用程序组件的Grain Services的抽象，其工作负载通过集群一致性环进行分区。 支持不均匀分布的可用粮仓的异构silos。 Service Fabric的群集成员资格提供程序。 社区虚拟聚会＃13 升级Orleans应用程序 与 谢尔盖·拜科夫(Sergey Bykov) 和团队2017年2月8日 介绍 v1.4.0-beta 2017年2月1日 主要新功能 改进了JournaledGrain，用于事件源，并支持基于地理分布的基于日志的一致性提供程序。 具有固定存储的每仓库应用程序组件的Grain Services的抽象，其工作负载通过集群一致性环进行分区。 支持不均匀分布的可用粮仓的异构silos。 Service Fabric的群集成员资格提供程序。 社区虚拟聚会＃12 部署Orleans 与 雅库布·科内基(Jakub Konecki) 2016年12月8日 介绍 v1.3.1 2016年11月15日 社区虚拟聚会＃11 监控和可视化展示 与 理查德·阿斯特伯里 ， 丹·范德布姆 和 罗杰·克雷克 2016年10月13日 1.3.0版 2016年10月11日 v1.2.4 2016年10月5日 v1.3.0-beta2 2016年9月27日 显着的新功能 支持地理分布的多集群部署 ＃1108 ＃1109 ＃1800 添加了新的Amazon AWS基本Orleans提供程序 ＃2006 支持Grain方法中的分布式取消令牌 ＃1599 社区虚拟聚会＃10 核心团队与Orleans2.0的路线图 2016年8月25日 v1.2.3 2016年7月11日 1.2.2版 2016年6月15日 v1.2.1 2016年5月19日 v1.2.0 2016年5月4日 v1.2.0-beta 2016年4月18日 重大改进 根据Halo 5中使用的相同代码添加了EventHub流提供程序。 根据情况，吞吐量提高了5％至26％。 将30个功能测试以外的所有功能迁移到GitHub。 Grains状态不必扩展 Grains状态 不再(标记为 [过时] )，并且可以是简单的POCO类。 增加了对每类的支持 和 全局服务器端拦截器。 添加了对将Consul 0.6.0用作成员资格提供程序的支持。 支持C＃6。 切换到xUnit进行测试，以实现CoreCLR兼容性。 v1.1.3 2016年3月9日 社区虚拟聚会＃9 内姆·比拉(Nehme Bilal) 和 鲁本·邦德 谈论部署Orleans 与 山药 和 服务面料 2016年2月26日 社区虚拟聚会＃8.5 网络讨论 由主办 杰森·布拉格 2016年2月11日 社区虚拟聚会＃8 Orleans核心团队介绍路线图 2016年1月21日 v1.1.2 2016年1月20日 v1.1.1 2016年1月11日 社区虚拟聚会＃7 圣诞特辑- 叶文·鲍勃罗夫(Yevhen Bobrov) 上 Orleans卡 2015年12月17日 v1.1.0 2015年12月14日 社区虚拟聚会＃6 地理分布Orleansp的MSR博士 2015年10月23日 v1.0.10 2015年9月22日 v1.0.9 2015年7月15日 v1.0.8 2015年5月26日 社区虚拟聚会＃5 加布里埃尔·克利奥特(Gabriel Kliot) 于新OrleansStreaming API上发表2015年5月22日 v1.0.7 2015年5月15日 社区虚拟聚会＃4 鲁本·邦德 在FreeBay上使用Orleans的机会2015年4月15日 v1.0.5 2015年3月30日 社区虚拟聚会＃3 叶文·鲍勃罗夫(Yevhen Bobrov) 于Orleans的Uniform API上使用2015年3月6日 社区虚拟聚会＃2 Orleans团队现场问答和路线图2015年1月12日 Orleans开源v1.0更新(2015年1月) 社区虚拟聚会＃1 雅库布·科内基(Jakub Konecki) 关于事件来源的Grains2014年12月18日"
  },
  "1.5/Documentation/Event-Sourcing/LogConsistencyProviders.html": {
    "href": "1.5/Documentation/Event-Sourcing/LogConsistencyProviders.html",
    "title": "Included Log-Consistency Providers | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Built-In Log-Consistency Providers The Microsoft.Orleans.EventSourcing package includes several log-consistency providers that cover basic scenarios suitable to get started, and allow some extensibility. Orleans.EventSourcing. StateStorage .LogConsistencyProvider This provider stores grain state snapshots , using a standard storage provider that can be configured independently. The data that is kept in storage is an object that contains both the grain state (as specified by the first type parameter to JournaledGrain ) and some meta-data (the version number, and a special tag that is used to avoid duplication of events when storage accesses fail). Since the entire grain state is read/written every time we access storage, this provider is not suitable for objects whose grain state is very large. This provider does not support RetrieveConfirmedEvents : it cannot retrieve the events from storage because the events are not persisted. Orleans.EventSourcing. LogStorage .LogConsistencyProvider This provider stores the complete event sequence as a single object , using a standard storage provider that can be configured independently. The data that is kept in storage is an object that contains a List<EventType> object , and some meta-data (a special tag that is used to avoid duplication of events when storage accesses fail). This provider does support RetrieveConfirmedEvents . All events are always available and kept in memory. Since the whole event sequence is read/written every time we access storage, this provider is not suitable for use in production , unless the event sequences are guaranteed to remain pretty short. The main purpose of this provider is to illustrate the semantics of the event sourcing, and for samples/testing environments. Orleans.EventSourcing. CustomStorage .LogConsistencyProvider This provider allows the developer to plug in their own storage interface, which is then called by the conistency protocol at appropriate times. This provider does not make specific assumptions about whether what is stored are state snapshots or events - the programmer assumes control over that choice (and may store either or both). To use this provider, a grain must derive from JournaledGrain<StateType,EventType> , as before, but additionally must also implement the following interface: public interface ICustomStorageInterface<StateType, EventType> { Task<KeyValuePair<int,StateType>> ReadStateFromStorage(); Task<bool> ApplyUpdatesToStorage(IReadOnlyList<EventType> updates, int expectedversion); } The consistency provider expects these to behave a certain way. Programmers should be aware that: The first method, ReadStateFromStorage , is expected to return both the version, and the state read. If there is nothing stored yet, it should return zero for the version and a state that matches corresponds to the default constructor for StateType . ApplyUpdatesToStorage must return false if the expected version does not match the actual version (this is analogous to an e-tag check). If ApplyUpdatesToStorage fails with an exception, the consistency provider retries. This means some events could be duplicated if such an exception is thrown, but the event was actually persisted. The developer is responsible to make sure this is safe: e.g. either avoid this case by not throwing an exception, or ensure duplicated events are harmless for the application logic, or add some extra mechanism to filter duplicates. This provider does not support RetrieveConfirmedEvents . Of course, since the developer controls the storage interface anyway, they don't need to call this in the first place, but can implement their own event retrieval."
  },
  "1.5/Documentation/Event-Sourcing/Overview.html": {
    "href": "1.5/Documentation/Event-Sourcing/Overview.html",
    "title": "Event Sourcing | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Event Sourcing Event sourcing provides a flexible way to manage and persist grain state. An event-sourced grain has many potential advantages over a standard grain. For one, it can be used with many different storage provider configurations, and supports geo-replication across multiple clusters. Moreover, it cleanly separates the grain class from definitions of the grain state (represented by a grain state object) and grain updates (represented by event objects). The documentation is structured as follows: JournaledGrain Basics explains how to define an event-sourced grains by deriving from JournaledGrain , how to access the current state, and how to raise events that update the state. Replicated Instances explains how the event-sourcing mechanism handles replicated grain instances and ensures consistency. It discusses the possibility of racing events and conflicts, and how to address them. Immediate/Delayed Confirmation explains how delayed confirmation of events, and reentrancy, can improve availability and throughput. Notifications explains how to subscribe to notifications, allowing grains to react to new events. Configuration explains how to configure projects, clusters, and log-consistency providers. Built-In Log-Consistency Providers explains how the three currently included log-consistency providers work. Diagnostics explains how to monitor for connection errors, and get simple statistics. The behavior documented above is reasonably stable, as far as the JournaledGrain API is concerned. However, we expect to extend or change the list of log consistency providers soon, to more easily allow developers to plug in standard event storage systems."
  },
  "1.5/Documentation/Installation/NuGets.html": {
    "href": "1.5/Documentation/Installation/NuGets.html",
    "title": "Orleans NuGet Packages | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Nuget Packages Orleans NuGet packages as of v1.5.0 There are 4 key NuGet packages you will need to use in most scenarios: Microsoft Orleans Build-time Code Generation PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build Build support for grain interfaces and implementation projects. Add it to your grain interfaces and implementation projects to enable code generation of grain references and serializers. Microsoft.Orleans.Templates.Interfaces and Microsoft.Orleans.Templates.Grains packages are obsolete and provided only for backward compatibility and migration. Microsoft Orleans Core Library PM> Install-Package Microsoft.Orleans.Core Contains Orleans.dll, which defines most of Orleans public types and Orleans Client. Reference it for building libraries and client applications that use Orleans types but don't need any of the included providers. Microsoft Orleans Server Libraries PM> Install-Package Microsoft.Orleans.Server Includes everything you need to run a silo. Microsoft Orleans Client Libraries PM> Install-Package Microsoft.Orleans.Client Includes everything you need for an Orleans client (frontend). Additional Packages The below packages provide additional functionality. Microsoft Orleans Providers PM> Install-Package Microsoft.Orleans.OrleansProviders Contains a set of built-in persistence and stream providers, primarily for testing, as well as some abstractions and utility types for building persistence and stream providers. Included in Microsoft.Orleans.Client and Microsoft.Orleans.Server. Microsoft Orleans Event-Sourcing PM> Install-Package Microsoft.Orleans.EventSourcing Contains a set of base types for creating grain classes with event-sourced state. Providers and extensions Microsoft Orleans Azure Utilities PM> Install-Package Microsoft.Orleans.OrleansAzureUtils Contains Azure Table based cluster membership provider, wrapper classes that simplify instantiation of silos and clients in Azure Worker/Web roles, persistence providers for Azure Tables and Azure Blobs, and a stream provider for Azure Queues. Microsoft Orleans Sql Utilities PM> Install-Package Microsoft.Orleans.OrleansSqlUtils Contains SQL based cluster membership and persistence providers for use with SQL Server, MySQL, PostgreSQL, and other SQL databases. Microsoft Orleans ServiceBus Utilities PM> Install-Package Microsoft.Orleans.OrleansServiceBus Includes the stream provider for Azure Event Hubs. Microsoft Orleans Consul Utilities PM> Install-Package Microsoft.Orleans.OrleansConsulUtils Includes the plugin for using Consul for storing cluster membership data. Microsoft Orleans ZooKeeper Utilities PM> Install-Package Microsoft.Orleans.OrleansZooKeeperUtils Includes the plugin for using ZooKeeper for storing cluster membership data. Microsoft Orleans AWS Utilities PM> Install-Package Microsoft.Orleans.OrleansAWSUtils Includes DynamoDB based cluster membership provider, DynamoDB persistence provider, and SQS based stream provider. Microsoft Orleans Telemetry Consumer - Performance Counters PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.Counters Windows Performance Counters implementation of Orleans Telemetry API. Microsoft Orleans Telemetry Consumer - Azure Application Insights PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.AI Includes the telemetry consumer for Azure Application Insights. Microsoft Orleans Telemetry Consumer - NewRelic PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.NewRelic Includes the telemetry consumer for NewRelic. Microsoft Orleans Bond Serializer PM> Install-Package Microsoft.Orleans.Serialization.Bond Includes support for Bond serializer . Microsoft Orleans Google Utilities PM> Install-Package Microsoft.Orleans.OrleansGoogleUtils Includes Google Protocol Buffers serializer. Hosting and testing Microsoft Orleans Runtime PM> Install-Package Microsoft.Orleans.OrleansRuntime Core runtime library of Microsoft Orleans that hosts and executes grains within a silo. Microsoft Orleans Silo Host PM> Install-Package Microsoft.Orleans.OrleansHost Includes the default silo host - OrleansHost.exe. Can be used for on-premises deployments or as an out-of-process silo host in Azure Worker Role. Included in Microsoft.Orleans.Server. We are planning to deprecate this package in favor of customers building their custom silo host processes in order to simplify dependency management and programmatic configuration. Microsoft Orleans Service Fabric Support PM> Install-Package Microsoft.Orleans.ServiceFabric Support for hosting Microsoft Orleans on Service Fabric. Microsoft Orleans Testing Host Library PM> Install-Package Microsoft.Orleans.TestingHost Includes the library for hosting silos in a testing project. Microsoft Orleans Code Generation PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator Includes the run time code generator. Included in Microsoft.Orleans.Server and Microsoft.Orleans.Client. Tools Microsoft Orleans Performance Counter Tool PM> Install-Package Microsoft.Orleans.CounterControl Includes OrleansCounterControl.exe, which registers Windows performance counter categories for Orleans statistics and for deployed grain classes. Requires elevation. Can be executed in Azure as part of a role startup task. Included in Microsoft.Orleans.Server. Microsoft Orleans Management Tool PM> Install-Package Microsoft.Orleans.OrleansManager Includes Orleans management tool - OrleansManager.exe. We are planning to deprecate this package in favor of customers building their custom management tools in order to simplify dependency management and programmatic configuration."
  },
  "1.5/Documentation/Installation/Prerequisites.html": {
    "href": "1.5/Documentation/Installation/Prerequisites.html",
    "title": "Prerequisites | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Prerequisites Orleans is a set of .NET libraries delivered via NuGet packages . In order to use Orleans, you need .NET Framework 4.6.1 (since 1.5.0, 4.5.1 for prior versions) or higher and a copy of Visual Studio 2015 or higher. Note that the Express versions of Visual Studio do not support extension packages, but you can use Orleans by adding references to the NuGet packages directly. In production, Orleans requires persistent storage for reliable cluster membership. The following storage technologies are supported for managing cluster membership state (only need one of those): Azure Table Storage - Tested with Azure SDK 2.4 - 2.8 SQL Server 2008 or higher ZooKeeper 3.4.0 or higher MySQL 5.0 or higher PostgreSQL 9.5 or higher Consul 0.6.0 or higher DynamoDB - Tested with AWSSDK - Amazon DynamoDB 3.1.5.3 Another production deployment option is to use Azure Service Fabric . There is a NuGet package that helps with that. It has a dependency on Service Fabric 2.1.163."
  },
  "Tutorials/index.zh.html": {
    "href": "Tutorials/index.zh.html",
    "title": "Step by Step Tutorials | Microsoft Orleans 中文文档",
    "keywords": "这些教程适用于2.0版本 Orleans2.0是从1.x版本开始的重大改进。"
  },
  "Tutorials/Custom-Grain-Storage.zh.html": {
    "href": "Tutorials/Custom-Grain-Storage.zh.html",
    "title": "Custom Grain Storage | Microsoft Orleans 中文文档",
    "keywords": "自定义Grains存储 编写自定义Grains存储 在有关声明性参与者存储的教程中，我们研究了允许Grains使用内置存储提供程序之一将其状态存储在Azure表中。尽管Azure是松散数据的好地方，但还有许多替代方法。实际上，有太多的人无法支持所有人。取而代之的是，Orleans旨在让您通过编写Grains存储来轻松添加对您自己的存储形式的支持。 在本教程中，我们将逐步介绍如何编写基于文件的简单Grains存储。文件系统不是存储Grains状态的最佳位置，因为它是本地的，文件锁可能存在问题，并且最后更新日期不足以防止不一致。但这是一个简单的示例，可以帮助我们说明 Grains储存 。 入门 OrleansGrains仓库是实现 IGrain存储 包含在其中 Microsoft.Orleans.Core NuGet程序包 。 我们也从 ILifecycleParticipant <ISiloLifecycle> 这将使我们能够订阅孤岛生命周期中的特定事件。 我们首先创建一个名为 FileGrainStorage 。 using Orleans; using System; using Orleans.Storage; using Orleans.Runtime; using System.Threading.Tasks; namespace GrainStorage { public class FileGrainStorage : IGrainStorage, ILifecycleParticipant<ISiloLifecycle> { private readonly string _storageName; private readonly FileGrainStorageOptions _options; private readonly ClusterOptions _clusterOptions; private readonly IGrainFactory _grainFactory; private readonly ITypeResolver _typeResolver; private JsonSerializerSettings _jsonSettings; public FileGrainStorage(string storageName, FileGrainStorageOptions options, IOptions<ClusterOptions> clusterOptions, IGrainFactory grainFactory, ITypeResolver typeResolver) { _storageName = storageName; _options = options; _clusterOptions = clusterOptions.Value; _grainFactory = grainFactory; _typeResolver = typeResolver; } public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } } } 在开始实施之前，我们创建一个包含根目录的选项类，Grains状态文件将存储在该目录下。为此，我们将创建一个选项文件 FileGrainStorageOptions ： public class FileGrainStorageOptions { public string RootDirectory { get; set; } } 创建一个包含两个字段的构造函数， storageName 指定使用此存储应该写入哪些纹理 [StorageProvider(ProviderName =“文件”)] 和 目录 这将是保存grains状态的目录。 IGrain工厂 ， ITypeResolver 将在下一部分中使用，我们将在其中初始化存储。 我们也有两个选择，我们自己 FileGrainStorageOptions 和 集群选项 。实现存储功能将需要这些。 我们还需要 JsonSerializerSettings 因为我们正在以Json格式进行序列化和反序列化。 Json是一个实现细节，由开发人员决定哪种串行化/反序列化协议适合该应用程序。另一种常见格式是二进制格式。 初始化存储 要初始化存储，我们注册一个 在里面 功能上 应用服务 生命周期。 public void Participate(ISiloLifecycle lifecycle) { lifecycle.Subscribe(OptionFormattingUtilities.Name<FileGrainStorage>(_storageName), ServiceLifecycleStage.ApplicationServices, Init); } 的 在里面 功能用于设置 _jsonSettings 将用于配置 Json 序列化器。同时，我们创建文件夹来存储grains状态(如果尚不存在)。 private Task Init(CancellationToken ct) { // Settings could be made configurable from Options. _jsonSettings = OrleansJsonSerializer.UpdateSerializerSettings(OrleansJsonSerializer.GetDefaultSerializerSettings(_typeResolver, _grainFactory), false, false, null); var directory = new System.IO.DirectoryInfo(_rootDirectory); if (!directory.Exists) directory.Create(); return Task.CompletedTask; } 我们还提供了一个通用函数来构造文件名，以确保每个服务，GrainID和Grain类型的唯一性。 private string GetKeyString(string grainType, GrainReference grainReference) { return $\"{_clusterOptions.ServiceId}.{grainReference.ToKeyString()}.{grainType}\"; } 阅读状态 要读取grains状态，我们使用先前定义的函数获取文件名，并将其组合到来自选项的根目录中。 public async Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (!fileInfo.Exists) { grainState.State = Activator.CreateInstance(grainState.State.GetType()); return; } using (var stream = fileInfo.OpenText()) { var storedData = await stream.ReadToEndAsync(); grainState.State = JsonConvert.DeserializeObject(storedData, _jsonSettings); } grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } 我们使用 fileInfo.LastWriteTimeUtc 作为ETag，其他功能将使用该ETag进行不一致检查以防止数据丢失。 请注意，对于反序列化，我们使用 _jsonSettings 这是在 在里面 功能。这对于能够正确地序列化/反序列化状态很重要。 写作状态 写入状态类似于读取状态。 public async Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings); var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists && fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (WriteState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } using (var stream = new StreamWriter(fileInfo.Open(FileMode.Create, FileAccess.Write))) { await stream.WriteAsync(storedData); } fileInfo.Refresh(); grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } 与阅读类似，我们使用 _jsonSettings 写状态。当前的ETag用于检查文件的UTC中的最后更新时间。如果日期不同，则意味着同一粒Grains的另一次激活会同时更改状态。在这种情况下，我们将 InconsistentStateException 这将导致当前激活被杀死，以防止覆盖先前由其他激活grains保存的状态。 清算国 如果文件存在，则清除状态将删除该文件。 public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists) { if (fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (ClearState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } grainState.ETag = null; grainState.State = Activator.CreateInstance(grainState.State.GetType()); fileInfo.Delete(); } return Task.CompletedTask; } 出于同样的原因 写状态 ，我们在继续删除文件并重置ETag之前检查是否存在不一致，并检查当前ETag是否与上次写入时间UTC相同。 把它放在一起 之后，我们将创建一个工厂，该工厂将使我们可以将选项设置的范围限定在提供程序名称上，同时创建一个实例。 FileGrainStorage 简化向服务集合的注册。 public static class FileGrainStorageFactory { internal static IGrainStorage Create(IServiceProvider services, string name) { IOptionsSnapshot<FileGrainStorageOptions> optionsSnapshot = services.GetRequiredService<IOptionsSnapshot<FileGrainStorageOptions>>(); return ActivatorUtilities.CreateInstance<FileGrainStorage>(services, name, optionsSnapshot.Get(name), services.GetProviderClusterOptions(name)); } } 最后，要注册Grains储存库，我们在 ISiloHostBuilder 在内部使用以下方式将Grains存储注册为命名服务 .AddSingletonNamedService(...) ，由提供的扩展 Orleans 。 public static class FileSiloBuilderExtensions { public static ISiloHostBuilder AddFileGrainStorage(this ISiloHostBuilder builder, string providerName, Action<FileGrainStorageOptions> options) { return builder.ConfigureServices(services => services.AddFileGrainStorage(providerName, options)); } public static IServiceCollection AddFileGrainStorage(this IServiceCollection services, string providerName, Action<FileGrainStorageOptions> options) { services.AddOptions<FileGrainStorageOptions>(providerName).Configure(options); return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); } } 我们的 FileGrainStorage 实现两个接口， IGrain存储 和 ILifecycleParticipant <ISiloLifecycle> 因此，我们需要为每个接口注册两个命名服务： return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); 这使我们能够使用扩展名添加文件存储。 ISiloHostBuilder ： var silo = new SiloHostBuilder() .UseLocalhostClustering() .AddFileGrainStorage(\"File\", opts => { opts.RootDirectory = \"C:/TestFiles\"; }) .Build(); 现在，我们将可以与供应商一起装饰Grains [StorageProvider(ProviderName =“文件”)] 它将以谷Grain态存储在选项中设置的根目录中。"
  },
  "Documentation/grains/grain_versioning/deploying_new_versions_of_grains.html": {
    "href": "Documentation/grains/grain_versioning/deploying_new_versions_of_grains.html",
    "title": "部署新版本的Grains | Microsoft Orleans 中文文档",
    "keywords": "部署新版本的Grains 滚动升级 通过这种方法，您可以直接在环境中部署较新的Silo。这是最简单的方法，但是可能很难中断正在进行的部署并回滚。 推荐配置： DefaultCompatibilityStrategy 调成 BackwardCompatible DefaultVersionSelectorStrategy 调成 AllCompatibleVersions var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(AllCompatibleVersions); }) [...] 使用此配置时，“旧”客户端将能够与两个版本的silos上的激活进行对话。较新的客户端和silos只会在较新的silos上触发新的激活。 使用预生产环境 在这种方法中，您将需要第二个环境(预生产环境)，在该环境中您将在停止生产环境之前部署较新的Silo。生产和预生产Silos和客户端将作为 同一集群的一部分 。两个环境中的silos可以相互通信，这一点很重要。 推荐配置： DefaultCompatibilityStrategy 调成 BackwardCompatible DefaultVersionSelectorStrategy 调成 MinimumVersion var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(MinimumVersion); }) [...] 建议的部署步骤： “V1” silos和客户端已部署并正在生产插槽中运行。 “V2” silos和客户端开始在预生产插槽中启动。他们将与生​​产广告位加入同一集群。到目前为止，将不会创建“V2”激活。 在预生产插槽中的部署完成后，开发人员可以重定向V2客户端上的某些流量(烟雾测试，目标Beta用户等)。这将创建V2激活，但是由于Grains是向后兼容的，并且所有Silo都在同一集群中，因此不会创建重复的激活。 如果验证成功，请继续进行VIP交换。如果没有，您可以安全地关闭预生产群集：如果需要，现有的V2激活将被销毁，而V1激活将被创建。 V1激活自然会最终“迁移”到V2 Silo。您可以安全地关闭V1 silos。 [！警告!]请记住，无状态工作器没有版本控制，流代理也将在预生产环境中启动。"
  },
  "Documentation/grains/grain_versioning/version_selector_strategy.html": {
    "href": "Documentation/grains/grain_versioning/version_selector_strategy.html",
    "title": "版本选择器策略 | Microsoft Orleans 中文文档",
    "keywords": "版本选择器策略 当集群中存在相同grains接口的多个版本，并且必须创建新的激活时， 兼容版本 将根据中定义的策略进行选择 GrainVersioningOptions.DefaultVersionSelectorStrategy 。 开箱即用的Orleans支持以下策略： 所有兼容版本(默认) 使用此策略，将在所有兼容版本中随机选择新激活的版本。 例如，如果我们有给定的grains接口的两个版本，即V1和V2： V2与V1向后兼容 集群中有2个支持V2的silos，有8个支持V1的silos 该请求是从V1客户/silos发出的 在这种情况下，新激活将有20％的机会成为V2，而有80％的机会将是V1。 最新版本 使用此策略，新激活的版本将始终是最新的兼容版本。 例如，如果我们有给定的grains接口的两个版本，即V1和V2(V2向后或与V1完全兼容)，则所有新激活将为V2。 最低版本 使用此策略，新激活的版本将始终是请求的版本或最低兼容版本。 例如，如果给定的Grain接口有2个版本，即V2，V3，则所有版本都完全兼容： 如果请求是从V1客户端/silos发出的，则新的激活将是V2 如果请求是从V3客户端/silos发出的，则新的激活也将是V2"
  },
  "Documentation/grains/event_sourcing/event_sourcing_configuration.html": {
    "href": "Documentation/grains/event_sourcing/event_sourcing_configuration.html",
    "title": "Configuration | Microsoft Orleans 中文文档",
    "keywords": "配置 配置项目引用 grains接口 和以前一样，接口只依赖于 微软.orleans.core 包，因为grain接口独立于实现。 Grains实现 日志需要从 行程<s，e> 或 日志记录<s> ，定义见 Microsoft.Orleans.EventSourcing 包裹。 日志一致性提供程序 我们目前包括三个日志一致性提供程序(用于状态存储、日志存储和自定义存储)。这三个都包含在 Microsoft.Orleans.EventSourcing 包装也一样。因此，所有被记录的Grains都已经可以获得这些。有关这些提供程序的功能和区别的说明，请参见 包括日志一致性提供程序 . 群集配置 日志一致性提供程序的配置与任何其他Orleans提供程序一样。例如，要包含所有三个提供者(当然，您可能不需要全部三个提供者)，请将此添加到 <Globals> 配置文件的元素： <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.StateStorage.LogConsistencyProvider\" Name=\"StateStorage\" /> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"LogStorage\" /> <Provider Type=\"Orleans.EventSourcing.CustomStorage.LogConsistencyProvider\" Name=\"CustomStorage\" /> </LogConsistencyProviders> 同样可以通过编程实现。移动到2.0.0稳定，客户端配置和集群配置不再存在！它现在已经被一个clientbuilder和一个silobuilder所取代(注意没有集群构建器)。 builder.AddLogStorageBasedLogConsistencyProvider(\"LogStorage\") Grains类属性 每个记录的Grains类必须有 日志一致性提供程序 属性指定日志一致性提供程序。一些提供商还要求 存储提供程序 属性。如：[存储提供程序(providername=“orleanslocalstorage”)][logconsistencyprovider(providername = \"logstorage\")]公共类事件源dbankAccountGrain:JournaledGrain ，IEventSourceBankAccountGrain{} 所以这里“orleanslocalstorage”被用来存储grain状态，其中“logstorage”是eventsourcing事件的内存存储提供程序。 LogConsistencyProvider属性 要指定日志一致性提供程序，请添加 [日志一致性提供程序(providername=…)] 属性，并提供由群集配置配置配置的提供程序的名称。例如： [LogConsistencyProvider(ProviderName = \"CustomStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain, ICustomStorage { ... } StorageProvider属性 一些日志一致性提供程序(包括 日志存储 和 状态存储 )使用标准的StorageProvider与存储通信。此提供程序使用单独的 存储提供程序 属性，如下所示： [LogConsistencyProvider(ProviderName = \"LogStorage\")] [StorageProvider(ProviderName = \"AzureBlobStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain { ... } 默认提供程序 可以省略 日志一致性提供程序 和/或 存储提供程序 属性，如果在配置中指定了默认值。这是通过使用特殊的名称来完成的 违约 各自的供应商。例如： <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"Default\" /> </LogConsistencyProviders> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> </StorageProviders>"
  },
  "Documentation/grains/event_sourcing/journaledgrain_diagnostics.html": {
    "href": "Documentation/grains/event_sourcing/journaledgrain_diagnostics.html",
    "title": "JournaledGrain Diagnostics | Microsoft Orleans 中文文档",
    "keywords": "JournaledGrain诊断 监视连接错误 通过设计，日志一致性提供程序在出现连接错误(包括与存储的连接以及群集之间的连接)时具有弹性。但是仅仅容忍错误是不够的，因为应用程序通常需要监视任何此类问题，并在严重时提请操作员注意。 当观察到连接错误并解决了这些错误时，JournaledGrain子类可以重写以下方法来接收通知： protected override void OnConnectionIssue(ConnectionIssue issue) { /// handle the observed error described by issue } protected override void OnConnectionIssueResolved(ConnectionIssue issue) { /// handle the resolution of a previously reported issue } ConnectionIssue 是一个抽象类，有几个公共字段描述该问题，包括自上次成功连接以来已观察到此问题的次数。连接问题的实际类型由子类定义。连接问题分为以下几种类型： PrimaryOperationFailed 要么 NotificationFailed ，有时还有多余的键(例如 RemoteCluster )，进一步缩小了类别。 如果同一类别的问题多次发生(例如，我们不断收到以相同的 RemoteCluster 为目标的 NotificationFailed )，每次由 OnConnectionIssue 。解决此类问题后(例如，我们终于可以成功向此发送通知 RemoteCluster )， 然后 OnConnectionIssueResolved 被调用一次，与 问题 上次报告的对象 OnConnectionIssue 。独立类别的连接问题及其解决方案将独立报告。 简单统计 目前，我们为基本统计信息提供了简单的支持(将来，我们可能会用更标准的遥测机制来代替它)。通过调用可以为JournaledGrain启用或禁用统计信息收集 void EnableStatsCollection() void DisableStatsCollection() 可以通过调用获取统计信息 LogConsistencyStatistics GetStats()"
  },
  "Documentation/grains/event_sourcing/notifications.html": {
    "href": "Documentation/grains/event_sourcing/notifications.html",
    "title": "通知 | Microsoft Orleans 中文文档",
    "keywords": "通知 有能力对状态变化作出反应通常是很方便的。所有回调都受orleans的基于轮换的保证的约束；另请参见关于并发保证的一节。 跟踪确认状态 如果确认状态发生任何变化， 日志记录 子类可以重写此方法： protected override void OnStateChanged() { // read state and/or event log and take appropriate action } 状态已更改 每当确认的状态更新(即版本号增加)时调用。这可能发生在 已从存储中加载状态的新版本。 此实例引发的事件已成功写入存储。 从其他实例接收到通知消息。 注意，由于所有的grains最初都有版本0，直到存储的初始加载完成，这意味着 状态已更改 在初始加载完成且版本大于零时调用。 跟踪暂定状态 如果临时状态有任何变化， 日志记录 子类可以重写此方法： protected override void OnTentativeStateChanged() { // read state and/or events and take appropriate action } ontentativestatechanged 当暂定状态改变时调用，即如果组合序列(confirmedEvents+confirmedEvents)改变。特别是，回调 ontentativestatechanged() 总是发生在 葡萄干 ."
  },
  "Documentation/grains/event_sourcing/journaledgrain_basics.html": {
    "href": "Documentation/grains/event_sourcing/journaledgrain_basics.html",
    "title": "JournaledGrain API | Microsoft Orleans 中文文档",
    "keywords": "日志训练基础 日记grains来源于 <journaledgrain<statetype，事件类型> ，具有以下类型参数： 这个 状态类型 表示Grains的状态。它必须是具有公共默认构造函数的类。 事件类型 是可为此Grain引发的所有事件的通用父类型，可以是任何类或接口。 所有状态和事件对象都应该是可序列化的(因为日志一致性提供程序可能需要持久化它们，和/或在通知消息中发送它们)。 对于事件是pocos(普通的旧c对象)的Grains， 日志记录<statetype> 可用作 journaledgrain<statetype，对象> 是的。 解读grain状况 要读取当前grains状态并确定其版本号，journaledgrain具有属性 GrainState State { get; } int Version { get; } 版本号始终等于已确认事件的总数，状态是将所有已确认事件应用于初始状态的结果。初始状态的版本为0(因为没有应用任何事件)，由grainstate类的默认构造函数确定。 重要： 应用程序不应直接修改 State 是的。这本书仅供阅读。相反，当应用程序想要修改状态时，它必须通过引发事件间接地进行修改。 引发事件 通过调用 葡萄干 功能。例如，一个代表聊天的Grains可以引发 后遗症 要指示用户提交了帖子，请执行以下操作： RaiseEvent(new PostedEvent() { Guid = guid, User = user, Text = text, Timestamp = DateTime.UtcNow }); 请注意 葡萄干 启动对存储的写入访问，但不等待写入完成。对于许多应用程序，必须等到我们确认事件已被持久化。在这种情况下，我们总是等待 证实人 以下内容： RaiseEvent(new DepositTransaction() { DepositAmount = amount, Description = description }); await ConfirmEvents(); 请注意，即使您没有显式调用 证实人 ，事件最终将得到确认-它在后台自动发生。 状态转换方法 运行时更新Grains状态 自动 每当事件发生时。应用程序不需要在引发事件后显式更新状态。但是，应用程序仍然必须提供指定 怎样 更新状态以响应事件。这可以通过两种方式来实现。 (一) grainstate类可以实现一个或多个 应用 方法论 状态类型 是的。通常，会创建多个重载，并为事件的运行时类型选择最接近的匹配： class GrainState { Apply(E1 @event) { // code that updates the state } Apply(E2 @event) { // code that updates the state } } (二) grains可以覆盖transitionState函数： protected override void TransitionState(State state, EventType @event) { // code that updates the state } 假设转换方法除了修改状态对象之外没有任何副作用，并且应该是确定性的(否则，效果是不可预测的)。如果转换代码抛出异常，则会捕获该异常并将其包含在日志一致性提供程序发出的Orleans日志中的警告中。 确切地说，运行时调用转换方法取决于所选的日志一致性提供程序及其配置。对于应用程序来说，最好不要依赖于特定的时间，除非日志一致性提供程序特别保证。 一些提供者，如 日志存储 日志一致性提供程序，每次加载Grain时重播事件序列。因此，只要事件对象仍然可以从存储中正确反序列化，就有可能从根本上修改grainstate类和转换方法。但对于其他提供商，如 状态存储 日志一致性提供程序，仅 Grain灰岩 对象是持久化的，因此开发人员必须确保从存储中读取时可以正确反序列化它。 引发多个事件 在调用confirmeEvents之前，可以多次调用raiseEvent： RaiseEvent(e1); RaiseEvent(e2); await ConfirmEvents(); 但是，这可能会导致两次连续的存储访问，并且只在写入第一个事件之后，Grains可能会失败。因此，通常最好使用 RaiseEvents(IEnumerable<EventType> events) 这保证了给定的事件序列以原子方式写入存储器。请注意，由于版本号始终与事件序列的长度匹配，因此引发多个事件会使版本号每次增加一个以上。 检索事件序列 下面的方法 日志记录 类允许应用程序检索所有已确认事件序列的指定段： Task<IReadOnlyList<EventType>> RetrieveConfirmedEvents(int fromVersion, int toVersion) 但是，并非所有日志一致性提供程序都支持它。如果不支持，或者序列的指定段不再可用，则 冒号 被扔了。 要检索最新确认版本之前的所有事件，可以调用 await RetrieveConfirmedEvents(0, Version); 只能检索已确认的事件：如果 Toversion 大于属性的当前值 版本 是的。 因为确认的事件永远不会改变，所以即使在存在多个实例或延迟确认的情况下，也不必担心比赛。但是，在这种情况下，有可能 版本 当await比当时恢复 检索确认事件 被调用，因此建议将其值保存在变量中。另请参阅关于并发保证的部分。"
  },
  "Documentation/grains/event_sourcing/index.html": {
    "href": "Documentation/grains/event_sourcing/index.html",
    "title": "Event Sourcing Overview | Microsoft Orleans 中文文档",
    "keywords": "活动来源 事件溯源提供了一种灵活的方式来管理和持久化Grain状态。与标准Grains相比，事件源Grains具有许多潜在优势。首先，它可以与许多不同的存储提供程序配置一起使用，并支持跨多个群集的地理复制。此外，它还将grain类与grain状态(由grain状态对象表示)和grain更新(由事件对象表示)的定义完全分离。 文件结构如下： 日志训练基础 解释如何通过从 日志记录 ，如何访问当前状态，以及如何引发更新状态的事件。 复制实例 解释事件源机制如何处理复制的grain实例并确保一致性。它讨论了比赛事件和冲突的可能性，以及如何解决它们。 立即/延迟确认 解释延迟的事件确认和重新进入如何提高可用性和吞吐量。 通知 解释如何订阅通知，允许Grains对新事件作出反应。 事件源配置 说明如何配置项目、群集和日志一致性提供程序。 内置日志一致性提供程序 解释当前包含的三个日志一致性提供程序的工作方式。 日志Grain诊断 解释如何监视连接错误，并获取简单的统计信息。 就journaledgrain api而言，上面记录的行为是相当稳定的。但是，我们希望很快扩展或更改日志一致性提供程序列表，以便更容易地允许开发人员插入标准事件存储系统。"
  },
  "blog/fix-visual-studio-2015-with-orleans-tools-for-visual-studio-1.4.0 installed.html": {
    "href": "blog/fix-visual-studio-2015-with-orleans-tools-for-visual-studio-1.4.0 installed.html",
    "title": "使用适用于Visual Studio 1.4.0的Orleans工具修复Visual Studio 2015 | Microsoft Orleans 中文文档",
    "keywords": "使用适用于Visual Studio 1.4.0的Orleans工具修复Visual Studio 2015 阿提拉·哈伊德里克(Attila Hajdrik) 2017/3/10上午10:06:17 今天，如果两个社区成员安装了Orleans VSIX软件包的1.4.0版本，就会受到Visual Studio 2015问题的打击。我们有一个公开的问题可以跟踪 的GitHub 。如果您在Visual Studio 2017上安装了扩展程序，它将可以正常工作，只有2015年有此问题。我们看到的问题是您无法打开“工具和扩展”窗口，VS将显示此错误对话框： 在研究解决方案时，我们未发布有问题的版本，并发布了该扩展的较旧版本，该扩展不适用于Visual Studio 2017，但都不会使Visual Studio 2015无法使用。如果您被此问题所困扰，请按照以下步骤进行修复： 1)退出所有Visual Studio实例。 2)打开管理员Visual Studio开发人员命令提示符。 3)cd / D“％USERPROFILE％\\本地设置，本地配置\\微软\\视觉工作室\\14.0\\扩展程序” 4)dir OrleansVSTools.dll / s 您将得到如下结果： C：\\ Users \\\\ Local Settings \\ Microsoft \\ VisualStudio \\ 14.0 \\ Extensions \\ pxzkggpq.50t的目录 2017/03/10下午02:36 18,608 OrleansVSTools.dll 1个文件18,608字节 5)将完整目录路径复制到剪贴板。 6)rmdir“” / q / s 确保您仍在Extensions目录中。 7)删除*.cache 8)devenv /设置 这可能会持续几分钟...请耐心等待。 现在，您可以启动Visual Studio 2015，并验证“扩展”对话框是否打开并且一切正常。 如果您为Visual Studio 2015配置了特殊的根后缀，则必须为该特定实例执行这些命令，因此不在14.0中执行，而可能在14.0Exp目录中执行。 更新2017年3月17日 我们发布了更新的VSIX，该VSIX可与VS2013，VS2015，VS2017一起正常使用： Microsoft Orleans Visual Studio工具"
  },
  "blog/solving-a-transactions-performance-mystery.html": {
    "href": "blog/solving-a-transactions-performance-mystery.html",
    "title": "解决交易绩效之谜 | Microsoft Orleans 中文文档",
    "keywords": "解决交易绩效之谜 鲁本·邦德 2018/12/7上午10:08:58 到达雷德蒙德并完成强制性的新员工入职培训后，我在Orleans团队的第一项任务就是协助进行一些持续的绩效调查，以确保内部人员可以使用Orleans的交易支持并因此而释放。 在针对我们的测试集群的压力/负载测试中，我们看到了严重的性能问题和大量事务失败。很大一部分事务一直暂停直到超时。 我们最初的调查集中在事务管理代码上。也许某个地方陷入僵局。我们采用了分而治之的方法，将内部交易组件替换为残存的变体。这个问题或多或少是孤立的 ITransactionalState <T> 实施取决于每个方面。事务状态负责加载和修改Grains状态并处理各种事务阶段(开始，准备，中止，提交，确认)，并使用读写器锁在隔离保证内优化多个重叠事务。您可以看到这不是一个小数目的代码，但是事实证明，进一步隔离问题是困难的，原因不仅仅限于以下事实：取出任何一段代码都没有显着改善。 分析数据对于性能调查至关重要，因此，在请求获得直接访问我们测试集群中机器的权限之后，我们使用以下方法收集了ETW日志： PerfView 使用与此类似的命令： PerfView.exe /acceptEULA /noGui /threadTime /zip /maxCollectSec:30 /dataFile:1.etl collect 分析结果 .etl 本地文件，查看 火焰图 对于堆栈跟踪样本，问题立即显而易见。 PerfView使问题的原因显而易见。 详细信息太小而无法在该视图上阅读，但是通过将鼠标悬停在每个小节上，我们可以看到堆栈框架代表哪种方法。箭头指向CPU等待锁的堆栈帧，在这种情况下，该锁位于全局.NET Timer队列中。向右的平稳期来自于为计时器队列提供服务并触发到期的计时器的线程，这也需要获取锁定。 我们的负载测试在.NET Framework 4.6.2上运行，因此 System.Threading.Timer 是使用 计时器的全局队列(链接列表) 由单个锁定对象保护。此队列上的任何操作都必须获得该锁。这是我们已经知道的，Orleans 2.1.0包含一个 PR减轻了此队列上的潜在锁争用 用于我们的主要计时器来源(响应超时计时器)。 交易代码从不使用 计时器 ，那为什么会有问题呢？交易利用 Task.Delay 用于多种任务，它显示在大多数组件中。这就是为什么我们不能将性能问题缩小到一段特定的代码的原因。 Task.Delay 使用一个 计时器 在引擎盖下，创建一个 计时器 可能会触发一次(如果未取消的话)，并在不再需要时注销它。我们的使用 Task.Delay 在负载下导致性能下降。 .NET Core 3.0用户可能从未见过这样的争用，因为.NET Core进行了大量工作以进行改进 计时器 和 Task.Delay 性能。看到 ＃14527 和 ＃20302 。 我们如何解决这一争执？在确认这里的修复程序实际上可以解决该问题(成功！)之后，我着手实施一个有希望的简单替代品 Task.Delay 。结果是 在这个公关 。其工作原理的要点是它使用单个 计时器 实例以服务线程本地计时器集合。计时器的点火不需要精确，因此在这些用途中不必担心延迟点火。通过使用线程局部数据结构可很大程度上避免锁争用，但通过使用轻量级Reentrant器可保留安全性 互锁比较交换 锁。看到 公关 更多细节。 该实施基于之前的工作 @dVakulen 在 ＃2060年 并导致吞吐量提高约4倍，而故障率降至零。谜团已揭开。"
  },
  "blog/index.html": {
    "href": "blog/index.html",
    "title": "Orleans Blog | Microsoft Orleans 中文文档",
    "keywords": "解决交易绩效之谜 鲁本·邦德 2018/12/7上午10:08:58 到达雷德蒙德并完成强制性的新员工入职培训后，我在Orleans团队的首要任务是协助进行一些持续的绩效调查，以确保内部人员可以使用Orleans的交易支持并因此而释放。 在针对我们的测试集群的压力/负载测试中，我们看到了严重的性能问题和大量事务失败。很大一部分事务一直暂停直到超时。 德米特里·瓦库连科(Dmitry Vakulenko) 谢尔盖·拜科夫(Sergey Bykov) 2018/11/19下午1:57:59 Dmitry Vakulenko三年前加入了Orleans开源社区，并开始提交侧重于提高Orleans代码库性能的请求。在核心团队的现任和前任成员之外，他成为了最多产的贡献者。 德米特里(Dmitry)也做出了其他改进，但他的激情始终是表现。由于增量优化的复合性质，随着时间的流逝，这些改进加起来达到了惊人的总和。我们的保守估计是，德米特里的贡献使Orleans的表现提高了约2.6倍。 宣布Orleans2.1 鲁本·邦德 2018/10/1下午7:17:59 今天，我们宣布了Orleans2.1。此版本包括对2.0的重大性能改进，对分布式事务支持的重大更新，新的代码生成器以及用于共同托管方案的新功能，以及较小的修复和改进。阅读 在这里发布说明 。"
  },
  "blog/latest-release-1.3.1.html": {
    "href": "blog/latest-release-1.3.1.html",
    "title": "最新版本-1.3.1 | Microsoft Orleans 中文文档",
    "keywords": "最新版本-1.3.1 谢尔盖·拜科夫(Sergey Bykov) 2016/12/1下午5:48:39 11月15日，我们发布了我们的 最新版本-1.3.1 。此修补程序版本自1.3.0起已合并到master中，其中包含许多错误修复和改进。1.3.1有两个主要原因。 343 Industries需要一个在流传输方面进行了一些改进的版本，以及EventHub流提供程序，以简化从Halo 5发布之前一直在运行的流发行堆栈的预发行版本的迁移。 Orleans卡 需要一个相当高级的功能，使他们可以在每个消息的基础上控制请求的交织。 @yevhen 提交了一份公关 为此，经过几次设计和实现迭代。 因此，1.3.1不是纯补丁程序发行版，因为它包含一项新功能。我们认为这里还可以，因为该功能实际上对其他人没有影响。 如果要从1.2.x或更早的版本升级到1.3.1，请注意在1.3.0中所做的细微更改。的 1.3.0发行说明 喊出来： 注意：此版本中有一个微妙的重大更改，很容易错过。 如果您正在使用 AzureSilo.Start(ClusterConfiguration配置，字符串DeploymentId) 在您的代码中，该重载已被删除，但是替换它的新重载具有相同的参数签名，但具有不同的第二个参数： (ClusterConfiguration配置，字符串connectionString) 。现在必须将部署ID作为config参数的一部分传递：config.Globals.DeploymentId。这样就消除了传递两个不同的部署ID的不确定性，但是不幸的是，这需要付出破坏性的API更改的代价。 1.3.0是一个相当大的版本，具有许多改进，错误修复以及地理分布的多集群的主要新功能。它的大部分内容都列在 1.3.0-beta2发行说明 。地理分布功能在 多集群支持部分 文档。"
  },
  "1.5/Tutorials/On-Premise-Deployment.html": {
    "href": "1.5/Tutorials/On-Premise-Deployment.html",
    "title": "On-Premise Deployment | Microsoft Orleans 中文文档",
    "keywords": "On-Premise Deployment Overview While using Orleans to implement cloud-based services is a core scenario, there is nothing that intrinsically ties it to the cloud as the sole platform. Orleans can just as well be deployed to the internal, on-premise, equipment of your organization's. In this tutorial, we describe the steps to take. Orleans based services are xcopy-deployable. All you need to do to deploy an Orleans based service to a set of machines is copy the following set of file to the target machines and start the OrleansHost.exe host process: Contents of the build folder of your host project (it can use Microsoft.Orleans.Host NuGet package or use your own console application running the Silo). OrleansConfiguration.xml file with configuration for the deployment to replace the default placeholder (If you use file based config). Binaries with grain interfaces and grain implementation classes of the service along with any external dependencies to Application<service name> subdirectory of the folder on the target with binaries of the host which should contain Orleans DLLs as well. This simple task may be accomplished in many different ways and with different tools, but the Orleans GitHub repo includes a set of PowerShell scripts ( https://github.com/dotnet/orleans/tree/master/misc/scripts/RemoteDeployment ) that provide a way to deploy an Orleans based service to a cluster of machines and remote start the hosting processes on them. There are also scripts for removing a service, monitoring its performance, starting and stopping it, and collecting logs. These are the scripts we found useful for ourselves while building and testing Orleans. Prerequisites The following table lists the prerequisites for deploying and running Orleans on a remote machine: .Net Framework 4.5 Orleans runs under the .Net Framework 4.5, which can be installed from this link: ( https://www.microsoft.com/en-us/download/details.aspx?id=30653 ) Powershell 2.0 with WinRM Windows 7 and Windows Server 2008 R2 should have these installed by default. For earlier versions of Windows, select the appropriate download from this article: ( https://support.microsoft.com/en-us/help/968929/windows-management-framework-windows-powershell-2.0,-winrm-2.0,-and-bits-4.0 ). To confirm you are running the required version of PowerShell, start a PowerShell window and type Get-Host – the resulting output needs to say \"Version: 2.0\" WinRM Configuration Both the source and target machines must be configured for remote operations: Open a PowerShell window as an Administrator and run the command below on the target machine (enter 'y' at the prompts): winrm quickconfig Increase PowerShell job memory Set the memory limit on remotely invoked jobs to 4Gb: Set-Item wsman:localhost\\Shell\\MaxMemoryPerShellMB 4096 To change it on a remote machine, use the following steps: Connect-WSMan -ComputerName <string> Set-Item wsman:<computerName>\\Shell\\MaxMemoryPerShellMB Disconnect-WSMan –ComputerName <string> PowerShell Execution Policy set to run remote scripts Open a PowerShell window as an Administrator and run the command below on the target machine (enter 'y' at the prompt): Set-ExecutionPolicy RemoteSigned This will set the machine to require signing for remote scripts only. Note that the user running the scripts must be a member of the Administrators Group on the remote machines. Deployment Steps In this tutorial , we will deploy the HelloWorld sample to a set of servers. The Orleans repo includes a RemoteDeployment folder ( https://github.com/dotnet/orleans/tree/master/misc/scripts/RemoteDeployment ) where everything we need can be found. Start by building the Hello World sample , commenting out (or removing) the silo initialization and shutdown code: static void Main(string[] args) { //AppDomain hostDomain = // AppDomain.CreateDomain(\"OrleansHost\", null, new AppDomainSetup //{ // AppDomainInitializer = InitSilo, // AppDomainInitializerArguments = args, //}); Orleans.GrainClient.Initialize(\"ClientConfiguration.xml\"); var friend = GrainClient.GrainFactory.GetGrain<HelloWorldInterfaces.IHello>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello(\"Good morning!\").Result); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); //hostDomain.DoCallBack(ShutdownSilo); } Also, start a new PowerShell window as Administrator and move to the RemoteDeployment folder. The basic steps to deploy Orleans code are: Setup a deployment manifest (Deployment.xml) . Adjust the Orleans server-side configuration (OrleansConfiguration.xml) to suit the environment. Run the PowerShell deployment scripts to deploy Orleans into your remote environment. Orleans Deployment Manifest The Orleans Deployment scripts use a manifest (XML) file to specify details of the deployment, including source and destination locations and local or remote machines to be deployed to. By making small changes to an existing deployment manifest xml file (typically by listing the different host machines), the same PowerShell scripts can deploy and run that Orleans system on a set of remote machines with equal ease as deploying and running that system on the local machine. The default file name for the manifest is Deployment.xml , and if you just modify this file, which is found in the RemoteDeployment folder, it will not be necessary to specify a different name. There are times, such as during testing, it may be advantageous to maintain multiple deployment files that specify a different set of silos. These other files may be specified explicitly to the deployment tools as specified in the respective sections below. A deployment manifest contains many different items, which collectively allow deployment of the Orleans runtime and applications onto a variety of local and remote configurations: Source location for the Orleans system runtime Located in the Path attribute of the <Deployment><Packages><Package> element where the Type attribute is set to \"System\". <Package Name=\"Orleans Runtime\" Type=\"System\" Path=\"..\\Binaries\\OrleansServer\" /> Source location for additional Orleans applications If you have any additional Orleans applications / grains to be included in this Orleans system, they are also located in the <Deployment><Packages><Package> nodes. The Type attribute must be set to \"Application\". <Package Name=\"HelloWorld\" Type=\"Application\" Path=\"..\\Binaries\\Applications\\HelloWorldGrains\" /> Source location for the server configuration file to be used by the Orleans host process Located in the Path attribute of the <Deployment><RuntimeConfiguration> element. The file name must be \"OrleansConfiguration.xml\" – if necessary, just change the path. <RuntimeConfiguration Path=\".\\OrleansConfiguration.xml\" /> Target location to install the Orleans server-side binaries on each machine Located in the <Deployment><TargetLocation> element. This must be an absolute local file system path (i.e. no \"..\" locations) that is valid on all the target hosts. <TargetLocation Path=\"C:\\Orleans\" /> The set of silos (host machines and optional silo names) this Orleans system should to be deployed to. Located in the <Deployment><Nodes><Node> elements. Typically: \"Primary\" on localhost , or multiple machines with one silo each. The HostName attribute specifies the machine name. The NodeName attribute specifies the name of the silo. Generally, this is arbitrary, with the exception that if multiple silos will run on any one machine, then silo names must be unique. <Nodes> <Node HostName=\"MACHINE1\" NodeName=\"Primary\" /> <Node HostName=\"MACHINE2\" NodeName=\"Node2\" /> <Node HostName=\"MACHINE3\" NodeName=\"Node3\" /> <Nodes /> Deployment Group ID This is a GUID which distinguishes one Orleans runtime system from another, even if both Orleans systems are running on the same machines. Located in the <Deployment> element. <Deployment Name=\"Deployment1\" DeploymentGroup=\"F219832A-1EE1-45DA-B35D-0BB3060C9FDA\" xmlns=\"urn:xcg-deployment\"> Orleans Silo Configuration Refer to Server Configuration for information on silo configuration. Orleans Powershell Scripts The following sections detail the PowerShell scripts provided with Orleans to aid with deployment and monitoring. (Use the /? option to get the latest usage info directly from the scripts.) Script Name Parameters Description DeployOrleansSilos.ps1 [$deploymentConfigFile] Copies the Orleans files to machines specified in the deploymentConfigFile (default is Deployment.xml). UndeployOrleansSilos.ps1 [$deploymentConfigFile] Stops and removes Orleans from the deployment servers deploymentConfigFile (default is Deployment.xml). MonitorOrleansSilos.ps1 [$deploymentConfigFile] [$networkInstance] [$samplesToLog] [$headerInterval] [$repeatHeaderInFile] Monitors CPU, Memory, Network Send, and Network Receive performance counters, and logs the data to files both as an aggregate of all data, and in separate files for each server. See usage text for details about the parameters. ShowOrleansSilos.ps1 [$deploymentConfigFile] Does a quick survey of the deployment silos and reports if Orleans is running on them. GatherOrleansSiloLogs.ps1 [$deploymentConfigFile] [$outputPath] Retrieve all log files from deployment silos and stores them in the specified output folder. UtilityFunctions.ps1 none Provides ancillary functionality to the other scripts. Deploying Orleans using Powershell Script Start a separate PowerShell command window as an administrator. Execute the DeployOrleansSilos.ps1 script, providing the location of the deployment configuration file (\"deployment.xml\" is the default and will be used if you don’t supply a value). .\\DeployOrleansSilos.ps1 .\\Deployment.xml The deployment will execute the following steps: Stop any running instances of Orleans that are running on the deployment machines. Copy the Orleans files and any application files that are listed in the deployment manifest. When the copy is completed, start the silos. This will pause after starting the first silo so that it is available for the other silos to register with. Pause to allow the start-up to complete. Report the progress of the deployment. When the deployment is complete, Orleans is ready for clients to connect to it. Confirming Orleans Status To determine if Orleans is running on the servers in the deployment manifest, run the ShowOrleansSilos.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. .\\ShowOrleansSilos.ps1 .\\Deployment.xml If everything works well, you should see something like this: PS C:\\Orleans\\misc\\scripts\\RemoteDeployment> .\\ShowOrleansSilos.ps1 .\\Deployment.xml OrleansHost running on host001: Process 1: 1340 OrleansHost running on host002: Process 1: 4320 2 processes running Running the Client We've edited the Hello World program not to start a silo in-process, but in order to run the client, the client configuration file DevTestClientConfiguratio.xml needs to be edited according to the Client Configuration section. The setup needs to conform to how the server was set up, specifically whether or not Azure Storage is used to keep track of the deployment configuration. In the author's setup, Azure is not involved, so the client configuration looks like this: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"host001\" Port=\"30000\"/> <Gateway Address=\"host002\" Port=\"30000\"/> <Statistics MetricsTableWriteInterval=\"30s\" PerfCounterWriteInterval=\"30s\" LogWriteInterval=\"300s\" WriteLogStatisticsToTable=\"true\"/> </ClientConfiguration> which corresponds to a server configuration that looks like this (relevant excerpts only): <Globals> <SeedNode Address=\"host001\" Port=\"11111\" /> <Liveness LivenessType =\"MembershipTableGrain\" /> ... </Globals> <Defaults> <Networking Address=\"\" Port=\"11111\" /> <ProxyingGateway Address=\"\" Port=\"30000\" /> ... </Defaults> Running the client in VS, I see this: ![](../Images/onpremise 1.PNG) Monitoring Orleans Once Orleans is deployed, you can start an optional script that will monitor the Orleans deployment using standard performance counters. Run a dedicated PowerShell command prompt as an administrator, and execute the .\\MonitorOrleans.ps1 script to start monitor performance counters for an Orleans Deployment. The following parameters configure the monitoring to suit individual circumstances: Parameter Default Description DeploymentConfigFile Deployment.xml The deployment manifest used to install Orleans. NetworkInstance corp The name of the network for the network performance counters. SamplesToLog 480 The number of samples to record in the current run. Use Ctrl-C to stop the script sooner. The default of 480, which taken in one minute intervals should continue for eight hours. HeaderInterval 10 The number of samples to write before repeating the header. RepeatHeaderInFile If this switch is present, the header will be repeated in the log file at the interval specified by the previous parameter. The script will store the data in the following types listed below. The files will be written to a folder called PerformanceData under the directory where the monitoring script is run from. File Type FileNameBase Description Machine Specific “PerfData-” + machine name + Date/Time stamp. Contains only the data for a single machine. If there are four machines in the deployment, then there will be four of these files. Combined “ConsolidatedPerfData-” + Date/Time stamp. Contains all of the data for all machines consolidated into a single file. Gathering Orleans Log Files To retrieve all log files from deployment silos and store them in the specified output folder, run the GatherOrleansSiloLogs.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. You may also specify an output folder where the collected log files will be stored otherwise a .\\logs subdirectory will be used by default. .\\GatherOrleansSiloLogs.ps1 .\\Deployment.xml .\\GatherOrleansSiloLogs.ps1 .\\Deployment.xml .\\MyLogs Removing Orleans When it is time to remove an Orleans deployment, use the UndeployOrleansSilos.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. .\\UnDeployOrleansSilos.ps1 .\\Deployment.xml Next We'll write our own storage provider, to save grain state to alternative to file instead of Microsoft Azure: Custom Storage Providers"
  },
  "1.5/Tutorials/Cloud-Deployment.html": {
    "href": "1.5/Tutorials/Cloud-Deployment.html",
    "title": "Cloud Deployment | Microsoft Orleans 中文文档",
    "keywords": "Cloud Deployment Deploying Orleans to Windows Azure This walkthrough shows the steps required to deploy the sample created in the Front Ends for Orleans Services to Windows Azure Cloud Services. In Azure, one or more worker roles will be used to host the Orleans silos, and an Azure web role will act as the presentation layer for the application and client to the application grains running in the Orleans silos. The same grain interfaces and implementation can run on both Windows Server and Windows Azure, so no special considerations are needed in order to be able to run your application in a Windows Azure hosting environment. The Azure Web Sample sample app provides a working example of how to run a web application with supporting Orleans silo cluster backend in an Azure hosted service, and the details are described below. Pre-requisites The following prerequisites are required: Visual Studio 2013 or 2015 Windows Azure SDK v2.4 or higher For more info on installing and working with Windows Azure in general, see the Microsoft Azure documentation web site: ( https://docs.microsoft.com/en-us/azure/ ) Create Azure Worker Role for Orleans Silos Right click on your solution, and select 'Add | New Project...'. Choose the 'Windows Azure Cloud Service' project template: When prompted, select a new 'Worker Role' to add to the project. This will be used to host the Orleans Silos: Add project references for Orleans Silo binaries Add references to the OrleansAzureSilo project for the required Orleans server library files. Copies of these files can be found in the .\\Binaries\\OrleansServer folder under the Orleans SDK. Orleans.dll OrleansAzureUtils.dll OrleansRuntime.dll OrleansProviders.dll (Only required if you your grains use the Declarative Persistence functionality.) Note: All of these references MUST have Copy Local = 'True' settings to ensure the necessary library DLLs get copied into the OrleansAzureSilo project output directory. Configure Azure Worker Role for Orleans Silos The Worker Role initialization class is a normal Azure worker role - it needs to inherit from the usual Microsoft.WindowsAzure.ServiceRuntime.RoleEntryPoint base class. The worker role initialization class needs to create an instance of Orleans.Runtime.Host.AzureSilo class, and call the appropriate Start / Run / Stop functions in the appropriate places: public class WorkerRole : RoleEntryPoint { AzureSilo silo; public override bool OnStart() { // Do other silo initialization – for example: Azure diagnostics, etc return base.OnStart(); } public override void OnStop() { silo.Stop(); base.OnStop(); } public override void Run() { var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); // Configure storage providers silo = new AzureSilo(); bool ok = silo.Start(config); silo.Run(); // Call will block until silo is shutdown } } It is IMPORTANT to start the silo not in OnStart but in Run. Azure may not have the firewalls open yet (on the remote silos) at the OnStart phase. Then, in the ServiceDefinition.csdef file for this role, add some required configuration items used by the Orleans Azure hosting library to the WorkerRole configuration: Add a ConfigurationSettings declaration named 'DataConnectionString'. This is the Azure storage location where Orleans Azure hosting library will place / look for its silo instance table. Add an InternalEndpoint declaration for a TCP endpoint named 'OrleansSiloEndpoint' Add an InternalEndpoint declaration for a TCP endpoint named 'OrleansProxyEndpoint' <ServiceDefinition ...> <WorkerRole name=\"OrleansAzureSilos\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" /> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> ... </WorkerRole> ... </ServiceDefinition> In the ServiceConfiguration.cscfg file for this role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings definition for 'DataConnectionString' This will be a normal Azure storage connection – either for the development storage emulator (only valid if running locally), or a full Azure storage account connection string for cloud-storage. In general, this connection string is likely to use the same configuration values as the Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString diagnostics connection string setting, but is not required to. Be careful to not mix up Azure storage and local storage. This can cause deployments to not work. See the Configure Azure Storage Connection Strings for more information. For example, to use local Developer Storage emulator (for local testing only) <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"UseDevelopmentStorage=true\" /> <Setting name=\"DataConnectionString\" value=\"UseDevelopmentStorage=true\" /> </ConfigurationSettings> Or using an Azure cloud storage account: <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> </ConfigurationSettings> Changing DataConnectionString The \"DataConnectionString\" setting in ServiceDefinition.csdef is the default name use by the Orleans silo for the Azure table account connection string that will be used for Orleans system tables such as OrleanSiloInstances . If you wish to use a different setting name for this value, then in the silo role initialization code set the property OrleansAzureSilo.DataConnectionConfigurationSettingName before the call to OrleansAzureSilo.Start(...) Add your grain binaries to Azure Worker Role for Orleans Silos Add the grain interfaces DLL and implementation classes DLL for the grains to be hosted in the Azure silo into the OrleansAzureSilo project, along with any supporting libraries those grains need. Note: You MUST ensure that all the referenced binaries are copied into the OrleansAzureSilo project output directory, to ensure they get picked up by the Azure packaging tools. Running Orleans Client as Azure Web Role The user interface / presentation layer for your application will usually run as a Web Role in Azure. The Orleans.Runtime.Host.AzureClient utility class is the main mechanism for bootstrapping connection to the Orleans silo worker roles from an Azure Web Role. A few additional configuration steps are needed to make the AzureClient utility class work – see below for details. Create Azure Web Role for Orleans Client Any type of web role can be used as an Orleans client, and there are no specific naming requirements or conventions for this project. Add a web role to the solution using the existing web application project that we created in the Front Ends for Orleans Services tutorial. Add project references for Orleans Client binaries. Add references to the web role project for the required Orleans client library files. Copies of these files can be found in either SDK-ROOT\\Samples\\References or SDK-ROOT\\Binaries\\OrleansClient directories. Orleans.dll OrleansAzureUtils.dll Note: All of these references MUST have Copy Local = 'True' settings to ensure the necessary library DLLs get copied into the web role project output directory. Configure Azure Web Role to be an Orleans Client In the ServiceDefinition.csdef file for this web role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings declaration named 'DataConnectionString'. This is the Azure storage location where Orleans Azure hosting library will place / look for its silo instance table. In addition, a http/s InputEndpoint will also need to be declared, just as for any other Azure web role config. <ServiceDefinition ...> <WebRole name=\"MyWebRole\" ...> ... <Sites> <Site name=\"Web\"> <Bindings> <Binding name=\"Endpoint1\" endpointName=\"Endpoint1\" /> </Bindings> </Site> </Sites> <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" /> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <Endpoints> <InputEndpoint name=\"Endpoint1\" protocol=\"http\" port=\"80\" /> </Endpoints> ... </WebRole> ... </ServiceDefinition> In the ServiceConfiguration.cscfg file for this role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings definition for 'DataConnectionString'. This will be a normal Azure storage connection – either for the development storage emulator (if running locally), or a full Azure storage account connection string for cloud-storage. This setting MUST match the DataConnectionString value used by the OrleansSiloWorker role in order for the client to discover and bootstrap the connection to the Orleans silos. For example, to use local Developer Storage emulator (for local testing only) <ServiceConfiguration ...> <Role name=\"OrleansWebClient\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"UseDevelopmentStorage=true\" /> <Setting name=\"DataConnectionString\" value=\"UseDevelopmentStorage=true\" /> </ConfigurationSettings> ... </Role> ... </ServiceConfiguration> Or using an Azure cloud storage account: <ServiceConfiguration ...> <Role name=\"OrleansWebClient\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> </ConfigurationSettings> ... </Role> ... </ServiceConfiguration> Add your grain interface binaries to Azure Web Role for Orleans Client Add the grain interfaces DLL for the application grains into this web role project. Access to the DLL containing the grain implementation classes should not be required by the client web role. Note: You MUST ensure that all the referenced binaries for grain interfaces and the generated proxy / factory libraries are copied into the web role project output directory, to ensure they get picked up by the Azure packaging tools. The grain implementation DLLs should not be required by the client and so should not be referenced by the web role. Initialize Client Connection to Orleans Silos It is recommended to bootstrap and initialize the client connection to the Orleans silo worker roles, to ensure a connection is set up before use in the Global.asax initialization methods. Edit the configuration of the client in the Global.asax.cs file to use AzureClient . namespace WebApplication1 { public class WebApiApplication : System.Web.HttpApplication { protected void Application_Start() { ... var config = AzureClient.DefaultConfiguration(); // Attempt to connect a few times to overcome transient failures and to give the silo enough // time to start up when starting at the same time as the client (useful when deploying or during development). const int initializeAttemptsBeforeFailing = 5; int attempt = 0; while (true) { try { AzureClient.Initialize(config); break; } catch (SiloUnavailableException e) { attempt++; if (attempt >= initializeAttemptsBeforeFailing) { throw; } Thread.Sleep(TimeSpan.FromSeconds(2)); } } ... Repeated calls to AzureClient.Initialize() will return and do nothing if the Orleans client connection is already set up. An additional variant of AzureClient.Initialize(System.IO.FileInfo) allows a base client config file location to be specified explicitly. The internal endpoint addresses of the Orleans silo nodes will still be determined dynamically from the Orleans Silo instance table each silo node registers with. <!--TODO: Create link to Orleans API when the link is created/found--> See the Orleans API docs for details of the various Initialize methods available. Deploying to Azure The normal Azure deployment tools are used to deploy the application to Windows Azure – either into the local Azure Compute Emulator for local development / test (Press F5 to run), or into the Azure cloud hosting environment right click on the Cloud project and select 'Publish': Next Let's look at the steps required to run Orleans on Windows Server: On-Premise Deployment"
  },
  "1.5/Tutorials/Unit-Testing-Grains.html": {
    "href": "1.5/Tutorials/Unit-Testing-Grains.html",
    "title": "Unit Testing Grains | Microsoft Orleans 中文文档",
    "keywords": "Unit Testing Grains This tutorial shows how to unit test your grains to make sure they behave correctly. There are two main ways to unit test your grains, and the method you choose will depend on the type of functionality you are testing. The Microsoft.Orleans.TestingHost NuGet package can be used to create test silos for your grains, or you can use a mocking framework like Moq to mock parts of the Orleans runtime that your grain interacts with. Using TestCluster The Microsoft.Orleans.TestingHost NuGet package contains TestCluster which can be used to create an in-memory cluster, comprised of two silos by default, which can be used to test grains. using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } Due to the overhead of starting an in-memory cluster you may wish to create a TestCluster and reuse it among multiple test cases. For example this can be done using xUnit's class or collection fixtures (see https://xunit.github.io/docs/shared-context.html for more details). In order to share a TestCluster between multiple test cases, first create a fixture type: public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } Next create a collection fixture: [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } You can now reuse a TestCluster in your test cases: using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHell(); Assert.Equal(\"Hello, World\", greeting); } } } xUnit will call the Dispose method of the ClusterFixture type when all tests have been completed and the in-memory cluster silos will be stopped. TestCluster also has a constructor which accepts TestClusterOptions that can be used to configure the silos in the cluster. Using Mocks Orleans also makes it possible to mock many parts of system, and for many of scenarios this is the easiest way to unit test grains. This approach does have limitations (e.g. around scheduling reentrancy and serialization), and may require that grains include code used only by your unit tests. The Orleans TestKit provides an alternative approach which side-steps many of these limitations. For example, let us imagine that the grain we are testing interacts with other grains. In order to be able to mock those other grains we also need to mock the GrainFactory member of the grain under test. By default GrainFactory is a normal protected property, but most mocking frameworks require properties to be public and virtual to be able to mock them. So the first thing we need to do is make GrainFactory both public and virtual property: public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } Now we can create our grain outside of the Orleans runtime and use mocking to control the behaviour of GrainFactory : using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); myGrain.Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())).Returns(journal.Object); await worker.DoWork(data) journal.Verfiy(x => x.Record(data), Times.Once()); } } } Here we create our grain under test, WorkerGrain , using Moq which means we can then override the behaviour of the GrainFactory so that it returns a mocked IJournalGrain . We can then verify that our WorkerGrain interacts with the IJournalGrain as we expect."
  },
  "1.5/Tutorials/My-First-Orleans-Application.html": {
    "href": "1.5/Tutorials/My-First-Orleans-Application.html",
    "title": "My First Orleans Application | Microsoft Orleans 中文文档",
    "keywords": "My First Orleans Application In this tutorial, we will walk through the steps to get the simplest possible Orleans application up and running, the all-too-familiar \"Hello World!\". We're using VS 2017, but it works equally well with VS 2012, VS 2013 and VS 2015. Before we start, there are three Orleans concepts that you will run into in this tutorial: that of a grain, a communication interface, and a silo. Grains Grains form the core of the Orleans programming model - they are distributed virtual actors. Grains are .NET classes that derive from a particular base class. It is easy to think about actors as objects that get dynamically instantiated on different servers and can invoke each other. They are distributed because interactions with grains may happen across process and computer boundaries, virtual because a particular grain may not be loaded in memory when another component sends it a message. If not present, the grain will be activated on-demand. Communication interfaces Communication interfaces describe how to communicate with grains. They are .NET interfaces extending a particular base interface. Silos Silos are containers of grains, potentially millions of grains in a single silo. Typically, you will run one silo per machine, but it sometimes make sense to run more than one on a single machine, when testing, for example. Getting Started Before getting started, make sure the Microsoft Orleans Tools for Visual Studio is installed. The plugin can be downloaded from: https://marketplace.visualstudio.com/items?itemName=sbykov.MicrosoftOrleansToolsforVisualStudio After starting Visual Studio, go to create a new project. Under \"Visual C#,\" you should see the following: Choose the \"Orleans Dev/Test Host\" project type, create a directory for the solution, and create the project: At this point go ahead and compile your project to download the packages. The project is just a console application populated with code that helps you host a silo in an environment that is \"developer friendly,\" i.e. where everything runs in a single process. The main code does three things: it creates a silo, initializes the Orleans client runtime, and waits for user input before terminating: static void Main(string[] args) { // First, configure and start a local silo var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"TestSilo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Silo started.\"); // Then configure and connect a client. var clientConfig = ClientConfiguration.LocalhostSilo(); var client = new ClientBuilder().UseConfiguration(clientConfig).Build(); client.Connect().Wait(); Console.WriteLine(\"Client connected.\"); // // This is the place for your test code. // Console.WriteLine(\"\\nPress Enter to terminate...\"); Console.ReadLine(); // Shut down client.Close(); silo.ShutdownOrleansSilo(); } Adding Some Grains At this point, we have everything we need except some actual Orleans-based code. Next we will create two more projects, one to hold the communication interface, and one to hold our grain. Separating the two is a best practice since the interface project is shared between the client and server-side, while the grains are implementation code and should be private to the server side. In addition to the Dev/Test host, there are two more Orleans projects, and we should create one of each in our solution: Once you have them in your solution, make sure to add a reference to the grain interface project from each of the other projects: the host, which will contain our client code, and the grain collection project. Add a reference for the grain collection project to the host project, so that it is automatically (re-)built and copied when starting the debugger. Open the IGrain1.cs file and add a method SayHello() to it. We should have something like this: public interface IGrain1 : IGrainWithIntegerKey { Task<string> SayHello(); } One of the important things is choosing a Key type for your grains, in this example we are using the Integer Key type. There are also Guids, strings and various compound keys that may meet your needs. Additionally, Orleans relies on TPL tasks in the interface method's return type -- an essential means to achieving scalability in the lightweight Orleans programming model is to use asynchronous I/O everywhere, and Orleans forces you to do so. Use Task or Task<T> as the return type of all methods of communication interfaces. Next, we turn our attention to the grain implementation, which is found in Grain1.cs . The first thing to do is make sure that the interface it implements is the right one: it should be MyGrainInterfaces1.IGrain1 , unless you renamed the project and/or the interface in the previous step. Then, we ask VS to generate the method stub for the one interface method we defined earlier: public Task<string> SayHello() { throw new NotImplementedException(); } We're finally ready to add the much-anticipated \"Hello World!\" code. Just return the string as the contents of a Task: public Task<string> SayHello() { return Task.FromResult(\"Hello World!\"); } OK, we're nearly done. All we need is a bit of client code. This will go in the Program.cs file in the Host project. In place of the comment following the call to GrainClient.Initialize() , add these two lines: var friend = client.GetGrain<MyGrainInterfaces1.IGrain1>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello().Result); That's it! Hit F5, let the silo initialization code take its time. This will take a few seconds, maybe as much as ten, and there will be a lot of log messages printed. At the very end, you should see the printout of the greeting. These are the essential steps to create and run Orleans-based code: define communication interfaces, implement them using grain classes, and write some client code to communicate with the grains in order to test them. In a realistic production environment, the grain code would be deployed in a silo hosted by Windows Azure or Windows Server and the client would most likely be a Web site or service using Orleans for the backend logic. However, that is just about making different configuration choices - the code in the simplified environment is the same as in the production environment. Next Next we'll see how we can run a minimal Orleans application. Minimal Orleans Application"
  },
  "1.5/Tutorials/Actor-Identity.html": {
    "href": "1.5/Tutorials/Actor-Identity.html",
    "title": "Actor Identity | Microsoft Orleans 中文文档",
    "keywords": "Actor Identity In object-oriented environments, the identity of an object is hard to distinguish from a reference to it. Thus, when an object is created using new, the reference you get back represents all aspects of its identity except those that map the object to some external entity that it represents. In distributed systems, object references cannot represent instance identity, since references are typically limited to a single address space. That is certainly the case for .NET references. Furthermore, a virtual actor must have an identity regardless of whether it is active, so that we can activate it on demand. Therefore grains have a primary key. The primary key can be either a GUID (A Globally Unique Identifier), a long integer, or a string. The primary key is scoped to the grain type. Therefore, the complete identity of a grain is formed from the actor type and its key. The caller of the grain decides a long, a GUID, or a string scheme should be used. In fact the underlying data is the same, so the schemes can be used interchangeably. When a long is used, a GUID is actually created, and padded with zeros. Situations that require a singleton grain instance, such as a dictionary or registry, benefit from using 0 (a valid GUID) as its key. This is merely a convention, but by adhering, it becomes clear at the call site that it is what is going on, as we saw in the first tutorial: Using GUIDs GUIDs are useful when there are several processes that could request a grain, such as a number of web servers in a web farm. You don't need to coordinate the allocation of keys, which could introduce a single point of failure in the system, or a system-side lock on a resource which could present a bottleneck. There is a very low chance of GUIDs colliding, so they would probably be the default choice when architecting an Orleans system. Referencing a grain by GUID in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(Guid.NewGuid()); Retrieving the primary key from grain code: public override Task OnActivateAsync() { Guid primaryKey = this.GetPrimaryKey(); return base.OnActivateAsync(); } Using Longs A long integer is also available, which would make sense if the grain is persisted to a relational database, where numerical indexes are preferred over GUIDs. Referencing a grain by long integer in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(1); Retrieving the primary key form grain code: public override Task OnActivateAsync() { long primaryKey = this.GetPrimaryKeyLong(); return base.OnActivateAsync(); } Using Strings A string is also available. Referencing a grain by String in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(\"myGrainKey\"); Retrieving the primary key form grain code: public override Task OnActivateAsync() { string primaryKey = this.GetPrimaryKeyString(); return base.OnActivateAsync(); } The stock ticker example used in the Interaction with Libraries and Services uses a string keys to activate grains representing different stock symbols. Using Compound Primary Key If you have a system that doesn't fit well with either GUIDs or longs, you can opt for a compound primary key which allows you to use a combination of a GUID or long and a string to reference a grain. You can inherit your interface from 'IGrainWithGuidCompoundKey' or 'IGrainWithIntegerCompoundKey\" interface like this: public interface IExampleGrain : Orleans.IGrainWithIntegerCompoundKey { Task Hello(); } In client code, this adds a second argument to the GetGrain method on the grain factory. var grain = GrainClient.GrainFactory.GetGrain<IExample>(0, \"a string!\", null); To access the compound key in the grain, we can call an overload on the GetPrimaryKey method: public class ExampleGrain : Orleans.Grain, IExampleGrain { public Task Hello() { string keyExtension; long primaryKey = this.GetPrimaryKey(out keyExtension); Console.WriteLine(\"Hello from \" + keyExtension); return TaskDone.Done; } } Next Let's add another type of grain into the solution, and demonstrate inter-grain communication. A Service is a Collection of Communicating Actors"
  },
  "1.5/Tutorials/Interaction-with-Libraries-and-Services.html": {
    "href": "1.5/Tutorials/Interaction-with-Libraries-and-Services.html",
    "title": "Interaction with Libraries and Services | Microsoft Orleans 中文文档",
    "keywords": "Interaction with Libraries and Services Code running in a grain is not prohibited from calling external systems or services, but the rule for always using asynchronous code must be maintained. In this sample we'll see how a grain can call out to an external service. Creating a Stock Grain For this sample, let's create a grain which maintains the current price for a stock. Create a grain interface project, and add an interface for an IStockGrain : public interface IStockGrain : Orleans.IGrainWithStringKey { Task<string> GetPrice(); } Note, we've opted for an string-based key for our grain, which is useful since the ticker symbol makes a natural key. The IGrainWithStringKey interface is new in the September refresh. Now add a grain implementation project, and add a reference to the interface project. Add a reference to System.Net.Http . We'll implement the grain so it retrieves the price of the stock when it is activated: public class StockGrain : Orleans.Grain, IStockGrain { // demo key might not work, claim yours at https://www.alphavantage.co/support/# private const string apiKey = \"demo\"; string price; public override async Task OnActivateAsync() { string stock; this.GetPrimaryKey(out stock); await UpdatePrice(stock); await base.OnActivateAsync(); } async Task UpdatePrice(string stock) { price = await GetPriceQuote(stock); } async Task<string> GetPriceQuote(string stock) { var uri = $\"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol={stock}&apikey={apiKey}&datatype=csv\"; using (var http = new HttpClient()) using (var resp = await http.GetAsync(uri)) { return await resp.Content.ReadAsStringAsync(); } } public Task<string> GetPrice() { return Task.FromResult(price); } } Next create some client code to connect to the Orleans Silo, and retrieve the grain state: Console.WriteLine(\"Waiting for Orleans Silo to start. Press Enter to proceed...\"); Console.ReadLine(); var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); // retrieve the MSFT stock var grain = GrainClient.GrainFactory.GetGrain<IStockGrain>(\"MSFT\"); var price = grain.GetPrice().Result; Console.WriteLine(price); Console.ReadLine(); When we start the local silo, and run the application, we should see the stock value written out symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.6875,20725407,2018-10-18,110.7100,-2.0225,-1.8268% Note that the extra text in the stock price is just the formatting that Alphavantage returned. Refreshing the value with a timer The problem with the grain as it stands is that the value of the stock will change, but the grain will maintain the same value for it's lifetime (an indefinite period of time). One way to fix this is to periodically refresh the price. A traditional .NET timer is not suitable for running in a grain. Instead, Orleans provides it's own timer. Let's re-factor the OnActivateAsync() method to introduce a timer which will call the UpdatePrice method in 1 minute, and then repeatedly every minute from then on, until the grain is deactivated: public override async Task OnActivateAsync() { string stock; this.GetPrimaryKey(out stock); await UpdatePrice(stock); RegisterTimer( UpdatePrice, stock, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1)); await base.OnActivateAsync(); } We'll also have to slightly adjust the UpdatePrice method, as the stock argument must be an object rather than a string. We'll also add some logging so we can see what's happening: async Task UpdatePrice(object stock) { price = await GetPriceQuote(stock as string); Console.WriteLine(price); } The RegisterTimer method takes four arguments: callback - A function to call. state - An object to pass as the first argument of the callback function (this can be null). dueTime - The period to wait before starting the first call to callback . period - The period between subsequent calls to callback . Note: In our sample we're passing the stock name as the state argument when we register the timer. This means the stock name is presented to the UpdatePrice method as the argument. Alternative we could set state to be null , and read the stock name from inside UpdatePrice using GetPrimaryKey . The method returns an IOrleansTimer which is disposable and can be used to stop the timer. It's a good idea to hold on to a reference to this in case you need to stop the timer. Now when we run the sample, the grain is activated, the timer gets registered and every minute the price is updated for us: symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3000,21747221,2018-10-18,110.7100,-2.4100,-2.1769% symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3100,21750728,2018-10-18,110.7100,-2.4000,-2.1678% symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3300,21762108,2018-10-18,110.7100,-2.3800,-2.1498% Orleans is acting as an automatically refreshing cache. Whenever a stock grain is queried Orleans will provide the latest price it has, without having to make a call to the stock web service. Parallelization Running code in a single threaded execution model, does not prohibit you from awaiting several tasks at once (or in parallel). Let's add a new function to retrieve the graph data for a stock: async Task<string> GetDailySeries(string stock) { var uri = $\"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={stock}&apikey={apiKey}&datatype=csv\"; using (var http = new HttpClient()) using (var resp = await http.GetAsync(uri)) { return await resp.Content.ReadAsStringAsync(); } } We'll also add a new field to the grain to store this information: string graphData; Now we can retrieve the graph data and current price like this: async Task UpdatePrice(object stock) { price = await GetPriceQuote(stock as string); graphData = await GetDailySeries(stock as string); Console.WriteLine(price); } However, by doing this we're waiting for the price from Yahoo, and after that's complete we request the graph data. This is inefficient, as we could be doing these at the same time. Fortunately, Task has a convenient WhenAll method which allows us to await multiple tasks at once, allowing these tasks to complete in parallel. async Task UpdatePrice(object stock) { // collect the task variables without awaiting var priceTask = GetPriceQuote(stock as string); var graphDataTask = GetDailySeries(stock as string); // await both tasks await Task.WhenAll(priceTask, graphDataTask); // read the results price = priceTask.Result; graphData = graphDataTask.Result; Console.WriteLine(price); } Note: The Result of a Task will block execution if the task hasn't completed. This should be avoided in Orleans, tasks should always be awaited before Result is read. Note: When a large number of asynchronous actions need to happen simultaneously you can collect the tasks in a List<Task<T>> and present this to Task.WhenAll . External Tasks It's tempting to use the Task Parallel Library \"TPL\" for executing parallel tasks in Orleans, but TPL uses the .NET thread pool to dispatch tasks. This is prohibited within grain code. Orleans has its own task scheduler which provides the single threaded execution model used within grains. It's important that when running tasks the Orleans scheduler is used, and not the .NET thread pool. Should your grain code require a sub-task to be created, you should use Task.Factory.StartNew : await Task.Factory.StartNew(() =>{ /* logic */ }); This technique will use the current task scheduler, which will be the Orleans scheduler. You should avoid using Task.Run , which always uses the .NET thread pool, and therefore will not run in the single-threaded execution model. Next Let's look at how Orleans can persist grain state for us: Declarative Persistence"
  },
  "1.5/Tutorials/Minimal-Orleans-Application.html": {
    "href": "1.5/Tutorials/Minimal-Orleans-Application.html",
    "title": "Minimal Orleans Application | Microsoft Orleans 中文文档",
    "keywords": "Minimal Orleans Application This tutorial provides step by step instructions for creating a basic functioning Orleans application. It is designed to be self-contained and minimalistic, with the following traits. It does not need the SDK or Extension to be installed, and relies on Nuget packages only. Has been tested in both Visual Studio 2013 and 2015 using Orleans 1.2.0. Has no reliance on SQL or Azure Keep in mind that this is only a tutorial and lacks appropriate error handling and other goodies that would be useful for a production environment. However, it should help the readers get a real hands-on with regards to different facets of Orleans and allow them to focus their continued learning on the parts most relevant to them. You can find the final source code in Samples\\Tutorial.Minimal folder ( see latest version online ). Project Setup For this tutorial we’re going to need to create 3 projects. A Library that contains the interfaces (Communication interfaces), a library that contains the implementation (called Grains), and a simple console application that will Host our Silo. For further understanding of this terminology please see the document Getting Started with Orleans . The Solution will eventually look like this. (Missing files will be added in the sections below) Within Visual Studio Create a blank solution called OrleansTest Create a New Console Application called Host Create a New class library called GrainInterfaces Create a New class library called GrainCollection We just use the default project types in c#. Delete the Extras Delete Class1.cs from GrainCollection Delete Class1.cs from GrainInterfaces Add the following References GrainCollection references GrainInterfaces Host references GrainInterfaces Host references GrainCollection Adding Orleans Orleans is available via Nuget. The primary goodness is in Microsoft.Orleans.Core but we will be including packages that provide additional functionality. Specifically, we will be using Template packages, which provide autocode generation for our grains and interfaces, and the Runtime which is used for hosting. With Nuget Add Microsoft.Orleans.OrleansCodeGenerator.Build to GrainInterfaces Add Microsoft.Orleans.OrleansCodeGenerator.Build to GrainCollection Add Microsoft.Orleans.OrleansRuntime to Host Creating our Grain Interface In GrainInterfaces create an interface IHello.cs public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string msg); } Creating our Implementation In GrainCollection create a class HelloGrain.cs class HelloGrain : Orleans.Grain, IHello { public Task<string> SayHello(string msg) { return Task.FromResult(string.Format(\"You said {0}, I say: Hello!\", msg)); } } Host The host requires the most amount of attention to get Orleans up and running. Throughout future tutorials, much of this will change, or go away (Orleans comes with a nice precanned SiloHost and the extension provides a template that simplifies this). However this small implementation should demonstrate the basics of getting started. Host – App.Config Change App.config to enable the recommended server garbage collection <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> Host – OrleansConfiguration.xml Within the Host project, add an XML file named OrleansConfiguration.xml. This will be used for cluster configuration. Make sure to set the Copy to Output directory file property to Copy if newer : <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"localhost\" Port=\"11111\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> It is possible to configure this within the code, but it is fairly difficult to do so. Host – Program.cs Program.cs is our lengthiest code block. We attempt to accomplish a number of objectives here Initialize Orleans in its own AppDomain Run a trivial task (DoSomeClientWork) Wait for the user to press enter Shutdown gracefully The Orleans samples come with a very nice class called HostWrapper, which abstracts some of the boiler plate within this example and is worth exploring for a more robust implementation. We're going to do this by hand in this tutorial. using Orleans.Runtime.Host; using Orleans; using System.Net; using System; class Program { static SiloHost siloHost; static void Main(string[] args) { // Orleans should run in its own AppDomain, we set it up like this AppDomain hostDomain = AppDomain.CreateDomain(\"OrleansHost\", null, new AppDomainSetup() { AppDomainInitializer = InitSilo }); DoSomeClientWork(); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); // We do a clean shutdown in the other AppDomain hostDomain.DoCallBack(ShutdownSilo); } static void DoSomeClientWork() { // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); var result = friend.SayHello(\"Goodbye\").Result; Console.WriteLine(result); } static void InitSilo(string[] args) { siloHost = new SiloHost(System.Net.Dns.GetHostName()); // The Cluster config is quirky and weird to configure in code, so we're going to use a config file siloHost.ConfigFileName = \"OrleansConfiguration.xml\"; siloHost.InitializeOrleansSilo(); var startedok = siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", siloHost.Name, siloHost.Type)); } static void ShutdownSilo() { if (siloHost != null) { siloHost.Dispose(); GC.SuppressFinalize(siloHost); siloHost = null; } } } Running the application At this point we should be able to run the Host project. A console should appear with a large amount of logging text, and at the end it should look like this Within the appropriate bin directory (Debug/Release) there will be a number of log files showing this information as well. The amount and method of logging is configurable. Troubleshooting System.SystemException: 'Failed to start Orleans silo 'YOUR-HOST-NAME' as a Secondary node': Problem: The silo is trying to start but does not find a the specified file to get the configuration. Solution: Set the property \"Copy to Output Directory\" to \"Copy if newer\", to set it, right click on the configuration file, then click on properties. ``` Further Reading List of Orleans Packages Orleans Configuration Guide Orleans Best Practices Running in a Stand Alone Silo Azure Web Sample"
  },
  "1.5/Tutorials/Concurrency.html": {
    "href": "1.5/Tutorials/Concurrency.html",
    "title": "Concurrency | Microsoft Orleans 中文文档",
    "keywords": "Concurrency Please read about Grains before following this tutorial. Let's go back to the code that was established in the tutorial on collections of actors and modify it to demonstrate how things can go bad by creating a trivial cycle in the messaging graph: when an employee receives a greeting, he sends another greeting back to the sender and waits for the acknowledgment. This will send a back-and-forth series of messages, until we get to 3. First create a class in the interface project which we'll use to send the greetings around: public class GreetingData { public Guid From { get; set; } public string Message { get; set; } public int Count { get; set; } } From will be the sender of the message (the ID of the grain), Message will be the message text, and Count will be the number of times the message has been sent back and forth. This stops us from getting a stack overflow. We need to modify the arguments of Greeting on the IEmployee interface to : Task Greeting(GreetingData data); We need to update the implementation accordingly: public async Task Greeting(GreetingData data) { Console.WriteLine(\"{0} said: {1}\", data.From, data.Message); // stop this from repeating endlessly if (data.Count >= 3) return; // send a message back to the sender var fromGrain = GrainFactory.GetGrain<IEmployee>(data.From); await fromGrain.Greeting(new GreetingData { From = this.GetPrimaryKey(), Message = \"Thanks!\", Count = data.Count + 1 }); } We'll also update the Manager class, so it send the new message object: public async Task AddDirectReport(IEmployee employee) { _reports.Add(employee); await employee.SetManager(this); await employee.Greeting(new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }); } Now the Employee sends a message back to the manager, saying \"Thanks!\". Let's add some simple client code to add a direct report to a manager: var e0 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var m1 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.NewGuid()); m1.AddDirectReport(e0).Wait(); When we run this code, the first \"Thanks!\" greeting is received. However, when this message is responded to this we get a 30 second pause (or 10 minutes when the debugger is attached), then warnings appear in the log and we're told the grain is about to break it's promise. 7b66f830-8d81-49fc-b8fc-279af6924bd3 said: Welcome to my team! ce14310a-8500-4b2f-a21b-b4b23eb48d0d said: Thanks! [2014-03-12 15:25:37.398 GMT 31 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/906ECA4C/00000001@68e2b3ab->S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #13: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187>. About to break its promise. [2014-03-12 15:25:37.398 GMT 27 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187->S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4 #14: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000001:@afc70cb4>. About to break its promise. [2014-03-12 15:25:37.407 GMT 28 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4->S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #15: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187>. About to break its promise. An exception is then thrown in the client code. We've created a deadlock. Grain 0 sends a message to grain 1. In that call grain 1 sends a message back to grain 0. However, grain 0 can't process it because it's awaiting the first message, so it gets queued. The await can't complete until the second message is returned, so we've entered a state that we can't escape from. Orleans waits for 30 seconds (10 minutes with the debugger), then kills the request. Orleans offers us a way to deal with this, by marking the grain [Reentrant] , which means that additional calls may be made while the grain is waiting for a task to complete, resulting in interleaved execution. [Reentrant] public class Employee : Grain, IEmployee { ... } We see that the sample works, and Orleans is able to interleave the grain calls: aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Welcome to my team! 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks! aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Thanks! 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks! Messages Messages are simply data passed from one actor to another, we just created the GreetingData class to do just this. In .NET, most objects are created from a class of some sort and are passed around by reference, something that doesn't work well with concurrency, and definitely not with distribution. When Orleans sends a message from one grain to another, it creates a deep copy of the object, and provides the copy to the second grain, and not the object stored in the first grain. This prohibits the mutation of state from one grain to another, one of the main tenets in the actor model is that state shouldn't be shared, and message passing is the only mechanism for exchanging data. When the grains are in different silos, the object model is serialized to a binary format, and sent over the wire. However, this deep copy process is expensive, and if you promise not to modify the message, then for communication with grains within a silo, it's unnecessary. If you indicate to Orleans that you are not going to modify the object (i.e. it's immutable) then it can skip the deep copy step, and it will pass the object by reference. There's no way Orleans or C# can stop you from modifying the state, you have to be disciplined. Immutability is indicated with a the [Immutable] attribute on the class: [Immutable] public class GreetingData { public Guid From { get; set; } public string Message { get; set; } public int Count { get; set; } } No other code change is required, this is just a signal to give to Orleans to tell it your not going to modify this object. Next Next, we'll see how we can interact with external services from inside our grain. Interaction with Libraries and Services"
  },
  "1.5/Tutorials/Running-in-a-Stand-alone-Silo.html": {
    "href": "1.5/Tutorials/Running-in-a-Stand-alone-Silo.html",
    "title": "Running in a Stand-Alone Silo | Microsoft Orleans 中文文档",
    "keywords": "Running in a Stand-Alone Silo In the first tutorial , we got a very simple \"Hello World!\" Orleans application running in the simplest possible environment, a dev/test host where everything is running in one process, which makes starting and stopping it really easy. For most of your initial development of grain-based applications and services, that environment will be ideal. However, one thing that is hard to test in such an environment is what happens when the client and server do not get started and stopped at the same time. Often, state is maintained on the server across client sessions, something that is hard to model using the single-process setup. Therefore, what we're going to do now is modify the solution we finished up with in the first tutorial and make it just a bit more like a production environment, running the server and client code in different processes. Getting Started The first thing we need to do is get the grain code running in a silo that is in a separate process and prevent it from being started by the code in Program.cs . To do the latter, remove the code that starts the silo in its own app domain, as well as the code that shuts it down at the end. One consequence of not running the silo from the same process is that the client code has to wait for the silo to be ready to accept incoming requests. Rather than adding some clever backoff-retry code, here we simply expect you to wait for the silo to start, then hit 'Enter' in the client console window when the silo is advertising its readiness. This is the result: static void Main(string[] args) { Console.WriteLine(\"Waiting for Orleans Silo to start. Press Enter to proceed...\"); Console.ReadLine(); // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); } Now you should add reference to Microsoft.Orleans.Server NuGet package to your collection project and then in its project properties in Debug tab set the bin/Debug/OrleansHost.exe or bin/Release/OrleansHost.exe file as startup program for your collections class library. Try to not mix NuGet package versions, make sure all Orlean packages (client, graininterface and grain projects) are aligned in the solution. You also need to add a OrleansConfiguration.xml file, you can create it using the instruction in Minimal Orleans Application tutorial . Then, in this file, make sure that the ProxyingGateway element inside its Defaults section matches this value: <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> Don't forget to set the file's \"Copy to Output Directory\" property to \"Copy if newer\". OrleansHost.exe is a ready-made host executable intended for running Orleans silo code. It is also useful for development purposes. If you set both the grain collection project and the the host project as startup projects, you will see two windows come up: ![](../Images/Standalone 1.PNG) This allows us to debug the grains in their own process, while keeping the client code in its own process. If you let the client make its request, then terminate it using 'Enter' when asked, you should see only the client process windows disappear. The debugging session won't end, because the grains are still being debugged in the OrleansHost.exe process. To start the client again, you will have to use the right-button context menu in the Solution Explorer to get it started. Keeping Things Around To demonstrate keeping state around across client sessions, let's modify the SayHello() method to take a string argument. Then, we will have our grain save each string it is sent and return the last one. Only at the first greeting will we see something we didn't send to the grain from the client. First, change the interface definition of SayHello public interface IGrain1 : IGrainWithIntegerKey { Task<string> SayHello(string greeting); } Then change the Implementation private string text = \"Hello World!\"; public Task<string> SayHello(string greeting) { var oldText = text; text = greeting; return Task.FromResult(oldText); } We also change the client to send a greeting several times in Program.cs: var hello = GrainClient.GrainFactory.GetGrain<IGrain1>(0); Console.WriteLine(hello.SayHello(\"First\").Result); Console.WriteLine(hello.SayHello(\"Second\").Result); Console.WriteLine(hello.SayHello(\"Third\").Result); Console.WriteLine(hello.SayHello(\"Fourth\").Result); What we would expect to see here is four greetings, the first of which is \"Hello World!\". Let's check it out: ![](../Images/Standalone 2.PNG) Terminate the client (make sure it's just the client, we need the grain host to stay up) and restart it using the context menu. There's no reason to wait for the silo now, since it's already running. Here's what we get: ![](../Images/Standalone 3.PNG) Still four greetings, but instead of \"Hello World!\" the first greeting is the last one from our previous client session. In other words, the grain in the silo kept some state around for us. Next So far, we've only seen one single grain type and a single instance of that type. It has served to keep things simple for the purpose of explaining how the environment works, but it is not typical of Orleans code. In the next tutorial, we will see something more realistic. Actor Identity"
  },
  "1.5/Tutorials/Failure-Handling.html": {
    "href": "1.5/Tutorials/Failure-Handling.html",
    "title": "Handling Failures | Microsoft Orleans 中文文档",
    "keywords": "Handling Failures Note: All of the containing guidance in this document is provided to serve as examples and food for thought. You should not think of them as prescriptive solutions to your problems, since failure handling is a rather application specific subject, and these patterns and others are only useful if applied with a good knowledge of the concrete case being worked on. The hardest thing in programming a distributed system is handling failures. The actor model and the way it works makes it much easier to deal with different kinds of failures but still as the developer you are responsible to deal with the failure possibilities and handle them in an appropriate way. Types of failures When you are coding your grains, all calls are asynchronous and potentially can go over the network. Each grain call can possibly fail due to one of the following reasons. The grain was activated on a silo which is unavailable at the moment due to a network partition crash or some other reason. If the silo has not been declared dead yet, your request might time out. The grain method call can throw an exception signaling that it failed and can not continue its job. An activation of the grain doesn't exist and cannot be created because the OnActivateAsync method throws an exception or is dead-locked. Network failures don't let you to communicate with the grain before timeout. And potentially other reasons Detection of failures Getting a reference to a grain always succeeds and is a local operation. However, method calls can fail, and when they do, you get an exception. You can catch the exception at any level you need and they are propagated even across silos. Recovering from failures Part of the recovery job is automatic in Orleans and if a grain is not accessible anymore, Orleans will reactivate it in the next method call. The thing you need to handle and make sure is correct in the context of your application is the state. A grain's state can be partially updated or the operation might be something which should be done across multiple grains and is carried on partially. After you see a grain operation fail you can do one or more of the following. Simply retry your action, especially if it doesn't involve any state changes which might be half done. This is by far the most typical case. Try to fix/reset the partially changed state by calling a method which resets the state to the last known correct state or just reads it from storage by calling ReadStateAsync . Reset the state of all related activations as well to ensure a clean state for all of them. Perform multi-grain state manipulations using a Process Manager or database transaction to make sure it's either done completely or nothing is changed to avoid the state being partially updated. Depending on your application, the retry logic might follow a simple or complex pattern, and you might have to do other stuff like notifying external systems and other things, but generally you either have to retry your action, restart the grain/grains involved or stop responding until something which is not available becomes available. If you have a grain responsible for database saves and the database is not available, you simply have to fail any request until the database comes back online. If your operation can simply be retried at the user's will like failure of saving a comment in a comment grain, you can retry when the user presses the retry button (until a certain number of times in order to not saturate the network). Specific details of how to do it are application specific but the possible strategies are the same. Strategy parameters and choosing a good strategy As described in the section above, choosing a strategy is application and context dependent and strategies usually have parameters which again have to be decided at the application level. For example you might want to retry a request maximum 5 times per minute and can deal with it being done eventually but for some other action you might not be able to continue if something is not working. If your Login grain fails , you cannot process any other requests from the user as an example. There is a guide in the Azure documentation about good patterns and practices for the cloud which applies to Orleans as well in most cases. A fairly complex example Since in Orleans grains are activated and deactivated automatically and you don't handle their life-cycle, you usually only deal with making sure that actor state is correct and actions are being started and finished correctly in relation to each other. Knowing the dependencies between grains and actions they perform is a big step toward understanding how to handle failure in any complex system. If you need to store relations between grains, you can simply do it and it is a widely followed practice too. As an example let's say we have a GameManager grain which starts and stops Game grains and adds Player grains to the games. If my GameManager grain fails to do its action regarding starting a game, the related game belonging to it should fail to do its Start() as well and the manager can do this for the game by doing orchestration. Managing memory in Orleans is automatic and the system deals with it, you only need to make sure that the game starts and only if manager can do its Start() as well. You can achieve this by either calling the related methods in a sequential manner or doing them in parallel and reset the state of all involved grains if any of them fail. If one of the games receives a call, it will be reactivated automatically, so if you need the manager to manage the game grains, then all calls to the game which are related to management should go through the GameManager . If you need orchestration between actors, Orleans doesn't solve it automagically for you and you need to do your orchestration but the fact that you are not dealing with creating/destroying actors means you don't need to worry about resource management. You don't need to answer any of these questions: Where should I create my supervision tree which actors should I register to be addressable by name? Is actor X alive so I can send it a message? ... So the game start example can be summarized like this: GameManager asks the Game grain to start Game grain adds the Player grains to itself Game asks Player grains to add game to themselves Game sets its state to be started. GameManager adds the game to its list of games. Now if, say, a player fails to add the game to itself, you don't need to kill all players and the game and start from scratch. You simply reset the state of other players which added the game to themselves, and reset the state of the Game and GameManager , if required, and redo your work or declare a failure. If you can deal with adding the game to the player later on, you can continue and retry doing that again in a reminder or at some other game call like Finish() method of the game. Next, we'll see how we can call our grains from an MVC web application. Front Ends for Orleans Services"
  },
  "1.5/Tutorials/Custom-Storage-Providers.html": {
    "href": "1.5/Tutorials/Custom-Storage-Providers.html",
    "title": "Custom Storage Providers | Microsoft Orleans 中文文档",
    "keywords": "Custom Storage Providers Writing a Custom Storage Provider In the tutorial on declarative actor storage, we looked at allowing grains to store their state in an Azure table using one of the built-in storage providers. While Azure is a great place to squirrel away your data, there are many alternatives. In fact, there are so many that there was no way to support them all. Instead, Orleans is designed to let you easily add support for your own form of storage by writing a storage provider. In this tutorial, we'll walk through how to write a simple file-based storage provider. A file system is not necessarily the best place to store data for grains, since it's so local, but it's an easy example to help us illustrate the principles. Getting Started An Orleans storage provider is simply a class that implements IStorageProvider . It should be built into an assembly that is placed in the Orleans binaries folder. To move it there on build will require adding a bit of post-build event code. We'll start by creating the project -- it should be a regular .NET class library. Once the project is created, let's also rename the file Class1.cs to FileStorageProvider.cs . That should also prompt VS to rename the class we find inside. Next, we must add references to Microsoft.Orleans.Core NuGet package . Assuming, of course, that your project is called StorageProviders , make your silo host project reference it, so that StorageProviders.dll gets copied to the silo folder. Our storage provider should implement the interface Orleans.Storage.IStorageProvider . With a little bit of massaging of the code, it should look something like this: using System; using System.Threading.Tasks; using System.Collections.Generic; using Orleans; using Orleans.Storage; using Orleans.Runtime; using Newtonsoft.Json; using Orleans.Serialization; namespace StorageProviders { public class FileStorageProvider : IStorageProvider { private JsonSerializerSettings _jsonSettings; public Logger Log { get; set; } public string Name { get; set; } public Task Init(string name, Orleans.Providers.IProviderRuntime providerRuntime, Orleans.Providers.IProviderConfiguration config) { throw new NotImplementedException(); } public Task Close() { throw new NotImplementedException(); } public Task ReadStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } public Task WriteStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } public Task ClearStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } } } The first thing we have to figure out is what data we need to provide through configuration. The name is a required property, but we will also need the path to the root directory for our file store. That is, in fact, the only piece of information we need, so we'll add a RootDirectory string property and edit the configuration file as in the previous section. In doing so, it's critical to pay attention to the namespace and class name of the provider. Add this to the <StorageProviders> element in the OrleansConfiguration.xml configuration file of your silo host project where you will be testing the provider: <Provider Type=\"StorageProviders.FileStorageProvider\" Name=\"FileStore\" RootDirectory=\".\\Storage\"/> Edit the Grain1.cs file to use this storage provider instead of the Azure provider, then set a breakpoint in the Init() method of the storage provider implementation class and start the silo. If you have followed the instructions, you should hit the breakpoint during silo initialization. There's no reason to go on debugging, since you will throw an exception right away. Initializing the Provider There are four major functions to implement in the provider -- Close() is the only one we won't need to do anything with. As you may have guessed, the starting point is the call to Init() , which provides us with the configuration data and a chance to get things set up properly. In our case, we'll want to set the properties and create the root directory if it doesn't already exist: public Task Init(string name, Orleans.Providers.IProviderRuntime providerRuntime, Orleans.Providers.IProviderConfiguration config) { _jsonSettings = SerializationManager.UpdateSerializerSettings(SerializationManager.GetDefaultJsonSerializerSettings(), config); this.Name = name; if (string.IsNullOrWhiteSpace(config.Properties[\"RootDirectory\"])) throw new ArgumentException(\"RootDirectory property not set\"); var directory = new System.IO.DirectoryInfo(config.Properties[\"RootDirectory\"]); if (!directory.Exists) directory.Create(); this.RootDirectory = directory.FullName; return TaskDone.Done; } Run the program again. This time, you will still crash, but in ReadStateAsync() . After running the code, you should find a Storage directory under the bin\\Debug directory of the silo host project. Make sure you have set the project up to build on F5, or you may not see the edits take effect. Reading State To store data in the file system (or anywhere, really), we have to devise a convention that generates a unique name for each grain. This is easiest done by combining the state type name with the grain id, which combines the grain type and GUID creating a globally unique key. Thus, ReadStateAsync() (which, by the way, should be declared as an async method), starts like this: var collectionName = grainState.GetType().Name; var key = grainRef.ToKeyString(); var fName = key + \".\" + collectionName; var path = System.IO.Path.Combine(RootDirectory, fName); var fileInfo = new System.IO.FileInfo(path); if (!fileInfo.Exists) return; We also need to decide how the data will be stored. To make it easy to inspect the data outside of the application, we're going to use JSON. A more space-conscious design may use a binary serialization format, instead, it's entirely a choice of the provider designer's. using (var stream = fileInfo.OpenText()) { var storedData = await stream.ReadToEndAsync(); grainState.State = JsonConvert.DeserializeObject(storedData, grainState.State.GetType(), _jsonSettings); } Writing State The format decisions have already been made, so coding up the WriteStateAsync method should be straight-forward: serialize as JSON, construct the file name, then write to the file: public async Task WriteStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings); var collectionName = grainState.GetType().Name; var key = grainRef.ToKeyString(); var fName = key + \".\" + collectionName; var path = System.IO.Path.Combine(RootDirectory, fName); var fileInfo = new System.IO.FileInfo(path); using (var stream = new System.IO.StreamWriter( fileInfo.Open(System.IO.FileMode.Create, System.IO.FileAccess.Write))) { await stream.WriteAsync(storedData); } } Putting it Together There's really just one thing left to do, and that is to test the thing. Run the application and let it get to the end, where the greetings are shown, and then terminate it. Under the bin\\Debug\\Storage directory of your silo host project, you should find a file called 0.Grain1State , and it should contain something very recognizable: ![](../Images/Storage Provider 1.PNG) Run the application again, and you should see the same behaviour as before, that is, the last greeting of the first session is remembered. Clearing State The easiest method to write is the one that deletes grain state, which we didn't see any use of in the previous tutorial. In fact, we don't need it for our Hello World application, so we'll just leave its implementation as an exercise. It should do the obvious, i.e. delete the file. Next We'll look at how you can unit test grains: Unit Testing Grains"
  },
  "1.5/Tutorials/Front-Ends-for-Orleans-Services.html": {
    "href": "1.5/Tutorials/Front-Ends-for-Orleans-Services.html",
    "title": "Front Ends for Orleans Services | Microsoft Orleans 中文文档",
    "keywords": "Front Ends for Orleans Services Exposing silo gateway ports as public endpoints of an Orleans cluster is not recommended. Instead, Orleans is intended to be fronted by your own API. Creating an HTTP API, or web application is a common scenario. Let's extend the Employee/Manager scenario from the Declarative-Persistence walk-through to see what steps are required to publish grain data over HTTP. Creating the ASP.NET application First, you should add a new ASP.NET Web Application to your solution. Then, select the Web API template, although you could use MVC or Web Forms. Initializing Orleans Next, add a reference to the Orleans.dll file in the project references. As with the Orleans host we created earlier, we need to initialize Orleans. This is best done in the Global.asax.cs file like this: namespace WebApplication1 { public class WebApiApplication : System.Web.HttpApplication { protected void Application_Start() { ... var config = ClientConfiguration.LocalhostSilo(); // Attempt to connect a few times to overcome transient failures and to give the silo enough // time to start up when starting at the same time as the client (useful when deploying or during development). const int initializeAttemptsBeforeFailing = 5; int attempt = 0; while (true) { try { GrainClient.Initialize(config); break; } catch (SiloUnavailableException e) { attempt++; if (attempt >= initializeAttemptsBeforeFailing) { throw; } Thread.Sleep(TimeSpan.FromSeconds(2)); } } ... Now when the ASP.NET application starts, it will initialize the Orleans Client. Creating the Controller Now lets add a controller to the project, to receive HTTP requests, and call the grain code. Right click on the \"Controllers\" folder, and add a new \"Web API 2 Controller - Empty\". Next, call the controller EmployeeController . This will create a new empty controller called EmployeeController . We can add a Get method to the controller, which we'll use to return the level of an Employee. public class EmployeeController : ApiController { public Task<int> Get(Guid id) { var employee = GrainClient.GrainFactory.GetGrain<IEmployee>(id); return employee.GetLevel(); } } Note that the controller is asynchronous, and we can just pass back the Task which the grain returns. Running the Application Now let's test the application. Build the project. Set the ASP.NET application and the silo host project as the startup projects, and run them. If you navigate to the API URL (the number may be different on your project)... http://localhost:6858/api/employee/42783519-d64e-44c9-9c29-399e3afaa625 ...you should see the result returned from the grain: 42 That's the basics in place, the rest of the API can be completed by adding the rest of the HTTP verbs. Next We'll look at how you can deploy Orleans in the Azure Cloud Cloud Deployment"
  },
  "1.5/Tutorials/Declarative-Persistence.html": {
    "href": "1.5/Tutorials/Declarative-Persistence.html",
    "title": "Declarative Persistence | Microsoft Orleans 中文文档",
    "keywords": "Declarative Persistence In the second tutorial, we saw how grain state survived the client being shut down, which opens up for a lot of cache-like scenarios, where Orleans is relied upon as a kind of 'cache with behavior,' an object-oriented cache, if you will. That is already very valuable and goes a long way toward achieving server-side scalability with a simple, familiar, programming model and the built-in single-threaded execution guarantees. However, it is sometimes the case that some of the state you are accumulating belongs in some form of permanent storage, so that it can survive a silo shutdown, or a grain migrating from one silo to another for load-balancing or a complete restart/shutdown of the service. What we have seen so far will not support such situations. Fortunately, Orleans offers a simple declarative model for identifying the state that needs to be stored in a permanent location, while leaving the decision when to save and restore state under programmatic control. You are not required to use the declarative persistence mechanism and can still access storage directly from your grain code, but it’s a nice way to save you some boilerplate code and build applications that are portable across various storage services. Getting Started We'll continue to build on our employee-and-manager sample. The first thing we need to do is make the identities of our workers and managers a little more predictable. In the sample, they were assigned GUIDs using Guid.NewGuid() , which is convenient, but doesn't let us find them in a subsequent run. Therefore, we'll create a set of GUIDs first, then use them as the worker identities. The modified Main program looks like this: static void Main(string[] args) { ... var ids = new string[] { \"42783519-d64e-44c9-9c29-399e3afaa625\", \"d694a4e0-1bc3-4c3f-a1ad-ba95103622bc\", \"9a72b0c6-33df-49db-ac05-14316edd332d\", \"6526a751-b9ac-4881-9bfb-836ecce2ca9f\", \"ae4b106f-3c96-464a-b48d-3583ed584b17\", \"b715c40f-d8d2-424d-9618-76afbc0a2a0a\", \"5ad92744-a0b1-487b-a9e7-e6b91e9a9826\", \"e23a55af-217c-4d76-8221-c2b447bf04c8\", \"2eef0ac5-540f-4421-b9a9-79d89400f7ab\" }; var e0 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[0])); var e1 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[1])); var e2 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[2])); var e3 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[3])); var e4 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[4])); var m0 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.Parse(ids[5])); var m1 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.Parse(ids[6])); ... } Next, we'll do some silo configuration, in order to configure the storage provider that will give us access to persistent storage. The silo host project includes a file OrleansHostWrapper.cs which is where we find the following section: var config = ClusterConfiguration.LocalhostPrimarySilo(); config.AddMemoryStorageProvider(); // Add this line to use the Azure storage emulator // config.AddAzureTableStorageProvider(\"AzureStore\", \"UseDevelopmentStorage=true\"); // Add this line to use an Azure storage account // config.AddAzureBlobStorageProvider(\"AzureStore\", \"[insert data connection string]\"); siloHost = new SiloHost(siloName, config); If this is hosted in Azure Cloud Services, then one can use: config.AddAzureBlobStorageProvider(\"AzureStore\"); and it will pick up the same connection string used in config.Globals.DataConnectionString . The MemoryStorage provider is fairly uninteresting, since it doesn't actually provide any permanent storage; it's intended for debugging persistent grains while having no access to a persistent store. In our case, that makes it hard to demonstrate persistence, so we will rely on a real storage provider. Depending on whether you have already set up (and want to use) an Azure storage account, or would like to rely on the Azure storage emulator, you should add one of the other two lines, but not both. You can use either the AddAzureTableStorageProvider() function or the AddAzureBlobStorageProvider() function depending on how you want to store information. In the case of the former, you have to start the Azure storage emulator after installing the latest version of the Azure SDK. In the case of the latter, you will have to create a Azure storage account and enter the name and keys in the configuration file. With one of those enabled, we're ready to tackle the grain code. Note: The built-in storage provider classes Orleans.Storage.AzureBlobStorage and Orleans.Storage.AzureTableStorage are in the OrleansAzureUtils.dll assembly, make sure this assembly is referenced in your silo worker role project with CopyLocal='True' . Declaring State Identifying that a grain should use persistent state takes three steps: declaring a class for the state, changing the grain base class, and identifying the storage provider. The first step, declaring a state class in the grain implementations project, simply means identifying the information of an actor that should be persisted and creating what looks like a record of the persistent data -- each state component is represented by a property with a getter and a setter. For employees, we want to persist all the state: public class EmployeeState { public int Level { get; set; } public IManager Manager { get; set; } } and for managers, we must store the direct reports, but the _me reference may continue to be created during activation. public class ManagerState { public List<IEmployee> Reports { get; set; } } Then, we change the grain class declaration to identify the state interface (e.g., from Orleans.Grain to Orleans.Grain<EmployeeState> ) and remove the variables that we want persisted. Make sure to remove level , and manager from the Employee class and _reports from the Manager class. In addition, we must update the other functions to reflect these removals. We also add an attribute to identify the storage provider: [StorageProvider(ProviderName = \"AzureStore\")] public class Employee : Orleans.Grain<EmployeeState>, Interfaces.IEmployee and [StorageProvider(ProviderName=\"AzureStore\")] public class Manager : Orleans.Grain<ManagerState>, IManager At risk of stating the obvious, the name of the storage provider attribute should match the name in the configuration file. This indirection is what allows you to delay choices around where to store grain state until deployment. Given these declarative changes, the grain should no longer rely on a private fields to keep compensation level and manager. Instead, the grain base class gives us access to the state via a State property that is available to the grain. For example: public Task SetManager(IManager manager) { State.Manager = manager; return TaskDone.Done; } Controlling Checkpoints The question that remains is when the persistent state gets saved to the storage provider. One choice that the Orleans designers could have made would be to have the runtime save state after every method invocation, but that turns out to be undesirable because it is far too conservative -- not all invocations will actually modify the state on all invocations, and some will never modify it. Rather than employing a complex system to evaluate state differentials after each method, Orleans asks the grain developer to add the necessary logic to determine whether state needs to be saved or not. Saving the state using the storage provider is easily accomplished by calling base.WriteStateAsync() . Thus, the final version of the Promote() and SetManager() methods looks like this: public Task Promote(int newLevel) { State.Level = newLevel; return base.WriteStateAsync(); } public Task SetManager(IManager manager) { State.Manager = manager; return base.WriteStateAsync(); } In the Manager class, there's only one method that need to be modified to write out data, AddDirectReport() . It should look like this: public async Task AddDirectReport(IEmployee employee) { if (State.Reports == null) { State.Reports = new List<IEmployee>(); } State.Reports.Add(employee); await employee.SetManager(this); var data = new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }; await employee.Greeting(data); Console.WriteLine(\"{0} said: {1}\", data.From.ToString(), data.Message); await base.WriteStateAsync(); } Let's try this out! Set a breakpoint in Employee.Promote() . When we run the client code the first time and hit the breakpoint, the level field should be 0 and the newLevel parameter either 10 or 11 : ![](../Images/Persistence 2.PNG) Let the application finish (reach the 'Hit Enter...' prompt) and exit. Run it again, and compare what happens when you look at state this second time around: ![](../Images/Persistence 3.PNG) Just Making Sure... It's worth checking what Azure thinks about the data. Using a storage explorer such as Azure Storage Explorer (ASE) or the one built in to Server Explorer in Visual Studio 2013, open the storage account (or developer storage of the emulator) and find the 'OrleansGrainState' table. It should look something like this (you have to hit 'Query' in ASE): ![](../Images/Persistence 4.PNG) If everything is working correctly, the grain keys should appear in the PartitionKey column, and the qualified class name of the grains should appear in the RowKey column. Mixing Things A grain may contain a combination of persisted and transient state. Any transient state should be represented by private fields in the grain class. A common use for mixing the two is to cache some computed version of the persisted state in private fields while it is present in memory. For example, a stack of elements may be externally represented as a List<T> , but internally, as a Stack<T> . In the case of our Manager class, the _me field is simply a cached value, something we don't even need to keep as a field in the first place, it can be created any time we need it, but since it's going to be a commonly used value, it's worth keeping it around in a transient field. Automatic loading of state If a grain type has state, at activation time the state will be loaded from storage and then OnActivateAsync is called so you can be sure that the state is loaded when initializing your grain. This is the only case that Orleans calls ReadStateAsync automatically. If you want to write the state or read it in some other place, you should do it on your own. Normally you should not need to call ReadStateAsync yourself unless you are doing something specific regarding handling corrupted state or something else. Handling failures using persistence Generally speaking reading and writing a grain's state is a good mechanism to handle failures as well as serving its original intent. There is a possibility that your grain call fails in the middle of a method due to different reasons and you end up with a state which is half changed. In this case reading from storage can return your state to the last correct state. Alternatively, having gotten into such a state, the grain can request to get immediately deactivated by calling DeactivateOnIdle(), so that its a next request to it would trigger reactivation of the grain, which would reread the persistent state and reconstruct its in-memory copy. Deactivation is the cleanest way of resetting a grain to its last know good state, but if you want to avoid the cost of the reactivation process, you can reset its state and rerun any initialization logic (for example, by calling OnActivateAsync ) instead of deactivating the grain. Next Next, we'll see how we can call our grains from an MVC web application. Handling Failure"
  },
  "1.5/Tutorials/index.html": {
    "href": "1.5/Tutorials/index.html",
    "title": "Step by Step Tutorials | Microsoft Orleans 中文文档",
    "keywords": "These tutorials are for the 1.5 release Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Step by Step Tutorials The collection of technology walkthrough tutorials found here is intended to introduce you to the features of this exciting technology, spanning the programming model, its configuration, deployment, and customization. They build on each other, so it is best to go through them in the order outlined below. Each walkthrough is focused narrowly on just a couple of specific concepts in isolation from the scenarios that motivate your using Orleans in the first place, they are intended to teach you the mechanics of Orleans, not to explain when or why you should be using them. My First Orleans Application This walkthrough shows you how to create a \"Hello World\" application using Orleans and run it in the simplest possible single-process environment, one that is convenient for debugging your code. Minimal Orleans Application This walkthrough is an alternative to the My First Orleans Application tutorial. It walks step by step through a basic application, using only the nuget packages. Running in a Stand-Alone Silo In this walkthrough, the simple \"Hello World\" application is modified to use a more typical environment for services: separate processes for the client and service code. It is still a development and debugging environment, simpler than a production configuration, which would involve multiple processes on multiple computers. Actor Identity Actors are a lot like regular objects, but there are a couple of quirks that make them different. One is the notion of actor identity, which surfaces in Orleans in the form of grains' primary keys. A Service is a Collection of Communicating Actors The previous examples used only a single actor type and instance to demonstrate their concepts. In almost all real systems, this is the opposite of what you would want to do; actors are intended to be as light-weight as objects and you would expect hundreds of thousands or millions of them to be active on a single system simultaneously, with as potentially billions waiting inactive in persistent store. This walkthrough explains the actor lifecycle and identity, how actors are activated and deactivated. Concurrency What distinguishes the actor model from most other (distributed) object models is that it enforces a specific set of rules for concurrent access to state, allowing it to be free of data races by exchanging data between actors using message-passing and only allowing a single thread of execution to access each actor's internal state at any given point in time. On the other hand, there are many situations where data races are not a risk, and the single-threaded model is too conservative. Further, single-threaded execution can cause other problems, such as deadlocks. Orleans offers a few tools that allow developers to control this behavior, explained in this walkthrough. Interaction with Libraries and Services Applications using Orleans are regular .NET applications, and can interact freely with other .NET components. In order to not undermine the scalability inherent in the actor model, programmers have to take care to follow a few rules, mostly related to using asynchronous APIs whenever they are available. This walkthrough demonstrates the basic principles. Declarative Persistence Actors are often transient, i.e., their state lives only for a short period of time, or is reconstructible at will from other actors. In many circumstances, however, actor state needs to persist for longer periods of time and be stored in an external database of some sort. Orleans offers the developer flexible options on where to store actor state, and this walkthrough will introduce the simplest way to deal with long-lived actor state: declaratively. Handling Failures Everything is easy and beautiful in a distributed system until something fails and handling failures is one of the hardest things in any computer program. In this section we will learn how we can handle failures. Front Ends for Orleans Services Many Orleans services will be private and available only to front-end services that rely on the Orleans-based code as one of several backend services. In some circumstances, what is needed is to put a thin HTTP layer in front of the backend service, essentially making the Orleans service itself publically available via HTTP. In this walk-through, the steps of producing a thin HTTP layer based on ASP.NET Web API is described. Cloud Deployment The next walkthrough demonstrates how to get your Orleans application deployed in the cloud using Azure. On-Premise Deployment Orleans applications can be deployed both on your server equipment as well as in the cloud. In this walkthrough, you will see how to set up an on premise cluster and deploy your application to it. Custom Storage Providers Defining your own storage provider is the easiest way to extend the persistence choices of your Orleans application. While Orleans comes with a couple of storage providers in the box, they are not intended to be the only choices or constrain you unnecessarily. Therefore, the library offers a way to extend the set of storage providers to include This walkthrough demonstrates how to extend the choices by building a storage provider based on regular files. Unit Testing Grains Writing tests is one of the essential parts of the software development process which allows you to maintain your code easily, refactor with ease and sleep well when a new team member is changing 3 years old code. Orleans makes it very easy to write different kinds of tests for your Orleans application. this tutorial describes how to write simple unit tests to check if each grain method is having the right behavior. More complex scenarios like load testing and object mocking are not described here."
  },
  "1.5/Tutorials/A-Service-is-a-Collection-of-Communicating-Actors.html": {
    "href": "1.5/Tutorials/A-Service-is-a-Collection-of-Communicating-Actors.html",
    "title": "A Service is a Collection of Communicating Actors | Microsoft Orleans 中文文档",
    "keywords": "A Service is a Collection of Communicating Actors The previous tutorials all relied on interacting with a single actor from the client. In most real-world situations this is not what would be expected as actors are intended to be more or less as light-weight as objects and treated as such. Thus, you would no more find an application with just one actor type and one actor instance than you would expect to find a .NET application with one instance of one class. In this tutorial, we're going to construct multiple actors from a couple of classes with different communication interfaces. Not everything will be explained while putting together the application, we will go back and elaborate on a few things after we have it working. Employees and Managers This example will use the relationship of employees and managers to demonstrate the concept of multiple actors - it's one we all understand and relate to. Start by creating a new solution with a silo host, a communications interface project and a grain implementation project as described in previous tutorials. Don't forget to add the necessary project-to-project references and make sure to add a build dependency on the implementation project so that it is built when the host project is built. Change the first interface to IEmployee and add an interface called IManager . Add a couple of methods to describe relationships and employment level: public interface IEmployee : IGrainWithGuidKey { Task<int> GetLevel(); Task Promote(int newLevel); Task<IManager> GetManager(); Task SetManager(IManager manager); } and public interface IManager : IGrainWithGuidKey { Task<IEmployee> AsEmployee(); Task<List<IEmployee>> GetDirectReports(); Task AddDirectReport(IEmployee employee); } Note that this looks a bit different to normal .NET interfaces: usually, you have a property with a setter and a getter, but when defining grain interfaces, you need to avoid using properties altogether, only methods are supported. This is because .NET property setters and getters aren't meant to do I/O. It is often possible to use traditional object-oriented design methodology with Orleans, but sometimes there are reasons for not doing so. In this case, we're choosing to not rely on inheritance when defining the Manager class, even though a Manager is clearly also an Employee . The reason for this will be explained when we discuss Orleans' support for Declarative Persistence . With these two interfaces as our starting point, the implementation classes are straightforward to implement, as the interfaces are simple. Here's what it looks like: public class Employee : Grain, IEmployee { public Task<int> GetLevel() { return Task.FromResult(_level); } public Task Promote(int newLevel) { _level = newLevel; return TaskDone.Done; } public Task<IManager> GetManager() { return Task.FromResult(_manager); } public Task SetManager(IManager manager) { _manager = manager; return TaskDone.Done; } private int _level; private IManager _manager; } and public class Manager : Grain, IManager { public override Task OnActivateAsync() { _me = this.GrainFactory.GetGrain<IEmployee>(this.GetPrimaryKey()); return base.OnActivateAsync(); } public Task<List<IEmployee>> GetDirectReports() { return Task.FromResult(_reports); } public Task AddDirectReport(IEmployee employee) { _reports.Add(employee); employee.SetManager(this); return TaskDone.Done; } public Task<IEmployee> AsEmployee() { return Task.FromResult(_me); } private IEmployee _me; private List<IEmployee> _reports = new List<IEmployee>(); } A manager is expressed as an employee through composition: the manager grain has a reference to a grain representing its \"employeeness.\" The role of OnActivateAsync() will be explained later on; for now, you may consider it to be a constructor. In the client (Program.cs) , we can add a few lines to create a couple of employees and their manager: // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); var grainFactory = GrainClient.GrainFactory; var e0 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e1 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e2 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e3 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e4 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var m0 = grainFactory.GetGrain<IManager>(Guid.NewGuid()); var m1 = grainFactory.GetGrain<IManager>(Guid.NewGuid()); var m0e = m0.AsEmployee().Result; var m1e = m1.AsEmployee().Result; m0e.Promote(10); m1e.Promote(11); m0.AddDirectReport(e0).Wait(); m0.AddDirectReport(e1).Wait(); m0.AddDirectReport(e2).Wait(); m1.AddDirectReport(m0e).Wait(); m1.AddDirectReport(e3).Wait(); m1.AddDirectReport(e4).Wait(); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); In the code we have seen so far, it is noteworthy that you can send grain references (interfaces) in messages. Thus, when a direct report is added to a manager, the manager can communicate directly with the employee without calling GetGrain() . This ability is essential in making the programming model a smooth transition from .NET. Let's add the ability for employees to send messages to each other: public interface IEmployee : IGrainWithGuidKey { ... Task Greeting(IEmployee from, string message); ... } then: public class Employee : Grain, Interfaces.IEmployee { public Task Greeting(IEmployee from, string message) { Console.WriteLine(\"{0} said: {1}\", from.GetPrimaryKey().ToString(), message); return TaskDone.Done; } and public class Manager : Grain, IManager { public Task AddDirectReport(IEmployee employee) { _reports.Add(employee); employee.SetManager(this); employee.Greeting(_me, \"Welcome to my team!\"); return TaskDone.Done; } Executing it, you should see something like this: ![](../Images/Multiple Actors1.PNG) The use of a GUID to represent the name of a person leaves something for you to fix, as an exercise. If you want to do this exercise, please keep the rule for always using asynchronous code inside grains. The Result of a Task will block execution if the task hasn’t completed. This should be avoided in Orleans grains; tasks should always be awaited before Result is read. TaskDone.Done , used in the code above, is a convenience object defined by Orleans to allow code to succinctly return an already completed Task . Asynchrony Bites Us! In the image above, you may notice that the last message comes out after the request to press Enter -- why is that? All the client requests to add a direct report dutifully wait for the addition to finish, i.e. they are fully synchronous. The problem lies elsewhere -- in the implementation of AddDirectReport() , which doesn't wait for the greeting to be acknowledged. Such concurrency is often innocuous and sometimes beneficial, as long as we don't consider the risk of exceptions, which we always must. A correct version of the method would look like this: public async Task AddDirectReport(IEmployee employee) { _reports.Add(employee); await employee.SetManager(this); await employee.Greeting(_me, \"Welcome to my team!\"); } The Life of an Actor Orleans actors are virtual, meaning that even though an actor logically exists, it may not be present in memory at a given point in time. In fact, Orleans takes this concept to an extreme by claiming that all actors exist at all time (past and present) and are never created or destroyed. An actor may be inactive, such as before the first time anyone refers to it or after the last use, but is never not existing. While counter-intuitive and, frankly, strange to most of us with a object-oriented background, this notion actually removes a source of complexity from the system. An actor is either active (present in memory) or inactive, and that status can not be observed by a client. Actor activation is on-demand, just like virtual memory is mapped on demand to physical memory. Thus, the .NET object that holds the actor state is logically just a copy of the actor in memory while it is in the active state. Implementations of Orleans grains should refrain from having constructors, even parameter-less ones, with any logic. That is simply the wrong way of thinking about them: grains are never created or destroyed, just moved from the inactive to the active state or vice versa. Therefore, the implementation should catch the activation event (a call to OnActivateAsync() ) and perform any initialization steps necessary there. It is guaranteed to be called before any method on the grain instance is called. In the Manager grain above, it was used to establish the reference to the Employee grain. There is also an OnDeactivateAsync() method, used more infrequently. Next Next up is a look at Concurrency in Orleans."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Consul-Deployment.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Consul-Deployment.html",
    "title": "Using Consul as a Membership Provider | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Using Consul as a Membership Provider Introduction to Consul Consul is a distributed, highly available and datacenter-aware service discovery platform which includes simple service registration, health checking, failure detection and key/value storage. It is built on the premise that every node in the datacenter is running a Consul agent which is either acting as a server or client which communicate via a scalable gossip protocol. There is a very detailed overview of Consul including comparisons with similar solutions here . Consul is written in GO and is open source ; compiled downloads are available for Mac OS X, FreeBSD, Linux, Solaris and Windows Why Choose Consul? As an Orleans Membership Provider , Consul is a good choice when you need to deliver an on-premise solution which does not require your potential customers to have existing infrastructure and a co-operative IT provider. Consul is a very lightweight single executable, has no dependencies and as such can easily be built into your own middleware solution. And when Consul is already your solution for discovering, checking and maintaining your microservices, it makes sense to fully integrate with Orleans membership for simplicity and ease of operation. We therefore implemented a membership table in Consul (also known as \"Orleans Custom System Store\"), which fully integrates with Orleans's Cluster Management . Setting up Consul There is very extensive documentation available on Consul.io about setting up a stable Consul cluster and it doesn't make sense to repeat that here; however for your convenience we include this guide so you can very quickly get Orleans running with a standalone Consul agent. 1) Create a folder to install Consul into, e.g. C:\\Consul 2) Create a subfolder: C:\\Consul\\Data (Consul will not create this if it doesn't exist) 3) Download and unzip Consul.exe into C:\\Consul\\ 4) Open a command prompt at C:\\Consul\\ 5) Enter Consul.exe agent -server -bootstrap -data-dir \"C:\\Consul\\Data\" -client=0.0.0.0 agent Instructs Consul to run the agent process that hosts the services. Without this the Consul process will attempt to use RPC to configure a running agent. -server Defines the agent as a server and not a client (A Consul client is an agent that hosts all the services and data, but does not have voting rights to decide, and cannot become, the cluster leader -bootstrap The first (and only the first!) node in a cluster must be bootstrapped so that it assumes the cluster leadership. -data-dir [path] Specifies the path where all Consul data is stored, including the cluster membership table -client=0.0.0.0 Informs Consul which IP to open the service on. There are many other parameters, and the option to use a json configuration file. Please consult the Consul documentation for a full listing of the options. 6) Verify that Consul is running and ready to accept membership requests from Orleans by opening the services endpoint in your browser. Configuration of Orleans Server There is currently a known issue with the \"Custom\" membership provider OrleansConfiguration.xml configuration file that will fail to parse correctly. For this reason you have to provide a placeholder SystemStore in the xml and then configure the provider in code before starting the Silo. OrleansConfiguration.xml <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"None\" DataConnectionString=\"http://localhost:8500\" DeploymentId=\"MyOrleansDeployment\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"22222\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Code public void Start(ClusterConfiguration config) { _siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); _siloHost.Config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.Custom; _siloHost.Config.Globals.MembershipTableAssembly = \"OrleansConsulUtils\"; _siloHost.Config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.Disabled; _siloHost.InitializeOrleansSilo(); var startedok = _siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", _siloHost.Name, _siloHost.Type)); Log.Information(\"Orleans Silo is running.\\n\"); } Alternatively you could configure the silo entirely in code. Client The client configuration is much simpler ClientConfiguration.xml <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"Custom\" CustomGatewayProviderAssemblyName=\"OrleansConsulUtils\" DataConnectionString=\"http://192.168.1.26:8500\" DeploymentId=\"MyOrleansDeployment\" /> </ClientConfiguration> Client SDK If you are interested in using Consul for your own service discovery there are Client SDKs for most popular languages. Implementation Detail The Membership Table Provider makes use of Consul's Key/Value store functionality with CAS. When each Silo starts it registers two KV entries, one which contains the Silo details and one which holds the last time the Silo reported it was alive (the latter refers to diagnostics \"I am alive\" entries and not to failure detection hearbeats which are sent directly between the silos and are not written into the table). All writes to the table are performed with CAS to provide concurrency control, as necessitated by Orleans's Cluster Management Protocol . Once the Silo is running you can view these entries in your web browser here , this will display something like: [ \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753\", \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753/iamalive\" ] You will notice that the keys are prefixed with \"orleans/\" this is hard coded in the provider and is intended to avoid key space collision with other users of Consul. Each of these keys can be read by appending their key name (sans quotes of course) to the Consul KV root . Doing so will present you with the following: [ { \"LockIndex\": 0, \"Key\": \"orleans/MyOrleansDeployment/192.168.1.26:22222@191780753\", \"Flags\": 0, \"Value\": \"[BASE64 UTF8 Encoded String]\", \"CreateIndex\": 10, \"ModifyIndex\": 12 } ] Decoding the string will give you the actual Orleans Membership data: http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress] { \"Hostname\": \"[YOUR_MACHINE_NAME]\", \"ProxyPort\": 22222, \"StartTime\": \"2016-01-29T16:25:54.9538838Z\", \"Status\": 3, \"SuspectingSilos\": [] } http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress]/IAmAlive \"2016-01-29T16:35:58.9193803Z\" When the Clients connect, they read the KVs for all silos in the cluster in one HTTP GET by using the uri http://192.168.1.26:8500/v1/KV/orleans/MyOrleansDeployment/?recurse . Limitations Orleans Extended Membership Protocol (Table Version & ETag) Consul KV currrently does not currently support atomic updates. Therefore, the Orleans Consul Membership Provider only implements the the Orleans Basic Membership Protocol, as described here and does not support the Extended Membership Protocol. This Extended protocol was introduced as an additional, but not essential, silo connectivity validation and as a foundation to functionality that has not yet been implemented. Providing your infrastructure is correctly configured you will not experience any detrimental effect of the lack of support. Multiple Datacenters The Key Value Pairs in Consul are not currently replicated between Consul datacenters. There is a separate project to address this but it has not yet been proven to support Orleans. When running on Windows When Consul starts on Windows it logs the following message: ==> WARNING: Windows is not recommended as a Consul server. Do not use in production. This is displayed simply due to lack of focus on testing when running in a Windows environment and not because of any actual known issues. Read the discussion here before deciding if Consul is the right choice for you. Potential Future Enhanecements 1) Prove that the Consul KV replication project is able to support an Orleans cluster in a WAN environment between multiple Consul datacenters. 2) Implement the Reminder Table in Consul. 3) Implement the Extended Membership Protocol. The team behind Consul does plan on implementing atomic operations, once this functionality is available it will be possible to remove the limitations in the provider."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Relational-Storage.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Relational-Storage.html",
    "title": "Relational Storage | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Relational Storage Relational storage backend code in Orleans is built on generic ADO.NET functionality and is consequently database vendor agnostic. The Orleans data storage layout has been explained already in Runtime Tables . Setting up the connection strings are done as explained in Orleans Configuration Guide and SQL Tables . To make Orleans code function with a given relational database backend, the following is required: Appropriate ADO.NET library must be loaded to the process (multiple can exist in GAC or otherwise). This should be defined as usual, e.g. via DbProviderFactories element in application configuration. Configure the ADO.NET invariant via AdoInvariant attribute in the element defining the connection string, by default it is System.Data.SqlClient The database needs to exist and be compatible with the code. This is done by running a vendor specific database creation script. The scripts are found in the OrleansSqlUtils NuGet package and are published with every Orleans release. Currently there are two database scripts: SQL Server - CreateOrleansTables_SqlServer.sql . AdoInvariant is System.Data.SqlClient . MySQL - CreateOrleansTables_MySql.sql . AdoInvariant is MySql.Data.MySqlClient . If you need setup scripts for other ADO.NET supported databases, open an issue or please, stop by at Orleans Gitter . Goals of the design 1. Allow use of any backend that has a ADO.NET provider This should cover the broadest possible set of backends available for .NET, which is a factor in on-premises installations. Some providers are listed at ADO.NET Data Providers MSDN page , but for the sake of a remark, not all are listed, such as Teradata . 2. Maintain the potential to tune queries and database structure as appropriate, even while a deployment is running In many cases, the servers and databases are hosted by a third party in contractual relation with the client. It is not an unusual situation the hosting environment is virtualized and performance fluctuates due to unforeseen factors, such as noisy neighbors or faulty hardware. It may not be possible to alter and re-deploy either Orleans binaries (contractual reasons) or even application binaries, but usually it is possible to tweak the database deployment. Altering standard components , such as Orleans binaries, requires a lenghtier procedure as to what is afforded in a given situation. 3. Allow one to make use of vendor and version specific abilities Vendors have implemented different extensions and features within their products. It is sensible to make use of these features when they are available. These features are such as native UPSERT or PipelineDB in PostgreSQL, PolyBase or natively compiled tables and stored procedures in SQL Server – and myriads of other features. 4. Make it possible to optimize hardware resources When designing an application, it is often possible to anticipate which data needs to be inserted faster than other data and which data could be more likely put into cold storage which is cheaper (e.g. splitting data between SSD and HDD). As for an example, further considerations are that the physical location of some data could be more expensive (e.g. SSD RAID viz HDD RAID), more secured or some other decision attribute used. Related to point 3. Some databases offer special partitioning schemes, such as SQL Server Partitioned Tables and Indexes . This principle applies also throughout the application life-cycle. Considering one of the principles of Orleans itself is a high-availability system, it should be possible to adjust storage system without interruption to Orleans deployment or that it should be possible to adjust the queries according to data and other application parameters. One example of changes is in Brian Harry's blog post When a table is small, it almost doesn’t matter what the query plan is. When it’s medium an OK query plan is fine. When it's huge (millions upon millions or billions of rows) a tiny, slight variation in query plan can kill you. So, we hint our sensitive queries heavily. This is true in general. 5. No assumptions on what tools, libraries or deployment processes are used in organizations Many organizations have familiarity with a certain set of database tools, examples being Dacpac or Red Gate . It may be so that deploying a database requires either a permission or a person, such as someone in a DBA role, to do it. Usually this means also having the target database layout and a rough sketch of the queries the application will produce to the database to be used estimate the load. There might be processes, perhaps influenced by industry standards, which mandate script based deployment. Having the queries and database structures in an external script makes this possible. 6. Use the minimum set needed of interface functionality to load the ADO.NET libraries and functionality This is both fast and has less surface to be exposed to ADO.NET library implementation discrepancies. 7. Make the design shardable When it makes sense, for instance in relational storage provider, make the design readily shardable. This means for instance no database dependent data (e.g. IDENTITY ) and basically it means the information that distinguishes row data should build on only data from the actual parameters. 8. Make the design easy to test Creating a new backend should be ideally as easy as translating one of the deployment scripts and adding a new connection string to tests assuming default parameters, check if a given database is installed and then run the tests against it. 9. Taking into account the previous points, make both porting scripts for new backends and modifying already deployed backend scripts as transparent as possible Realization of the goals Orleans framework does not have knowledge of deployment specific hardware (which may change during active deployment), the change of data during the deployment life-cycle and some vendor specific features are usable in only some situations. For this reason, the interface between relational database and Orleans should adhere a minimum set of abstractions and rules to meet the goals but to make it also robust against misuse and easy to test if needed. Runtime Tables , Cluster Management and the concrete membership protocol implementation . Also, the SQL Server implementation contains SQL Server edition specific tuning. The interface contract between the database and Orleans is defined as follows: The general idea is that data is read and written through Orleans specific queries. Orleans operates on column names and types when reading and on parameter names and types when writing. The implementations must preserve input and output names and types. Orleans uses these parameters to reads query results by name and type. Vendor and deployment specific tuning is allowed and contributions are encouraged as long as the interface contract is maintained. The implementation across vendor specific scripts should preserve the constraint names. This simplifies troubleshooting by virtue of uniform naming across concrete implementations. Version – or ETag in application code – for Orleans represents a unique version. The type of its actual implementation is not important as long as it represents a unique version. In the implementation Orleans code excepts a signed 32-bit integer. For the sake of being explicit and removing ambiguity, Orleans expects some queries to return either TRUE as > 0 value or FALSE as = 0 value. That is, affected rows or such does not matter. If an error is raised or an exception is thrown the query must ensure the entire transaction is rolled back and may either return FALSE or propagate the exception. Currently all but one query are single row inserts or updates (note, one could replace UPDATE queries with INSERT ones provided the associated SELECT queries would provide the last write) except for statistic inserts. Statistic insert, as defined by InsertOrleansStatisticsKey writes the statistics in batches of predefined maximum size using UNION ALL for all databases except for Oracle, for which a UNION ALL FROM DUAL construct is used. InsertOrleansStatisticsKey is the only query that defines a kind of a template parameters of which Orleans multiplies as many times as there are parameters with differing values. Database engines support in-database programming, this is is similar to an idea of loading an executable script and invoke it to execute database operations. In pseudocode it could be depicted as const int Param1 = 1; const DateTime Param2 = DateTime.UtcNow; const string queryFromOrleansQueryTableWithSomeKey = \"SELECT column1, column2 FROM <some Orleans table> where column1 = @param1 AND column2 = @param2;\"; TExpected queryResult = SpecificQuery12InOrleans<TExpected>(query, Param1, Param2); These principles are also included in the database scripts . Some ideas on applying customized scripts Alter scripts in OrleansQuery for grain persistence with IF ELSE so that some state is saved using the default INSERT while some grain state uses, for instance, memory optimized tables . The SELECT queries need to be altered accordingly. The idea in 1. can be used to take advantage of other deployment or vendor specific aspects. Such as splitting data between SSD or HDD , putting some data on encrypted tables, or perhaps inserting statistics data via SQL Server to Hadoop or even linked servers . The altered scripts can be tested running the Orleans test suite or straight in the database using, for instance, SQL Server Unit Test Project . Guidelines for adding new ADO.NET providers Add a new database setup script according to the Realization of the goals section above. Add the vendor ADO invariant name to AdoNetInvariants and ADO.NET provider specific data to DbConstantsStore . These are (potentially) used in some query operations. e.g. to select the correct statistics insert mode (i.e. the UNION ALL with or without FROM DUAL ). Orleans has comprehensive tests for all system stores: membership, reminders and statistics. Adding tests for the new database script is done by copy-pasting existing test classes and changing the ADO invariant name. Also, derive from RelationalStorageForTesting in order to define test functionality for the ADO invariant."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Cluster-Management.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Cluster-Management.html",
    "title": "Cluster Management in Orleans | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Cluster Management in Orleans Orleans provides cluster management via a built-in membership protocol, which we sometimes refer to as Silo Membership . The goal of this protocol is for all silos (Orleans servers) to agree on the set of currently alive silos, detect failed silos, and allow new silos to join the cluster. The protocol relies on an external service to provide an abstraction of MembershipTable . MembershipTable is a flat No-SQL like durable table that we use for 2 purposes. First, it is used as a rendezvous point for silos to find each other and Orleans clients to find silos. Second, it is used to store the current membership view (list of alive silos) and helps coordinate the agreement on the membership view. We currently have 6 implementations of the MembershipTable : based on Azure Table Storage , SQL server, Apache ZooKeeper , Consul IO , AWS DynamoDB , and in-memory emulation for development. In addition to the MembershipTable each silo participates in fully distributed peer-to-peer membership protocol that detects failed silos and reaches agreement on a set alive silos. We start by describing the internal implementation of the Orleans's membership protocol below and later on describe the implementation of the MembershipTable . The Basic Membership Protocol: Upon startup every silo writes itself into a well-known MembershipTable (passed via config). A combination of silo identity ( ip:port:epoch ) and service deployment id are used as unique keys in the table. Epoch is just time in ticks when this silo started, and as such ip:port:epoch is guaranteed to be unique in a given Orleans deployment. Silos monitor each other directly, via application pings (\"are you alive\" heartbeats ). Pings are sent as direct messages from silo to silo, over the same TCP sockets that silos communicate. That way, pings fully correlate with actual networking problems and server health. Every silo pings X other silos. A silo picks whom to ping by calculating consistent hashes on other silos' identity, forming a virtual ring of all identities and picking X successor silos on the ring (this is a well-known distributed technique called consistent hashing and is widely used in many distributed hash tables, like Chord DHT ). If a silo S does not get Y ping replies from a monitored servers P, it suspects it by writing its timestamped suspicion into P’s row in the MembershipTable . If P has more than Z suspicions within K seconds, then S writes that P is dead into P’s row, and broadcasts a request for all silos to re-read the membership table (which they’ll do anyway periodically). In more details: 5.1 Suspicion is written to the MembershipTable , in a special column in the row corresponding to P. When S suspects P it writes: “at time TTT S suspected P”. 5.2 One suspicion is not enough to declare P as dead. You need Z suspicions from different silos in a configurable time window T, typically 3 minutes, to declare P as dead. The suspicion is written using optimistic concurrency control provided by the MembershipTable . 5.3 The suspecting silo S reads P's row. 5.4 If S is the last suspector (there have already been Z-1 suspectors within time period T, as written in the suspicion column), S decides to declare P as Dead. In this case, S adds itself to list of suspectors and also writes in P's Status column that P is Dead. 5.5 Otherwise, if S is not the last suspector, S just adds itself to the suspectors column. 5.6 In either case the write back uses the version number or etag that was read, so the updates to this row are serialized. In case the write has failed due to version/etag mismatch, S retries (read again, and try to write, unless P was already marked dead). 5.7 At a high level this sequence of \"read, local modify, write back\" is a transaction. However, we are not using storage transactions to do that. “Transaction” code executes locally on a server and we use optimistic concurrency provided by the MembershipTable to ensure isolation and atomicity. Every silo periodically reads the entire membership table for its deployment. That way silos learn about new silos joining and about other silos being declared dead. Configuration : we provide a default configuration, which was hand tuned during our production usage in Azure. Currently the default is: every silo is monitored by 3 other silos, 2 suspicions are enough to declare a silo dead, suspicions only from last 3 minutes (otherwise they are outdated). Pings are send every 10 seconds and you needs to miss 3 pings to suspect a silo. Enforcing Perfect Failure detection – it is theoretically possible that a silo will be declared dead if it lost communication with other silos, while the silo process itself is still running. To solve this problem once the silo is declared dead in the table it is considered dead by everyone, even if it is in fact not dead (just partitioned temporarily or heartbeat messages got lost). Everyone stops communicating with it and once it learns that it is dead (by reading its own new status from the table) it commits suicide and shuts down its process. As a result, there must be an infrastructure in place to restart the silo as a new process (a new epoch number is generated upon start). When it's hosted in Azure, that happens automatically. When it isn't, another infrastructure is required. For example, a Windows Service configured to auto restart on failure. Optimization to reduce the frequency of periodical table reads and speed up all silos learning about new joining silos and dead silos . Every time any silo writes anything successfully to the table (suspicion, new join, …) it also broadcasts to all other silos – “go and reread the table now”. The silo does NOT tell others what it wrote in the table (since this information could already be outdated/wrong), it just tells them to re-read the table. That way we learn very quickly about membership changes without the need to wait for the full periodic read cycle. We still need the periodic read, in case the “re-read the table” message gets lost. Properties of the Basic Membership Protocol and FAQ: Can handle any number of failures – our algorithm can handle any number of failures (that is, f<=n), including full cluster restart. This is in contrast with “traditional” Paxos based solutions, which require quorum, which is usually a majority. We have seen in production situations when more than half of the silos were down. Our system stayed functional, while Paxos based membership would not be able to make progress. Traffic to the table is very light - The actual pings go directly between servers and not to the table. This would generate a lot of traffic plus would be less accurate from the failure detection perspective - if a silo could not reach the table, it would miss to write its I am alive heartbeat and others would kill him. Tunable accuracy vs. completeness – both perfect and accurate failure detection is not possible in general . One usually wants an ability to tradeoff accuracy (don’t want to declare a silo that is really alive as dead) with completeness (want to declare dead a silo that is indeed dead as soon as possible). The configurable #votes to declare dead and #missed pings allows to trade those two. Scale - the basic protocol can handle thousands and probably even tens of thousands of servers. This is in contrast with traditional Paxos based solutions, such as group communication protocols, which are known not to scale beyond tens. Diagnostics - the table is also very convenient for diagnostics and troubleshooting. System administrator can instantaneously find in the table the current list of alive silos, as well as see the history of all killed silos and suspicions. This is especially useful when diagnosing problems. Why do we need reliable persistent storage for implementation of the MembershipTable ? - we use persistent storage (Azure table, SQL server, AWS DynamoDB, Apache ZooKeeper or Consul IO KV) for the MembershipTable for 2 purposes. First, it is used as a rendezvous point for silos to find each other and Orleans clients to find silos. Second, we use the reliable storage to help us coordinate the agreement on the membership view. While we perform failure detection directly in a peer to peer fashion between the silos, we store the membership view in a reliable storage and use the concurrency control mechanism provided by this storage to reach agreement of who is alive and who is dead. That way, in a sense, our protocol outsources the hard problem of distributed consensus to the cloud. In that we fully utilize the power of the underlying cloud platform, using it truly as \"Platform as a Service\". What happens if the table is not accessible for some time? (storage service is down, unavailable, or there are communication problems with it) – our protocol will NOT declare silos as dead by mistake in such a case. Currently operational silos will keep working without any problems. However, we won't be able to declare a silo dead (if we detected some silo is dead via missed pings we won’t be able to write this fact to the table) and also won't be able to allow new silos to join. So completeness will suffer, but accuracy will not - partitioning from the table will never cause us to declare silo as dead by mistake. Also, in case of a partial network partition (if some silos can access the table and some not), it could happen that we will declare a dead silo as dead, but it will take some time until all other silos learn about it. So detection could be delayed, but we will never wrongly kill someone due to table un-availability. Direct IAmAlive writes into the table for diagnostics only - in addition to heartbeats that are sent between the silos, each silo also periodically updates an \"I Am Alive\" column in his row in the table. This \"I Am Alive\" column is only used for manual troubleshooting and diagnostics and is not used by the membership protocol itself. It is usually written at much lower frequency (once every 5 minutes) and serves as a very useful tool for system administrators to check the liveness of the cluster or easily find out when the silo was last alive. Extension to totally order membership views: The basic membership protocol described above was later extended to support totally ordered membership views. We will briefly describe the reasons for this extension and how it is implemented. The extension does not change anything in the above design, just adds an additional property that all membership configurations are globally totally ordered. Why it is useful to totally order membership views? This allows serializing the joining of new silos to the cluster. That way, when a new silo joins the cluster it can validate two-way connectivity to every other silo that has already started. If some of the already joined silos do not answer it (potentially indicating a network connectivity problem with the new silo), the new silo is not allowed to join. This ensures that at least when a silo starts, there is a full connectivity between all silos in the cluster (this is implemented). Higher level protocols in the silo, such as distributed grain directory, can utilize the fact that membership views are ordered and use this information to perform smarter duplicate activations resolution. In particular, when directory finds out that 2 activations were created when membership was in flux, it may decide to deactivate the older activation that was created based on the now-outdated membership information (this is currently not implemented). Extended Membership Protocol: For implementation of this feature we utilize the support for transactions over multiple rows that is provided by the MembershipTable .. We add a membership-version row to the table that tracks table changes. When silo S wants to write suspicion or death declaration for silo P: 3.1 S reads the latest table content. If P is already dead, do nothing. Otherwise, 3.2 In the same transaction, write the changes to P's row as well as increment the version number and write it back to the table. 3.3 Both writes are conditioned with eTags. 3.4 If transaction aborts due to eTag mismatch on either P's row or on the version row, attempt again. All writes to the table modify and increment the version row. That way all writes to the table are serialized (via serializing the updates to the version row) and since silos only increment the version number, the writes are also totally ordered in increasing order. Scalability of the Extended Membership Protocol: In the extended version of the protocol all writes are serialized via one row. This can potentially hurt the scalability of the cluster managemenet protocol, since it increases the risk of conflicts between concurrent table writes. To partially mitigate this problem silos retry all their writes to the table by using exponential backoff. We have observed the extended protocols to work smoothly in production environment in Azure with up to 200 silos. However, we do think the protocol might have problems to scale beyond a thousand silos. In such large setups the updates to version row may be easily disabled, essentially maintaining the rest of the cluster managemenet protocol and giving up on the total ordering property. Please also note that we refer here to the scalability of the cluster management protocol, not the rest of Orleans. We believe that other parts of the Orleans runtime (messaging, distributed directory, grain hosting, client to gateway connectivity) are scalable way beyond hundreds of silos. Membership Table: As already mentioned, MembershipTable is used as a rendezvous point for silos to find each other and Orleans clients to find silos and also helps coordinate the agreement on the membership view. We currently have 6 implementation of the MembershipTable : based on Azure Table, SQL server, Apache ZooKeeper, Consul IO, AWS DynamoDB, and in-memory emulation for development. The interface for MembershipTable is defined in IMembershipTable . Azure Table Storage - in this implementation we use Azure deployment ID as partition key and the silo identity ( ip:port:epoch ) as row key. Together they guarantee a unique key per silo. For concurrency control we use optimistic concurrency control based on Azure Table ETags . Every time we read from the table we store the etag for every read row and use that eTag when we try to write back. etags are automatically assigned and checked by Azure Table service on every write. For multi-row transactions we utilize the support for batch transactions provided by Azure table , which guarantees serializale transactions over rows with the same partition key. SQL Server - in this implementation the configured deployment ID is used to distinguish between deployments and which silos belong to which deployments. The silo identity is defined as a combination of deploymentID, ip, port, epoch in appropriate tables and columns. The relational backend uses optimistic concurrency control and transactions, similar to the procedure of using ETags on Azure Table implementation. The relational implementation expects the database engine to generate the ETag used. In case of SQL Server, on SQL Server 2000 the generated ETag is one acquired from a call to NEWID() . On SQL Server 2005 and later ROWVERSION is used. Orleans reads and writes relational ETags as opaque VARBINARY(16) tags and stores them in memory as base64 encoded strings. Orleans supports multi-row inserts using UNION ALL (for Oracle including DUAL), which is currently used to insert statistics data. The exact implementation and rationale for SQL Server can be seen at CreateOrleansTables_SqlServer.sql . Apache ZooKeeper - in this implementation we use the configured deployment ID as a root node and the silo identity ( ip:port@epoch ) as its child node. Together they guarantee a unique path per silo. For concurrency control we use optimistic concurrency control based on the node version . Every time we read from the deployment root node we store the version for every read child silo node and use that version when we try to write back. Each time a node's data changes, the version number increases atomically by the ZooKeeper service. For multi-row transactions we utilize the multi method , which guarantees serializale transactions over silo nodes with the same parent deployment ID node. Consul IO - we used Consul's Key/Value store to impelement the membershop table. Refer to Consul-Deployment for more details. AWS DynamoDB - In this implementation we use the cluster Deployment ID as the Partition Key and Silo Identity ( ip-port-generation ) as the RangeKey making the record unity. The optimistic concurrency is made by the ETag attribute by making conditional writes on DynamoDB. The implementation logic is quite similar to Azure Table Storage. We only implemented the basic membership protocol (and not the extended protocol). In-memory emulation for development setup. We use a special system grain, called MembershipTableGrain , for that implementation. This grain lives on a designated primary silo, which is only used for a development setup . In any real production usage primary silo is not required . Configuration: Membership protocol is configured via the Liveness element in the Globals section in OrleansConfiguration.xml file. The default values were tuned in years of production usage in Azure and we believe they represent good default settings. There is no need in general to change them. Sample config element: <Liveness ProbeTimeout = \"5s\" TableRefreshTimeout =\"10s DeathVoteExpirationTimeout =\"80s\" NumMissedProbesLimit = \"3\" NumProbedSilos=\"3\" NumVotesForDeathDeclaration=\"2\" /> There are 4 types of liveness implemented. The type of the liveness protocol is configured via the SystemStoreType attribute of the SystemStore element in the Globals section in OrleansConfiguration.xml file. MembershipTableGrain - membership table is stored in a grain on primary silo. This is a development setup only . AzureTable - membership table is stored in Azure table. SqlServer - membership table is stored in a relational database. ZooKeeper - membership table is stored in a ZooKeeper ensemble . Consul - configured as Custom system store with MembershipTableAssembly = \"OrleansConsulUtils\" . Refer to Consul-Deployment for more details. DynamoDB - configured as a Custom system store with MembershipTableAssembly = \"OrleansAWSUtils\" . For all liveness types the common configuration variables are defined in Globals.Liveness element: ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send \"I am alive\" heartbeat messages about itself. Default is 10 seconds. TableRefreshTimeout - The number of seconds to fetch updates from the membership table. Default is 60 seconds. DeathVoteExpirationTimeout - Expiration time in seconds for death vote in the membership table. Default is 120 seconds NumMissedProbesLimi t - The number of missed \"I am alive\" heartbeat messages from a silo or number of un-replied probes that lead to suspecting this silo as dead. Default is 3. NumProbedSilos - The number of silos each silo probes for liveness. Default is 3. NumVotesForDeathDeclaration - The number of non-expired votes that are needed to declare some silo as dead (should be at most NumMissedProbesLimit). Default is 2. UseLivenessGossip - Whether to use the gossip optimization to speed up spreading liveness information. Default is true. IAmAliveTablePublishTimeout - The number of seconds to periodically write in the membership table that this silo is alive. Used only for diagnostics. Default is 5 minutes. NumMissedTableIAmAliveLimit - The number of missed \"I am alive\" updates in the table from a silo that causes warning to be logged. Does not impact the liveness protocol. Default is 2. MaxJoinAttemptTime - The number of seconds to attempt to join a cluster of silos before giving up. Default is 5 minutes. ExpectedClusterSize - The expected size of a cluster. Need not be very accurate, can be an overestimate. Used to tune the exponential backoff algorithm of retries to write to Azure table. Default is 20. Design Rationale: A natural question that might be asked is why not to rely completely on Apache ZooKeeper for the cluster membership implementation, potentially by using it's out of the box support for group membership with ephemeral nodes ? Why did we bother implementing our own membership protocol? There were primarily three reasons: 1) Deployment/Hosting in the Cloud - Zookeeper is not a hosted service (at least at the time of this writing July 2015 and definitely when we first implemented this protocol in the summer of 2011 there was no version of Zookeeper running as a hosted service by any major cloud provider). It means that in the Cloud environment Orleans customers would have to deploy/run/manage their own instance of a ZK cluster. This is just yet another unnecessary burden, that we did not want to force on our customers. By using Azure Table we rely on a hosted, managed service which makes our customers lives much simpler. Basically, in the Cloud, use Cloud as a Platform, not as an Infrastructure. On the other hand, when running on premises and managing your own servers, relying on ZK as an implementation of the MembershipTable is a viable option. 2) Direct failure detection - when using ZK's group membership with ephemeral nodes the failure detection is performed between the Orleans servers (ZK clients) and ZK servers. This may not necessarily correlate with the actual network problems between Orleans servers. Our desire was that the failure detection would accurately reflect the intra-cluster state of the communication. Specifically, in our design, if an Orleans silo cannot communicate with the MembershipTable it is not considered dead and can keep working. As opposite to that, have we used ZK group membership with ephemeral nodes a disconnection from a ZK server may cause an Orleans silo (ZK client) to be declared dead, while it may actually be alive and fully functional. 3) Portability and flexibility - as part of Orleans's philosophy, we do not want to force a strong dependence on any particular technology, but rather have a flexible design where different components can be easily switched with different implementations. This is exactly the purpuse that MembershipTable abstraction serves. Acknowledgements: We would to acknowledge the contribution of Alex Kogan to the design and implementation of the first version of this protocol. This work was done as part of summer internship in Microsoft Research in the Summer of 2011. The implementation of ZooKeeper based MembershipTable was done by Shay Hazor , the implementation of SQL MembershipTable was done by Veikko Eeva , the implementation of AWS DynamoDB MembershipTable was done by Gutemberg Ribeiro and the implementation of Consul based MembershipTable was done by Paul North ."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Load-Balancing.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Load-Balancing.html",
    "title": "Load Balancing | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Load Balancing Load balancing, in a broad sense, is one of the pillars of the Orleans runtime . Orleans runtime tries to make everything balanced, since balancing allows to maximize resource usage and avoid hotspots, which leads to better performance, as well as helps with elasticity. Load balancing in Orleans applies in multiple places. Below is a non-exhaustive list of places where the runtime performs balancing: Default actor placement strategy is random - new activations are placed randomly across silos. That results in a balanced placement and prevents hotspots for most scenarios. A more advanced ActivationCountPlacement tries to equalize the number of activations on all silos, which results in a more even distribution of activations across silos. This is especially important for elasticity. Grain Directory service is built on top of a Distributed Hash Table, which inherently is balanced. The directory service maps grains to activations, each silo owns part of the global mapping table, and this table is globally partitioned in a balanced way across all silos. We use consistent hashing with virtual buckets for that. Clients connect to all gateways and spread their requests across them, in a balanced way. Reminder service is a distributed partitioned runtime service. The assignment of which silo is responsible to serve which reminder is balanced across all silos via consistent hashing, just like in grain directory. Performance critical components within a silo are partitioned, and the work across them is locally balanced . That way the silo runtime can fully utilize all available CPU cores and not create in-silo bottlenecks. This applies to all local resources: allocation of work to threads, sockets, dispatch responsibilities, queues, etc. StreamQueueBalance balances the responsibility of pulling events from persistence queues across silos in the cluster. Also notice that balancing, in a broad sense, does not necessarily mean loss of locality . One can be balanced and still maintain a good locality. For example, when balancing means sharding/partitioning, you can partition responsibility for a certain logical task, while still maintaining locality within each partition. That applies both for local and distributed balancing. Refer to this presentation on [Balancing Techniques in Orleans]( http://dotnet.github.io/orleans/Presentations/Balancing Techniques in Orleans.pptx) for more details."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Scheduler.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Scheduler.html",
    "title": "Scheduler | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Scheduler Orleans Scheduler is a component within the Orleans runtime responsible for executing application code and parts of the runtime code to ensure the single threaded execution semantics . It implements a custom TPL Task scheduler. Orleans Task scheduler is a hierarchical 2 level scheduler. At the first level there is the global OrleansTaskScheduler that is responsible for execution of system activities. At the second level every grain activation has its own ActivationTaskScheduler , which provides the single threaded execution semantics. At a high level, the execution path is the following: A request arrives to the correct silo and the destination activation is found. A request is translated into a Task that is queued for execution by that activation, on its ActivationTaskScheduler. Any subsequent Task created as part of the grain method execution is natively enqueued to the same ActivationTaskScheduler, via the standard TaskScheduler mechanism. Every ActivationTaskScheduler has a queue of tasks queued for execution. Orleans Scheduler has a set of worker threads that are collectively used by all the activation schedulers. Those threads periodically scan all the scheduler queues for work to execute. A thread takes a queue (each queue is taken by one thread at a time) and starts executing Tasks in that queue in FIFO order. The combination of one thread at a time taking a queue and the thread executing Tasks sequentially is what provides the single threaded execution semantics. Work Items: Orleans uses a notion of Work Items to designate the entry point into the scheduler. Every new request is enqueued initially as a work item which simply wraps the execution of the first Task for that request. Work items simply provide more contextual information about the scheduling activity (the caller, the name of the activity, logging) and sometimes some extra work that has to be done on behalf of that scheduling activity (post invocation activity in Invoke work item). There are currently the following work item types: Invoke work item – this is the mostly frequently used work item type. It represents execution of an application request. Request/Response work items – executes a system request (request to a SystemTarget) TaskWorkItem – represent a Task queued to the top level OrleansTaskScheduler. Used instead of a direct Task just for convenience of data structures (more details below). WorkItemGroup – group of work items that share the same scheduler. Used to wrap a queue of Tasks for each ActivationTaskScheduler. ClosureWorkItem – a wrapper around a closure (arbitrary lambda) that is queued to the system context. Scheduling Context: Scheduling Context is a tag, just an opaque object that represents scheduling target – activation data, system target or system null context. High level Principles: Tasks are always queued to the correct scheduler 1.1 Tasks are never moved around from one scheduler to another. 1.2 We never create tasks on behalf of other tasks to execute them. 1.3 WorkItems are wrapped within Task (that is, in order to execute a work item, we create a Task whose lambda function will just run the work item lambda). By always going via tasks we ensure that any activity is executed via an appropriate Task scheduler. Tasks are executed on the scheduler where they were queued by using base.TryExecute (and not by RunSynchronously) There is a one to one mapping between ATS, WorkItem Group and Scheduling Context: 3.1 Activation Task Scheduler (ATS) is a custom TPL scheduler. We keep ATS thin and store all the data in WorkItemGroup. ATS points to its WorkItemGroup. 3.2 WorkItem Group is the actual holder (data object) of the activation Tasks. The Tasks are stored in a List - the queue of all tasks for its ATS. WorkItemGroup points back to its ATS. Data Flow and Execution of Tasks and Work items: The entry point is always a work item enqueued into OrleansTaskScheduler. It can be one of the Invoke/Request/Response/Closure WorkItem. Wrapped into a Task and enqueued into the correct ActivationTaskScheduler based on the context via Task.Start. A Task that is queued to its ActivationTaskScheduler is put into the WorkItemGroup queue. When a Task is put into a WorkItemGroup queue, WorkItemGroup makes sure it appears in OrleansTaskScheduler global RunQueue. RunQueue is the global queue of runnable WorkItemGroups, those that have at least one Task queued, and thus ready to be executed. Worker threads scan the RunQueue of OrleansTaskScheduler which hold WorkItemGroups and call WorkItemGroups.Execute WorkItemGroups.Execute scans the queue of its tasks and executes them via ActivationTaskScheduler.RunTask(Task) 6.1 ActivationTaskScheduler.RunTask(Task) calls base.TryExecute. 6.2 Task that were enqueued directly to the scheduler via TPL will just execute 6.3 Tasks that wrap work items will call workItem.Execute which will execute the Closure work item delegate. Low level design – Work Items: Queueing work items to OrleansTaskScheduler is how the whole chain of execution for every request starts in the Orleans runtime. This is our entry point into the Scheduler. Work items are first submitted to OrleansTaskScheduler (since this is the interface presented to the rest of the system). 2.1 Only closure/invoke/resume work items can be submitted this way. 2.2 TaskWorkItem cannot be submitted to OrleansTaskScheduler directly (read more below on handling of TaskWorkItem). Every work item must be wrapped into Task and enqueued to the right scheduler via Task.Start. 3.1 This will make sure the TaskScheduler.Current is set correctly on any Task that is created implicitly during execution of this workItem. 3.2 Wrapping is done by creating a Task via WrapWorkItemAsTask that will execute the work item and enqueuing it to the right scheduler via Task.Start(scheduler). 3.3 Work items for the null context are queued to OrleansTaskScheduler. 3.4 Work items for non-null contexts are queued to ActivationTaskScheduler Low level design – Queueing Tasks: Tasks are queued directly to the right scheduler 1.1 Tasks are queued implicitly by TPL via protected override void QueueTask(Task task) 1.2 A Task that has a non-null context is always enqueued to ActivationTaskScheduler 1.3 A Task that has the null context is always enqueued to OrleansTaskScheduler Queueing Tasks to ActivationTaskScheduler: 2.1 We never wrap a Task in another Task. A Task gets added directly to the WorkItem Group queue Queueing Tasks to OrleansTaskScheduler: 3.1 When a Task is enqueued to the OrleansTaskScheduler, we wrap it into a TaskWorkItem and put it into this scheduler’s queue of work items. 3.2 This is just a matter of data structures, nothing inherent about it: 3.3 OrleansTaskScheduler usually holds work item groups to schedule them, so its RunQueue has a BlockingCollection . 3.4 Since tasks to the null context are also queued to OrleansTaskScheduler, we reuse the same data structure, thus we have to wrap each Task in a TaskWorkItem. 3.5 We should be able to get rid of this wrapping completely by adjusting the RunQueue data structure. This may simplify the code a bit, but in general should not matter. Also, in the future we should move away from the null context anyway, so this issue will be gone anyway Inlining tasks: Since Tasks are always queued to the right scheduler, in theory it should always be safe to inline any Task."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Runtime-Tables.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Runtime-Tables.html",
    "title": "Azure Runtime Tables | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Azure Runtime Tables Orleans maintains a number of internal tables for different runtime mechanisms. Here we list all the tables as they are organized if Azure is used as the system store, and provide more details on their internal structure. When SQL, ZooKeeper, Consul and other technologies are used for system store, organization and exact structure of the data may vary, but the general idea stays the same. Runtime tables: Orleans Silo Instances table Reminders table Silo Metrics table Clients Metrics table Silo Statistics table Clients Statistics table Orleans Silo Instances table Orleans Silo Instances table, also commonly referred to as Membership table, lists the set of silos that make an Orleans deployment. More details can be found in the description of the Cluster Management Protocol that maintains this table. All rows in this table consist of the following columns ( SiloInstanceTableEntry ): PartitionKey - deployment id. RowKey - Silo IP Address + \"-\" + Silo Port + \"-\" + Silo Generation number (epoch) DeploymentId - the deployment id of this Orleans service Address - IP address Port - silo to silo TCP port Generation - Generation number (epoch number) HostName - silo Hostname Status - status of this silo, as set by cluster management protocol. Any of the type Orleans.Runtime.SiloStatus ProxyPort - silo to clients TCP port Primary - whether this silo is primary or not. Deprecated. RoleName - If running in Azure - the name of this role. If running on premises, the name of the executing assembly. InstanceName - If running in Azure - the name of this role instance. If running on premises, the silo name that the silo host gave it. UpdateZone - Azure update zone, if running in Azure. FaultZone - Azure fault zone, if running in Azure. SuspectingSilos - the list of silos that suspect this silo. Managed by cluster management protocol. SuspectingTimes - the list of times when this silo was suspected. Managed by cluster management protocol. StartTime - the time when this silo was started. IAmAliveTime - the last time this silo reported that it is alive. Used for diagnostics and troubleshooting only. There is also a special row in this table, called membership version row, with the following columns: PartitionKey - deployment id. RowKey - \"VersionRow\" constant string DeploymentId MembershipVersion - the latest version of the current membership configuration. Naming: The silo instance row has 3 names: hostname, rolename and instance name. What is the difference? First, it is important to note that Orleans cluster protocol does not use any of these names for distinguishing between silos. Instead it uses IP:port:epoch as a unique identity of a silo instance. Therefore, setting of those 3 names has no impact on runtime correctness. It is in the table merely to help diagnostics and operational troubleshooting. Hostname is always set to the name of this host, as returned by Dns.GetHostName() . Role name is a logical name of the whole service and instance name is the name of this specific silo instance within this service. Role name and Instance name depend on the hosting - where the silo runs. Each silo host can set those differently. Azure host ( AzureSiloHost ) sets the role name to Azure role name ( myRoleInstance.Role.Name ) and instance name to Azure role Instance name ( myRoleInstance.Id ). On premises ( SiloHost ) the role name is the executing assembly name ( Assembly.GetExecutingAssembly().GetName().Name ) and the instance name is the name the host gave to that silo when it was started. Orleans Reminders table Orleans Reminders table durably stores all the reminders registered in the system. Each reminder has a separate row. All rows in this table consist of the following columns ( ReminderTableEntry ): PartitionKey - ServiceId + \"_\" + GrainRefConsistentHash RowKey - GrainReference + \"-\" ReminderName GrainReference - the grain reference of the grain that created this reminder. ReminderName - the name of this reminder ServiceId - the service id of the currently running Orleans service DeploymentId - the deployment id of the currently running Orleans service StartAt - the time when this reminder was supposed to tick in the first time Period - the time period for this reminder GrainRefConsistentHash - the consistent hash of the GrainReference Silo Metrics table Silo metrics table contains a small set of per-silo important key performance metrics (usually known as KPI - Key Performance Indicators ). Each silo has one row, periodically updated in-place by its silo ( SiloMetricsData ). PartitionKey - DeploymentId RowKey - silo name DeploymentId - the deployment id of this Orleans service Address - the silo address (ip:port:epoch) of this silo SiloName - the name of this silo (in Azure it is its Instance name) GatewayAddress - the gateway ip:port of tis silo HostName - the hostname of this silo CPU - current CPU utilization MemoryUsage - current memory usage ( GC.GetTotalMemory(false) ) Activations - number of activations on this silo RecentlyUsedActivations - number of activations on this silo that were used in the last 10 minutes (Note: this number may currently not be accurate if different age limits are used for different grain types). SendQueue - the current size of the send queue (number of messages waiting to be send). Only captures remote messages to other silos (not including messages to the clients). ReceiveQueue - the current size of the receive queue (number of messages that arrived to this silo and are waiting to be dispatched). Captures both remote and local messages from other silos as well as from the clients. RequestQueue SentMessages - total number of remote messages sent to other silos as well as to the clients. ReceivedMessages - total number of remote received messages, from other silos as well as from the clients. LoadShedding - whether this silo is currently overloaded and is in the load shedding mode. Clients - number of currently connected clients Clients Metrics table Silo metrics table containes a small set of per-Orleans-client important key performance metrics. Each client has one row, periodically updated in-place by its client. Client metrics are essentilay a subset of silo metrics ( ClientMetricsData ). PartitionKey - DeploymentId RowKey - Address DeploymentId - the deployment id of this Orleans service Address - the address (ip:port) of this client ClientId - the unique name of this client (pseudo client grain id) HostName - the hostname of this client CPU - current CPU utilization MemoryUsage - current memory usage ( GC.GetTotalMemory(false) ) SendQueue - the current size of the send queue (number of messages waiting to be send). Captures remote messages to other silos. ReceiveQueue - the current size of the receive queue (number of messages that arrived to this client and are waiting to be dispatched, including responses). SentMessages - total number of remote messages sent to silos. ReceivedMessages - total number of remote received messages from silos. ConnectedGatewayCount - number of gateways that this client is currently connected to. Silo Statistics table Silo Statistics table containes a large set of per-silo detailed statistic counters. Most of them are low level performance statistics, which are usualy used in troubleshooting scenarios. A set of examples and methodology of how those statistics can be used are described in our paper PAD: Performance Anomaly Detection in Multi-Server Distributed Systems and a proof of concept . Each statistic value is one row. This table is append only. Every silo periodicaly (usually every 5 minutes, configurable) appends all its latest statistic counter values. The number of counters per silo is currently about 200. So every 5 minutes every silo appends around 200 rows to this table. Each row is in the format ( StatsTableData ): PartitionKey - DeploymentId$ReverseTimestampToTheNearestHour - deploymentId and last hour RowKey - ReverseTimestampToTheNearestSecond$Name$counter - current second, silo name, monotonically growing sequence number DeploymentId - the deployment id of this Orleans service Time - the current time of the reporting on the reporting silo Address - the silo address (ip:port:epoch) of this silo Name - the name of this silo (in Azure it is its Instance name) HostName - the host name of this silo Statistic - the name of the statistic counter StatValue - the value of the statistic counter IsDelta - if this the statistic counter value is delta since last value reported or an absolute value The rationale behind the choice of partition key and row key is described here and here . Clients Statistics table Same as Silo Statistics table but for client."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Messaging-Delivery-Guarantees.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Messaging-Delivery-Guarantees.html",
    "title": "Messaging Delivery Guarantees | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Messaging Delivery Guarantees Orleans messaging delivery guarantees are at-most-once , by default. Optionally, if configured to do retries upon timeout, Orleans provides at-least-once deliv­ery instead. In more details: Every message in Orleans has automatic timeout (the exact timeout can be configured). If the reply does not arrive on time the return Task is broken with timeout exception. Orleans can be configured to do automatic retries upon timeout. By default we do NOT do automatic retries. Application code of course can also pick to do retries upon timeout. If the Orleans system is configured not to do automatic retries (default setting) and application is not resending – Orleans provides at most once message delivery . A message will either be delivered once or not at all. It will never be delivered twice. In the system with retries (either by the runtime or by the application) the message may arrive multiple times. Orleans currently does nothing to durably store which messages already arrived and suppress the second delivery (we believe this would be pretty costly). So in the system with retries Orleans does NOT guarantee at most once delivery. If you keep retrying potentially indefinitely , the message will eventually arrive , thus providing at least once delivery guarantee. Notice that “will eventually arrive” is something that the runtime needs to guarantee. It does not come for free just by itself even if you keep retrying. Orleans provides eventually delivery since grains never go into any permanent failure state and a failed grain will for sure eventually be re-activated on another silo. So to summarize : in the system without retries Orleans guarantees at most once message delivery. In the system with infinite retries Orleans guarantee at least once (and does NOT guarantee at most once). Note : In the Orleans technical report we accidentally only mentioned the 2nd option with automatic retries and forgot to mention that by default with no retries, Orleans provides at most once delivery."
  },
  "1.5/Documentation/Advanced-Concepts/Serialization.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Serialization.html",
    "title": "Serialization and Writing Custom Serializers | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Serialization and Writing Custom Serializers Orleans has an advanced and extensible serialization framework. Orleans serializes data types passed in grain request and response messages as well as grain persistent state objects. As part of this framework, Orleans automatically generates serialization code for those data types. In addition to generating a more efficient serialization/deserialization for types that are already .NET-serializable, Orleans also tries to generate serializers for types used in grain interfaces that are not .NET-serializable. The framework also includes a set of efficient built-in serializers for frequently used types: lists, dictionaries, strings, primitives, arrays, etc. There are 2 important features of Orleans's serializer that set it apart from a lot of other third party serialization frameworks: dynamic types/arbitrary polymorphism and object identity. Dynamic types and arbitrary polymorphism - Orleans does not put any restrictions on the types that can be passed in grain calls and maintains the dynamic nature of the actual data type. That means, for example, that if the method in the grain interfaces is declared to accept IDictionary but at runtime the sender passes SortedDictionary , the receiver will indeed get SortedDictionary (although the \"static contract\"/grain interface did not specify this behaviour). Maintaining Object identity - if the same object is passed multiple types in the arguments of a grain call or is indirectly pointed more than once from the arguments, Orleans will serialize it only once. At the receiver side Orleans will restore all references correctly, so that two pointers to the same object still point to the same object after deserialization as well. Object identity is important to preserve in scenarios like the following. Imagine actor A is sending a dictionary with 100 entries to actor B, and 10 of the keys in the dictionary point to the same object, obj, on A's side. Without preserving object identity, B would receive a dictionary of 100 entries with those 10 keys pointing to 10 different clones of obj. With object identity preserved, the dictionary on B's side looks exactly like on A's side with those 10 keys pointing to a single object obj. The above two behaviours are provided by the standard .NET binary serializer and it was therefore important for us to support this standard and familiar behaviour in Orleans as well. Generated Serializers Orleans uses the following rules to decide which serializers to generate. The rules are: 1) Scan all types in all assemblies which reference the core Orleans library. 2) Out of those assemblies: generate serializers for types that are directly referenced in grain interfaces method signatures or state class signature or for any type that is marked with [Serializable] attribute. 3) In addition, a grain interface or implementation project can point to arbitrary types for serialization generation by adding a [KnownType] or [KnownAssembly] assembly level attributes to tell code generator to generate serializers for a specific types or all eligible types within an assembly. Serialization Providers Orleans supports integration with third-party serializers using a provider model. This requires an implementation of the IExternalSerializer type described in the custom serialization section of this document. Integrations for some common serializers are maintained alongside Orleans, for example: Protocol Buffers : Orleans.Serialization.ProtobufSerializer from the Microsoft.Orleans.OrleansGoogleUtils NuGet package. Bond : Orleans.Serialization.BondSerializer from the Microsoft.Orleans.Serialization.Bond NuGet package. Newtonsoft.Json AKA Json.NET : Orleans.Serialization.OrleansJsonSerializer from the core Orleans library. Custom implementation of IExternalSerializer is described in the Writing Custom Serializers section below. Configuration It is important to ensure that serialization configuration is identical on all clients and silos. If configurations are not consistent, serialization errors may occur. Serialization providers, which implement IExternalSerializer , can be specified using the SerializationProviders property of ClientConfiguration and GlobalConfiguration in code: var cfg = new ClientConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); var cfg = new GlobalConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); Alternatively, they can be specified in XML configuration under the <SerializationProviders /> property of <Messaging> : <Messaging> <SerializationProviders> <Provider type=\"GreatCompany.FantasticSerializer, GreatCompany.SerializerAssembly\"/> </SerializationProviders> </Messaging> In both cases, multiple providers can be configured. The collection is ordered, meaning that if a provider which can serialize types A and B is specified before a provider which can only serialize type B , then the latter provider will not be used. Writing Custom Serializers In addition to automatic serialization generation, application code can provide custom serialization for types it chooses. Orleans recommends using the automatic serialization generation for the majority of your application types and only write custom serializers in rare cases when you believe it is possible to get improved performance by hand-coding serializers. This note describes how to do so, and identifies some specific cases when it might be helpful. There are 3 ways in which applications can customize serialization: Add serialization methods to your type and mark them with appropriate attributes ( CopierMethod , SerializerMethod , DeserializerMethod ). This method is preferable for types that your application owns, that is, the types that you can add new methods to. Implement IExternalSerializer and register it during configuration time. This method is useful for integrating an external serialization library. Write a separate static class annotated with an [Serializer(typeof(YourType))] with the 3 serialization methods in it and the same attributes as above. This method is useful for types that the application does not own, for example, types defined in other libraries your application has no control over. Each of these methods are detailed in the sections below. Introduction Orleans serialization happens in three stages: objects are immediately deep copied to ensure isolation; before being put on the wire; objects are serialized to a message byte stream; and when delivered to the target activation, objects are recreated (deserialized) from the received byte stream. Data types that may be sent in messages -- that is, types that may be passed as method arguments or return values -- must have associated routines that perform these three steps. We refer to these routines collectively as the serializers for a data type. The copier for a type stands alone, while the serializer and deserializer are a pair that work together. You can provide just a custom copier, or just a custom serializer and a custom deserializer, or you can provide custom implementations of all three. Serializers are registered for each supported data type at silo start-up and whenever an assembly is loaded. Registration is necessary for custom serializer routines for a type to be used. Serializer selection is based on the dynamic type of the object to be copied or serialized. For this reason, there is no need to create serializers for abstract classes or interfaces, because they will never be used. When to Consider Writing a Custom Serializer It is rare that a hand-crafted serializer routine will perform meaningfully better than the generated versions. If you are tempted to do so, you should first consider the following options: If there are fields or properties within your data types that don't have to be serialized or copied, you can mark them with the NonSerialized attribute. This will cause the generated code to skip these fields when copying and serializing. Use Immutable<T> & [Immutable] where possible to avoid copying immutable data. The section on Optimizing Copying below for details. If you're avoiding using the standard generic collection types, don't. The Orleans runtime contains custom serializers for the generic collections that use the semantics of the collections to optimize copying, serializing, and deserializing. These collections also have special \"abbreviated\" representations in the serialized byte stream, resulting in even more performance advantages. For instance, a Dictionary<string, string> will be faster than a List<Tuple<string, string>> . The most common case where a custom serializer can provide a noticeable performance gain is when there is significant semantic information encoded in the data type that is not available by simply copying field values. For instance, arrays that are sparsely populated may often be more efficiently serialized by treating the array as a collection of index/value pairs, even if the application keeps the data as a fully realized array for speed of operation. A key thing to do before writing a custom serializer is to make sure that the generated serializer is really hurting your performance. Profiling will help a bit here, but even more valuable is running end-to-end stress tests of your application with varying serialization loads to gauge the system-level impact, rather than the micro-impact of serialization. For instance, building a test version that passes no parameters to or results from grain methods, simply using canned values at either end, will zoom in on the impact of serialization and copying on system performance. Method 1: Adding Serialization Methods to the Type All serializer routines should be implemented as static members of the class or struct they operate on. The names shown here are not required; registration is based on the presence of the respective attributes, not on method names. Note that serializer methods need not be public. Unless you implement all three serialization routines, you should mark your type with the Serializable attribute so that the missing methods will be generated for you. Copier Copier methods are flagged with the Orleans.CopierMethod attribute: [CopierMethod] static private object Copy(object input, ICopyContext context) { ... } Copiers are usually the simplest serializer routines to write. They take an object, guaranteed to be of the same type as the type the copier is defined in, and must return a semantically-equivalent copy of the object. If, as part of copying the object, a sub-object needs to be copied, the best way to do so is to use the SerializationManager's DeepCopyInner routine: var fooCopy = SerializationManager.DeepCopyInner(foo, context); It is important to use DeepCopyInner, instead of DeepCopy, in order to maintain the object identity context for the full copy operation. Maintaining Object Identity An important responsibility of a copy routine is to maintain object identity. The Orleans runtime provides a helper class for this. Before copying a sub-object \"by hand\" (i.e., not by calling DeepCopyInner), check to see if it has already been referenced as follows: var fooCopy = context.CheckObjectWhileCopying(foo); if (fooCopy == null) { // Actually make a copy of foo context.RecordObject(foo, fooCopy); } The last line, the call to RecordObject , is required so that possible future references to the same object as foo references will get found properly by CheckObjectWhileCopying . Note that this should only be done for class instances, not struct instances or .NET primitives (strings, Uris, enums). If you use DeepCopyInner to copy sub-objects, then object identity is handled for you. Serializer Serialization methods are flagged with the SerializerMethod attribute: [SerializerMethod] static private void Serialize(object input, ISerializationContext context, Type expected) { ... } As with copiers, the \"input\" object passed to a serializer is guaranteed to be an instance of the defining type. The \"expected\" type may be ignored; it is based on compile-time type information about the data item, and is used at a higher level to form the type prefix in the byte stream. To serialize sub-objects, use the SerializationManager 's SerializeInner routine: SerializationManager.SerializeInner(foo, context, typeof(FooType)); If there is no particular expected type for foo, then you can pass null for the expected type. The BinaryTokenStreamWriter class provides a wide variety of methods for writing data to the byte stream. An instance of the class can be obtained via the context.StreamWriter property. See the class for documentation. Deserializer Deserialization methods are flagged with the DeserializerMethod attribute: [DeserializerMethod] static private object Deserialize(Type expected, IDeserializationContext context) { ... } The \"expected\" type may be ignored; it is based on compile-time type information about the data item, and is used at a higher level to form the type prefix in the byte stream. The actual type of the object to be created will always be the type of the class in which the deserializer is defined. To deserialize sub-objects, use the SerializationManager 's DeserializeInner routine: var foo = SerializationManager.DeserializeInner(typeof(FooType), context); Or, alternatively, var foo = SerializationManager.DeserializeInner<FooType>(context); If there is no particular expected type for foo, use the non-generic DeserializeInner variant and pass null for the expected type. The BinaryTokenStreamReader class provides a wide variety of methods for reading data from the byte stream. An instance of the class can be obtained via the context.StreamReader property. See the class for documentation. Method 2: Writing a Serializer Provider In this method, you implement Orleans.Serialization.IExternalSerializer and add it to the SerializationProviders property on both ClientConfiguration on the client and GlobalConfiguration on the silos. Configuration is detailed in the Serialization Providers section above. Implementation of IExternalSerializer follows the pattern described for serialization methods from Method 1 above with the addition of an Initialize method and an IsSupportedType method which Orleans uses to determine if the serializer supports a given type. This is the interface definition: public interface IExternalSerializer { /// <summary> /// Initializes the external serializer. Called once when the serialization manager creates /// an instance of this type /// </summary> void Initialize(Logger logger); /// <summary> /// Informs the serialization manager whether this serializer supports the type for serialization. /// </summary> /// <param name=\"itemType\">The type of the item to be serialized</param> /// <returns>A value indicating whether the item can be serialized.</returns> bool IsSupportedType(Type itemType); /// <summary> /// Tries to create a copy of source. /// </summary> /// <param name=\"source\">The item to create a copy of</param> /// <param name=\"context\">The context in which the object is being copied.</param> /// <returns>The copy</returns> object DeepCopy(object source, ICopyContext context); /// <summary> /// Tries to serialize an item. /// </summary> /// <param name=\"item\">The instance of the object being serialized</param> /// <param name=\"context\">The context in which the object is being serialized.</param> /// <param name=\"expectedType\">The type that the deserializer will expect</param> void Serialize(object item, ISerializationContext context, Type expectedType); /// <summary> /// Tries to deserialize an item. /// </summary> /// <param name=\"context\">The context in which the object is being deserialized.</param> /// <param name=\"expectedType\">The type that should be deserialized</param> /// <returns>The deserialized object</returns> object Deserialize(Type expectedType, IDeserializationContext context); } Method 3: Writing a Serializer for Individual Types In this method you write a new class annotated with an attribute [SerializerAttribute(typeof(TargetType))] , where TargetType is the type which is being serialized, and implement the 3 serialization routines. The rules for how to write those routines are identical to method 1. Orleans uses the [SerializerAttribute(typeof(TargetType))] to determine that this class is a serializer for TargetType and this attribute can be specified multiple times on the same class if it's able to serialize multiple types. Below is an example for such a class: public class User { public User BestFriend { get; set; } public string NickName { get; set; } public int FavoriteNumber { get; set; } public DateTimeOffset BirthDate { get; set; } } [Orleans.CodeGeneration.SerializerAttribute(typeof(User))] internal class UserSerializer { [CopierMethod] public static object DeepCopier(object original, ICopyContext context) { var input = (User) original; var result = new User(); // Record 'result' as a copy of 'input'. Doing this immediately after construction allows for // data structures which have cyclic references or duplicate references. // For example, imagine that 'input.BestFriend' is set to 'input'. In that case, failing to record // the copy before trying to copy the 'BestFriend' field would result in infinite recursion. context.RecordCopy(original, result); // Deep-copy each of the fields. result.BestFriend = (User)context.SerializationManager.DeepCopy(input.BestFriend); result.NickName = input.NickName; // strings in .NET are immutable, so they can be shallow-copied. result.FavoriteNumber = input.FavoriteNumber; // ints are primitive value types, so they can be shallow-copied. result.BirthDate = (DateTimeOffset)context.SerializationManager.DeepCopy(input.BirthDate); return result; } [SerializerMethod] public static void Serializer(object untypedInput, ISerializationContext context, Type expected) { var input = (User) untypedInput; // Serialize each field. SerializationManager.SerializeInner(input.BestFriend, context); SerializationManager.SerializeInner(input.NickName, context); SerializationManager.SerializeInner(input.FavoriteNumber, context); SerializationManager.SerializeInner(input.BirthDate, context); } [DeserializerMethod] public static object Deserializer(Type expected, IDeserializationContext context) { var result = new User(); // Record 'result' immediately after constructing it. As with with the deep copier, this // allows for cyclic references and de-duplication. context.RecordObject(result); // Deserialize each field in the order that they were serialized. result.BestFriend = SerializationManager.DeserializeInner<User>(context); result.NickName = SerializationManager.DeserializeInner<string>(context); result.FavoriteNumber = SerializationManager.DeserializeInner<int>(context); result.BirthDate = SerializationManager.DeserializeInner<DateTimeOffset>(context); return result; } } Serializing Generic Types The TargetType parameter of [Serializer(typeof(TargetType))] can be an open-generic type, for example, MyGenericType<> . In that case, the serializer class must have the same generic parameters as the target type. Orleans will create a concrete version of the serializer at runtime for every concrete MyGenericType<T> type which is serialized, for example, one for each of MyGenericType<int> and MyGenericType<string> . Hints for Writing Serializers and Deserializers Often the simplest way to write a serializer/deserializer pair is to serialize by constructing a byte array and writing the array length to the stream, followed by the array itself, and then deserialize by reversing the process. If the array is fixed-length, you can omit it from the stream. This works well when you have a data type that you can represent compactly and that doesn't have sub-objects that might be duplicated (so you don't have to worry about object identity). Another approach, which is the approach the Orleans runtime takes for collections such as dictionaries, works well for classes with significant and complex internal structure: use instance methods to access the semantic content of the object, serialize that content, and deserialize by setting the semantic contents rather than the complex internal state. In this approach, inner objects are written using SerializeInner and read using DeserializeInner. In this case, it is common to write a custom copier, as well. If you write a custom serializer, and it winds up looking like a sequence of calls to SerializeInner for each field in the class, you don't need a custom serializer for that class. Fallback Serialization Orleans supports transmission of arbitrary types at runtime and therefore the in-built code generator cannot determine the entire set of types which will be transmitted ahead of time. Additionally, certain types cannot have serializers generated for them because they are inaccessible (for example, private ) or have fields which are inaccessible (for example, readonly ). Therefore, there is a need for just-in-time serialization of types which were unexpected or could not have serializers generated ahead-of-time. The serializer responsible for these types is called the fallback serializer . Orleans ships with two fallback serializers: Orleans.Serialization.BinaryFormatterSerializer which uses .NET's BinaryFormatter ; and Orleans.Serialization.ILBasedSerializer which emits CIL instructions at runtime to create serializers which leverage Orleans' serialization framework to serialize each field. This means that if an inaccessible type MyPrivateType contains a field MyType which has a custom serializer, that custom serializer will be used to serialize it. The fallback serializer can be configured using the FallbackSerializationProvider property on both ClientConfiguration on the client and GlobalConfiguration on the silos. var cfg = new ClientConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); var cfg = new GlobalConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); Alternatively, the fallback serialization provider can be specified in XML configuration: <Messaging> <FallbackSerializationProvider type=\"GreatCompany.FantasticFallbackSerializer, GreatCompany.SerializerAssembly\"/> </Messaging> .NET Core uses the ILBasedSerializer by default, whereas .NET 4.6 uses BinaryFormatterSerializer by default. Optimize Copying Using Immutable Types Orleans has a feature that can be used to avoid some of the overhead associated with serializing messages containing immutable types. This section describes the feature and its application, starting with context on where it is relevant. Serialization in Orleans When a grain method is invoked, the Orleans runtime makes a deep copy of the method arguments and forms the request out of the copies. This protects against the calling code modifying the argument objects before the data is passed to the called grain. If the called grain is on a different silo, then the copies are eventually serialized into a byte stream and sent over the network to the target silo, where they are deserialized back into objects. If the called grain is on the same silo, then the copies are handed directly to the called method. Return values are handled the same way: first copied, then possibly serialized and deserialized. Note that all 3 processes, copying, serializing, and deserializing, respect object identity. In other words, if you pass a list that has the same object in it twice, on the receiving side you'll get a list with the same object in it twice, rather than with two objects with the same values in them. Optimizing Copying In many cases, the deep copying is unnecessary. For instance, a possible scenario is a web front-end that receives a byte array from its client and passes that request, including the byte array, on to a grain for processing. The front-end process doesn't do anything with the array once it has passed it on to the grain; in particular, it doesn't reuse the array to receive a future request. Inside the grain, the byte array is parsed to fetch the input data, but not modified. The grain returns another byte array that it has created to get passed back to the web client; it discards the array as soon as it returns it. The web front-end passes the result byte array back to its client, without modification. In such a scenario, there is no need to copy either the request or response byte arrays. Unfortunately, the Orleans runtime can't figure this out by itself, since it can't tell whether or not the arrays are modified later on by the web front-end or by the grain. In the best of all possible worlds, we'd have some sort of .NET mechanism for indicating that a value is no longer modified; lacking that, we've added Orleans-specific mechanisms for this: the Immutable<T> wrapper class and the [Immutable] attribute. Using Immutable<T> The Orleans.Concurrency.Immutable<T> wrapper class is used to indicate that a value may be considered immutable; that is, the underlying value will not be modified, so no copying is required for safe sharing. Note that using Immutable<T> implies that neither the provider of the value nor the recipient of the value will modify it in the future; it is not a one-sided commitment, but rather a mutual dual-side commitment. Using Immutable<T> is simple: in your grain interface, instead of passing T , pass Immutable<T> . For instance, in the above described scenario, the grain method that was: Task<byte[]> ProcessRequest(byte[] request); Becomes: Task<Immutable<byte[]>> ProcessRequest(Immutable<byte[]> request); To create an Immutable<T> , simply use the constructor: Immutable<byte[]> immutable = new Immutable<byte[]>(buffer); To get the value inside the immutable, use the .Value property: byte[] buffer = immutable.Value; Using [Immutable] For user-defined types, the [Orleans.Concurrency.Immutable] attribute can be added to the type. This instructs Orleans' serializer to avoid copying instances of this type. The following code snippet demonstrates using [Immutable] to denote an immutable type. This type will not be copied during transmission. [Immutable] public class MyImmutableType { public MyImmutableType(int value) { this.MyValue = value; } public int MyValue { get; } } Immutability in Orleans For Orleans' purposes, immutability is a rather strict statement: the contents of the data item will not be modified in any way that could change the item's semantic meaning, or that would interfere with another thread simultaneously accessing the item. The safest way to ensure this is to simply not modify the item at all: bitwise immutability, rather than logical immutability. In some cases it is safe to relax this to logical immutability, but care must be taken to ensure that the mutating code is properly thread-safe; because dealing with multithreading is complex, and uncommon in an Orleans context, we strongly recommend against this approach and recommend sticking to bitwise immutability. Serialization Best Practices Serialization serves two primary purposes in Orleans: As a wire format for transmitting data between grains and clients at runtime. As a storage format for persisting long-lived data for later retrieval. The serializers generated by Orleans are suitable for the first purpose due to their flexibility, performance, and versatility. They are not as suitable for the second purpose, since they are not explicitly version-tolerant. It is recommended that users configure a version-tolerant serializer such as Protocol Buffers for persistent data. Protocol Buffers is supported via Orleans.Serialization.ProtobufSerializer from the Microsoft.Orleans.OrleansGoogleUtils NuGet package. The best-practices for the particular serializer of choice should be used in order to ensure version-tolerance. Third-party serializers can be configured using the SerializationProviders configuration property as described above."
  },
  "1.5/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html",
    "title": "Activation Garbage Collection | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Activation Garbage Collection As described in Grains , a grain activation is an in-memory instance of a grain class that gets automatically created by the Orleans runtime on an as-needed basis as a temporary physical embodiment of a grain. Activation Garbage Collection (Activation GC) is the process of removal from memory of unused grain activations. It is conceptually similar to how garbage collection of memory works in .NET. However, Activation GC only takes into consideration how long a particular grain activation has been idle. Memory usage is not used as a factor. How Activation GC Works The general process of Activation GC involves Orleans runtime in a silo periodically scanning for grain activations that have not been used at all for the configured period of time (Collection Age Limit). Once a grain activation has been idle for that long, it gets deactivated. The deactivation process begins by the runtime calling the grain’s OnDeactivateAsync() method, and completes by removing references to the grain activation object from all data structures of the silo, so that the memory is reclaimed by the .NET GC. As a result, with no burden put on the application code, only recently used grain activations stay in memory while activations that aren't used anymore get automatically removed, and system resources used by them get reclaimed by the runtime. What counts as “being active” for the purpose of grain activation collection receiving a method call receiving a reminder receiving an event via streaming What does NOT count as “being active” for the purpose of grain activation collection performing a call (to another grain or to an Orleans client) timer events arbitrary IO operations or external calls not involving Orleans framework Collection Age Limit This period of time after which an idle grain activation becomes subject to Activation GC is called Collection Age Limit. The default Collection Age Limit is 2 hours, but it can be changed globally or for individual grain classes. Explicit Control of Activation Garbage Collection Delaying Activation GC A grain activation can delay its own Activation GC, by calling this.DelayDeactivation() method: protected void DelayDeactivation(TimeSpan timeSpan) This call will ensure that this activation is not deactivated for at least the specified time duration. It takes priority over Activation Garbage Collection settings specified in the config, but does not cancel them. Therefore, this call provides an additional hook to delay the deactivation beyond what is specified in the Activation Garbage Collection settings . This call can not be used to expedite Activation Garbage Collection. A positive timeSpan value means “prevent GC of this activation for that time span”. A negative timeSpan value means “cancel the previous setting of the DelayDeactivation call and make this activation behave based on the regular Activation Garbage Collection settings”. Scenarios: 1) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (20 min), it will cause this activation to not be collected for at least 20 min. 2) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (5 min), the activation will be collected after 10 min, if no extra calls were made. 3) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (5 min), and after 7 minutes there is another call on this grain, the activation will be collected after 17 min from time zero, if no extra calls were made. 4) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (20 min), and after 7 minutes there is another call on this grain, the activation will be collected after 20 min from time zero, if no extra calls were made. Note that DelayDeactivation does not 100% guarantee that the grain activation will not get deactivated before the specified period of time expires. There are certain failure cases that may cause 'premature' deactivation of grains. That means that DelayDeactivation cannot not be used as a means to 'pin' a grain activation in memory forever or to a specific silo . DelayDeactivation is merely an optimization mechanism that can help reduce the aggregate cost of a grain getting deactivated and reactivated over time, if that matters. In most cases there should be no need to use DelayDeactivation at all. Expediting Activation GC A grain activation can also instruct the runtime to deactivate it next time it becomes idle by calling this.DeactivateOnIdle() method: protected void DeactivateOnIdle() A grain activation is considered idle if it is not processing any message at the moment. If you call DeactivateOnIdle while a grain is processing a message, it will get deactivated as soon as processing of the current message is finished. If there are any requests queued for the grain, they will be forwarded to the next activation. DeactivateOnIdle take priority over any Activation Garbage Collection settings specified in the config or DelayDeactivation . Note that this setting only applies to the grain activation from which it has been called and it does not apply to other grain activation of this type. Configuration Programmatic Configuration Default Collection Age Limit (for all grain types) can be set via: void GlobalConfiguration.Application.SetDefaultCollectionAgeLimit(TimeSpan ageLimit) For individual grain types the limit can be set via: void GlobalConfiguration.Application.SetCollectionAgeLimit(Type type, TimeSpan ageLimit) The limit can also be reset for a grain type, so that the default limit would apply to it, via: void GlobalConfiguration.Application.ResetCollectionAgeLimitToDefault(Type type) XML Configuration (deprecated) Any length of time in the configuration XML file may use a suffix that specifies a unit of time: Suffix Unit none millisecond(s) ms millisecond(s) s second(s) m minute(s) hr hour(s) Specifying Default Collection Age Limit The default collection age limit that applies to all grain types can be customized by adding the OrleansConfiguation/Globals/Application/Defaults/Deactivation element to the OrleansConfiguration.xml file. The minimal allowed age limit is 1 minute. The following example specifies that all activations that have been idle for 10 minutes or more should be considered eligible for deactivation. <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Application> <Defaults> <Deactivation AgeLimit=\"10m\"/> </Defaults> </Application> </Globals> </OrleansConfiguration> Specifying per-Type Age Limits Individual grain types may specify a collection age limit that is independent from the global default, using the OrleansConfiguation/Globals/Application/GrainType/Deactivation element. The minimal allowed age limit is 1 minute. In the following example, activations that have been idle for 10 minutes are eligible for collection, except activations that are instantiations of the MyGrainAssembly.DoNotDeactivateMeOften class, which are not considered collectable unless idle for a full 24 hours: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Application> <Defaults> <Deactivation AgeLimit=\"10m\"/> </Defaults> <GrainType Type=\"MyGrainAssembly.DoNotDeactivateMeOften\"> <Deactivation AgeLimit=\"24hr\"/> </GrainType> </Application> </Globals> </OrleansConfiguration> Any number of GrainType elements may be specified."
  },
  "1.5/Documentation/Advanced-Concepts/Cancellation-Tokens.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Cancellation-Tokens.html",
    "title": "Grain cancellation tokens | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain cancellation tokens The Orleans runtime provides mechanism called grain cancellation token, that enables the developer to cancel an executing grain operation. Description GrainCancellationToken is a wrapper around standard .NET System.Threading.CancellationToken , which enables cooperative cancellation between threads, thread pool work items or Task objects, and can be passed as grain method argument. A GrainCancellationTokenSource is a object that provides a cancellation token through its Token property and sends a cancellation message by calling its Cancel method. Usage Instantiate a CancellationTokenSource object, which manages and sends cancellation notification to the individual cancellation tokens. var tcs = new GrainCancellationTokenSource(); Pass the token returned by the GrainCancellationTokenSource.Token property to each grain method that listens for cancellation. var waitTask = grain.LongIoWork(tcs.Token, TimeSpan.FromSeconds(10)); A cancellable grain operation needs to handle underlying CancellationToken property of GrainCancellationToken just like it would do in any other .NET code. public async Task LongIoWork(GrainCancellationToken tc, TimeSpan delay) { while(!tc.CancellationToken.IsCancellationRequested) { await IoOperation(tc.CancellationToken); } } Call the GrainCancellationTokenSource.Cancel method to initiate cancellation. await tcs.Cancel(); Call the Dispose method when you are finished with the GrainCancellationTokenSource object. tcs.Dispose(); Important Considerations: The GrainCancellationTokenSource.Cancel method returns Task , and in order to ensure cancellation the cancel call must be retried in case of transient communication failure. Callbacks registered in underlying System.Threading.CancellationToken are subjects to single threaded execution guarantees within the grain activation on which they were registered. Each GrainCancellationToken can be passed through multiple methods invocations."
  },
  "1.5/Documentation/Advanced-Concepts/Reentrant-Grains.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Reentrant-Grains.html",
    "title": "Reentrant Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Reentrant Grains By default, the Orleans scheduler requires an activation to completely finish processing one request before invoking the next request. An activation cannot receive a new request until all of the Task s created (directly or indirectly) in the processing of the current request have been resolved and all of their associated closures executed. Grain implementation classes may be marked with the [Reentrant] attribute to indicate that turns belonging to different requests may be freely interleaved. In other words, a reentrant activation may start executing another request while a previous request has not finished processing and has pending closures. Execution of turns of both requests are still limited to a single thread. So the activation is still executing one turn at a time, and each turn is executing on behalf of only one of the activation’s requests. Reentrant grain code will never run multiple pieces of grain code in parallel (execution of grain code will always be single-threaded), but reentrant grains may see the execution of code for different requests interleaving. That is, the continuation turns from different requests may interleave. For example, with the below pseudo-code, when Foo and Bar are 2 methods of the same grain class: Task Foo() { await task1; // line 1 return Do2(); // line 2 } Task Bar() { await task2; // line 3 return Do2(); // line 4 } If this grain is marked [Reentrant] , the execution of Foo and Bar may interleave. For example, the following order of execution is possible: Line 1, line 3, line 2 and line 4. That is, the turns from different requests interleave. If the grain was not reentrant, the only possible executions would be: line 1, line 2, line 3, line 4 OR: line 3, line 4, line 1, line 2 (new request cannot start before the previous one finished). Reentrant grains should have slightly less overhead because of fewer activations, scheduling queues, smaller directory, and resources proportional to the number of activations. How small or large the “slightly” depends on what order of numbers we are talking about here, and on the potential overhead of handling interleaving requests (extra copies of state, etc.). The main tradeoff in choosing between reentrant and non-reentrant grains is the code complexity to make interleaving work correctly and the difficulty to reason about it. In a trivial case when the grains are stateless and the logic is simple, fewer (but not too few, so that all the hardware threads are used) reentrant grains should be in general slightly more efficient. If the code is more complex, then a larger number of non-reentrant grains, even if slightly less efficient overall, should save you a lot of grief of figuring out non-obvious interleaving issues. In the end answer will depend on the specifics of the application."
  },
  "1.5/Documentation/Advanced-Concepts/Powershell-Client.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Powershell-Client.html",
    "title": "PowerShell Client Module | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . PowerShell Client Module The Orleans PowerShell Client Module is a set of PowerShell Cmdlets that wraps GrainClient in a set of convenient commands making possible to interact with not just ManagementGrain but any IGrain just as a regular Orleans application can by using Powershell scripts. These Cmdlets enable a series of scenarios from start maintenance tasks, tests, monitoring or any other kind of automation by leveraging Powershell scripts. Here is how to use it: Installing the module From Source You can build from source the OrleansPSUtils project and just import it with: PS> Import-Module .\\projectOutputDir\\Orleans.psd1 Althought you can do that, there is a much easier and interesting way for doing that by installing it from PowerShell Gallery . From PowerShell Gallery Powershell modules today are easily shared just as Nuget packages but instead of nuget.org, they are hosted on PowerShell Gallery . To install it on a specific folder just run: PS> Save-Module -Name OrleansPSUtils -Path <path> To install it on your PowerShell modules path ( the recommended way ), just run: PS> Install-Module -Name OrleansPSUtils If you plan to use this module on an Azure Automation , just click on the button bellow: Using the module Regardless of the way you decide to install it, the first thing you need to do in order to actually use it is import the module on the current PowerShell session so the Cmdlets get available by running this: PS> Import-Module OrleansPSUtils Note : In case of building from source, you must import it as suggested on the Install section by using the path to the .psd1 instead of using the module name since it will not be on the $env:PSModulePath PowerShell runtime variable. Again, it is highly recommended that you install from PowerShell Gallery instead. After the module is imported (which means it is loaded on PowerShell session), you will have the following Cmdlets available: Start-GrainClient Stop-GrainClient Get-Grain Start-GrainClient This module is a wrapper around GrainClient.Initialize() and its overloads. Usage : Start-GrainClient The same as call GrainClient.Initialize() which will look for the known Orleans Client configuration file names Start-GrainClient [-ConfigFilePath] <string> [[-Timeout] <timespan>] Will use the provided file path as in GrainClient.Initialize(filePath) Start-GrainClient [-ConfigFile] <FileInfo> [[-Timeout] <timespan>] Use an instance of the System.FileInfo class representing the config file just as GrainClient.Initialize(fileInfo) Start-GrainClient [-Config] <ClientConfiguration> [[-Timeout] <timespan>] Use an instance of a Orleans.Runtime.Configuration.ClientConfiguration like in GrainClient.Initialize(config) Start-GrainClient [-GatewayAddress] <IPEndPoint> [[-OverrideConfig] <bool>] [[-Timeout] <timespan>] Takes a Orleans Cluster Gateway Address Endpoint Note : The Timeout parameter is optional and if it is informed and greater than System.TimeSpan.Zero , it will call Orleans.GrainClient.SetResponseTimeout(Timeout) internally. Stop-GrainClient Takes no parameters and when called, if the GrainClient is initialized will gracefuly uninitialize. Get-Grain Wrapper around GrainClient.GrainFactory.GetGrain<T>() and its overloads. The mandatory parameter is -GrainType and the -XXXKey for the current Grain key types supported by Orleans ( string , Guid , long ) and also the -KeyExtension that can be used on Grains with compound keys. This Cmdlet return a grain reference of the type passed by as parameter on -GrainType . Example: A simple example on calling MyInterfacesNamespace.IMyGrain.SayHeloTo grain method: PS> Import-Module OrleansPSUtils PS> $configFilePath = Resolve-Path(\".\\ClientConfig.xml\").Path PS> Start-GrainClient -ConfigFilePath $configFilePath PS> Add-Type -Path .\\MyGrainInterfaceAssembly.dll PS> $grainInterfaceType = [MyInterfacesNamespace.IMyGrain] PS> $grainId = [System.Guid]::Parse(\"A4CF7B5D-9606-446D-ACE9-C900AC6BA3AD\") PS> $grain = Get-Grain -GrainType $grainInterfaceType -GuidKey $grainId PS> $message = $grain.SayHelloTo(\"Gutemberg\").Result PS> Write-Output $message Hello Gutemberg! PS> Stop-GrainClient We plan to update this page as we introduce more Cmdlets like use Observers, Streams and other Orleans core features more natively on Powershell. We hope that this help people as a starting point for automation. As always, this is a work-in-progress and we love contributions! :) Please note that the intent is not to reimplement the whole client on PowerShell but instead, give IT and DevOps teams a way to interact with the Grains without need to implement a .Net application."
  },
  "1.5/Documentation/Advanced-Concepts/Codegen.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Codegen.html",
    "title": "Code Generation | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Code Generation Efficient code generation is one of the pillars of the Orleans Runtime . The Orleans Runtime makes use of generated code in order to ensure proper serialization of types that are used across the cluster as well as for generating boilerplate which abstracts away the implementation details of method shipping, exception propagation, and other internal runtime concepts. There are two modes of OrleansCodeGenerator : Build-time Codegen - in this mode, codegen will run every time your project is compiled. A build task is injected into your project's build pipeline and the code is generated in the project's intermediate output directory. To activate this mode, add the package Microsoft.Orleans.OrleansCodeGenerator.Build to your Grain Interface project. If you edit your .csproj file, you will see that an extra build target was added. This mode allows a user to step-into the generated code while debugging since the file is physically on the disk. However, your build time will be slower than usual if you have big projects. This is the default mode selected when you create a Grain Interface project by using the Visual Studio templates. Runtime Codegen - This mode makes OrleansCodeGenerator to generate code when the Silo is starting. As such, no code is generated during the build. Users can therefore not step-into the generated code while debugging and it will increase silo initialization time. To enable this mode, if you were using the build-time codegen, remove the the Microsoft.Orleans.OrleansCodeGenerator.Build package and install Microsoft.Orleans.OrleansCodeGenerator in your Silo Host and Client projects. If the project was created via the Visual Studio templates then it will already be installed. Otherwise, just install Microsoft.Orleans.OrleansCodeGenerator on your silo & client projects. Both modes generate the same code with the exception that run-time code generation can only generate code for publicly accessible types."
  },
  "1.5/Documentation/Multi-Cluster/GossipChannels.html": {
    "href": "1.5/Documentation/Multi-Cluster/GossipChannels.html",
    "title": "Multi-Cluster Communication | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Communication The network must be configured in such a way that any Orleans silo can connect to any other Orleans silo via TCP/IP, regardless of where in the world it is located. Exactly how this is achieved is outside of the scope of Orleans, as it depends on how and where silos are deployed. For example, on Windows Azure, we can use VNETs to connect muliple deployments within a region, and gateways to connect VNETs across different regions. Cluster Id Each cluster has its own unique cluster id. The cluster id must be specified in the global configuration. Cluster ids may not be empty, nor may they contain commas. Also, if using Azure Table Storage, cluster ids may not contain the characters forbidden for row keys (/, , #, ?). We recommend using very short strings for the cluster ids, because cluster ids are transmitted frequently and may be stored in storage by some log-view providers. Cluster Gateways Each cluster automatically designates a subset of its active silos to serve as cluster gateways . Cluster gateways directly advertise their IP addresses to other clusters, and can thus serve as \"points of first contact\". By default, at most 10 silos (or whatever number is configured as MaxMultiClusterGateways ) are designated as cluster gateways. Communication between silos in different clusters does not always pass through a gateway. Once a silo has learned and cached the location of a grain activation (no matter in what cluster), it sends messages to that silo directly, even if the silo is not a cluster gateway. Gossip Gossip is a mechanism for clusters to share configuration and status information. As the name suggests, gossip is decentralized and bidirectional: each silo communicates directly with other silos, both in the same cluster and in other clusters, to exchange information in both directions. Content . Gossip contains some or all of the following information: The current time-stamped multi-cluster configuration . A dictionary that contains information about cluster gateways. The key is the silo address, and the value contains (1) a timestamp, (2) the cluster id, and (3) a status, which is either active or inactive. Fast & Slow Propagation . When a gateway changes its status, or when an operator injects a new configuration, this gossip information is immediately sent to all silos, clusters, and gossip channels. This happens fast, but is not reliable. Should the message be lost due to any reasons (e.g. races, broken sockets, silo failures), our periodic background gossip ensures that the information eventually spreads, albeit more slowly. All information is eventually propagated everywhere, and is highly resilient to occasional message loss and failures. All gossip data is timestamped, which ensures that newer information replaces older information regardless of the relative timing of messages. For example, newer multi-cluster configurations replace older ones, and newer information about a gateway replaces older information about that gateway. For more details on the representation of gossip data, see the MultiClusterData class. It has a Merge method that combines gossip data, resolving conflicts using timestamps. Gossip Channels When a silo is first started, or when it is restarted after a failure, it needs to have a way to bootstrap the gossip . This is the role of the gossip channel , which can be configured in the Silo Configuration . On startup, a silo fetches all the information from the gossip channels. After startup, a silo keeps gossiping periodically, every 30 seconds or whatever is configured as BackgroundGossipInterval . Each time it synchronizes its gossip information with a partner randomly selected from all cluster gateways and gossip channels. Notes: Though not strictly required, we recommend to always configure at least two gossip channels, in distinct regions, for better availability. Latency of communication with gossip channels is not critical. Multiple different services can use the same gossip channel without interference, as long as the ServiceId Guid (as specified by their respective configuration) is distinct. There is no strict requirement that all silos use the same gossip channels, as long as the channels are sufficient to let a silo initially connect with the \"gossiping community\" when it starts up. But if a gossip channel is not part of a silo's configuration, and that silo is a gateway, it does not push its status updates to the channel (fast propagation), so it may take longer before those reach the channel via periodic background gossip (slow propagation). Azure-Table-Based Gossip Channel We have already implemented a gossip channel based on Azure Tables. The configuration specifies standard connection strings used for Azure accounts. For example, a configuration could specify two gossip channels with separate Azure storage accounts usa and europe as follows: <MultiClusterNetwork ClusterId=\"...\"> <GossipChannel Type=\"AzureTable\" ConnectionString=\"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"/> <GossipChannel Type=\"AzureTable\" ConnectionString=\"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\"/> </MultiClusterNetwork> Multiple different services can use the same gossip channel without interference, as long as the ServiceId guid specified by their respective configuration is distinct. Other Gossip Channel Implementations We are working on other gossip channel providers, similar to how membership and reminders are packaged for many different storage back-ends."
  },
  "1.5/Documentation/Multi-Cluster/Overview.html": {
    "href": "1.5/Documentation/Multi-Cluster/Overview.html",
    "title": "Multi-Cluster Support | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Support Orleans v.1.3.0 added support for federating several Orleans clusters into a loosely connected multi-cluster that acts like a single service. Multi-clusters facilitate geo-distribution of a service, that is, make it easier to run an Orleans application in multiple data-centers around the world. Also, a multi-cluster can be run within a single datacenter to get better failure and performance isolation. All mechanisms are designed with particular attention to (1) minimize communication between clusters, and (2) let each cluster run autonomously even if other clusters fail or become unreachable. Configuration and Operation Below we document how to configure and operate a multi-cluster. Communication . Clusters communicate via the same silo-to-silo connections that are used within a cluster. To exchange status and configuration information, Clusters use a gossip mechanism and gossip channel implementations. Silo Configuration . Silos need to be configured so they know which cluster they belong to (each cluster is identified by a unique string). Also, each silo needs to be configured with connection strings that allow them to connect to one or more gossip channels on startup. Multi-Cluster Configuration Injection . At runtime, the service operator can specify and/or change the multi-cluster configuration , which contains a list of cluster ids, to specify which clusters are part of the current multi-cluster. This is done by calling the management grain in any one of the clusters. Multi-Cluster Grains Below we document how to use multi-cluster functionality at the application level. Global-Single-Instance Grains . Developers can indicate when and how clusters should coordinate their grain directories with respect to a particular grain class. The [GlobalSingleInstance] attribute means we want the same behavior as as when running Orleans in a single global cluster: that is, route all calls to a single activation of the grain. Conversely, the [OneInstancePerCluster] attribute indicates that each cluster can have its own independent activation. This is appropriate if communication between clusters is undesired. Log-View Grains (not in v.1.3.0) . A special type of grain that uses a new API, similar to event sourcing, for synchronizing or persisting grain state. It can be used to automatically and efficiently synchronize the state of a grain between clusters and with storage. Because its synchronization algorithms are safe to use with reentrant grains, and are optimized to use batching and replication, it can perform better than standard grains when a grain is frequently accessed in multiple clusters, and/or when it is written to storage frequently. Support for log-view grains is not part of the master branch yet. We have a prerelease including samples and a bit of documentation in the geo-orleans branch . It is currently being evaluated in production by an early adopter."
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html",
    "title": "Developing a Client | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . What Is Grain Client? The term \"Client\" or sometimes \"Grain Client\" is used for application code that interacts with grains but itself is not part of a grain logic. Client code runs outside of the cluster of Orleans servers called silos where grains are hosted. Hence, a client acts as a connector or conduit to the cluster and to all grains of the application. Usually, clients are used on the frontend web servers to connect to an Orleans cluster that serves as a middle tier with grains executing business logic. In a typical setup, a frontend web server: Receives a web request Performs necessary authentication and authorization validation Decides which grain(s) should process the request Uses Grain Client to make one or more method call to the grain(s) Handles successful completion or failures of the grain calls and any returned values Sends a response for the web request Initialization of Grain Client Before a grain client can be used for making calls to grains hosted in an Orleans cluster, it needs to be configured, initialized, and connected to the cluster. Configuration is provided via a ClientConfiguration object that contains a hierarchy of configuration properties for programmatically configuring a client. There is also a way to configure a client via a XML file, but that option will be deprecated in the future. More information is in the Client Configuration guide . Here we will simply use a helper method that creates a configuration object hardcoded for connecting to a local silo running as localhost . ClientConfiguration clientConfig = ClientConfiguration.LocalhostSilo(); Once we have a configuration object, we can build a client via the ClientBuilder class. IClusterClient client = new ClientBuilder().UseConfiguration(clientConfig).Build(); Lastly, we need to call Connect() method on the constructed client object to make it connect to the Orleans cluster. It's an asynchronous method that returns a Task . So we need to wait for its completion with an await or .Wait() . await client.Connect(); Making Calls to Grains Making calls to grain from a client is really no different from making such calls from within grain code . The same GetGrain<T>(key) method, where T is the target grain interface, is used in both cases to obtain grain references . The slight difference is in through what factory object we invoke GetGrain . In client code we do that through the connected client object. IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Task t = player.JoinGame(game) await t; A call to a grain method returns a Task or a Task<T> as required by the grain interface rules . The client can use the await keyword to asynchronously await the returned Task without blocking the thread, or in some cases the Wait() method to block the current thread of execution. The major difference between making calls to grains from client code and from within another grain is the single-threaded execution model of grains. Grains are constrained to be single-threaded by the Orleans runtime, while clients may be multi-threaded. Orleans does not provide any such guarantee on the client side, and so it is up to the client to manage its own concurrency using whatever synchronization constructs are appropriate for its environment – locks, events, Tasks , etc. Receiving notifications There are situations in which a simple request-response pattern is not enough, and the client needs to receive asynchronous notifications. For example, a user might want to be notified when a new message has been published by someone that she is following. Observers is one such mechanism that enables exposing client side objects as grain-like targets to get invoked by grains. Calls to observers do not provide any indication of success or failure, as they are sent as one-way best effort message. So it is a responsibility of the application code to build a higher level reliability mechanism on top of observers where necessary. Another mechanism that can be used for delivering asynchronous messages to clients is Streams . Streams expose indications of success or failure of delivery of individual messages, and hence enable reliable communication back to the client. Example Here is an extended version of the example given above of a client application that connects to Orleans, finds the player account, subscribes for updates to the game session the player is part of with an observer, and prints out notifications until the program is manually terminated. namespace PlayerWatcher { class Program { /// <summary> /// Simulates a companion application that connects to the game /// that a particular player is currently part of, and subscribes /// to receive live notifications about its progress. /// </summary> static void Main(string[] args) { RunWatcher().Wait(); // Block main thread so that the process doesn't exit. // Updates arrive on thread pool threads. Console.ReadLine(); } static async Task RunWatcher() { try { // Connect to local silo var config = ClientConfiguration.LocalhostSilo(); var client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); // Hardcoded player ID Guid playerId = new Guid(\"{2349992C-860A-4EDA-9590-000000000006}\"); IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); IGameGrain game = null; while (game == null) { Console.WriteLine(\"Getting current game for player {0}...\", playerId); try { game = await player.GetCurrentGame(); if (game == null) // Wait until the player joins a game { await Task.Delay(5000); } } catch (Exception exc) { Console.WriteLine(\"Exception: \", exc.GetBaseException()); } } Console.WriteLine(\"Subscribing to updates for game {0}...\", game.GetPrimaryKey()); // Subscribe for updates var watcher = new GameObserver(); await game.SubscribeForGameUpdates( await client.CreateObjectReference<IGameObserver>(watcher)); Console.WriteLine(\"Subscribed successfully. Press <Enter> to stop.\"); } catch (Exception exc) { Console.WriteLine(\"Unexpected Error: {0}\", exc.GetBaseException()); } } } /// <summary> /// Observer class that implements the observer interface. Need to pass a grain reference to an instance of this class to subscribe for updates. /// </summary> class GameObserver : IGameObserver { // Receive updates public void UpdateGameScore(string score) { Console.WriteLine(\"New game score: {0}\", score); } } } } Next Running the Application"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Implementation.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Implementation.html",
    "title": "Orleans Streams Implementation Details | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Implementation Details This section provides a high level overview of Orleans Stream implementation. It describes concepts and details that are not visible on the application level. If you only plan to use streams, you do not have to read this section. However, if you plan to extend streams, please read this section before reading Streams Extensibility section . Terminology : We refer by the word \"queue\" to any durable storage technology that can ingest stream events and allows either to pull events or provides a push-based mechanism to consume events. Usually, to provide scalability, those technologies provide sharded/partitions queues. For example, Azure Queues allow to create multiple queues, Event Hubs have multiple hubs, Kafka topics, ... Persistent Streams All Orleans Persistent Stream Providers share a common implementation PersistentStreamProvider . This generic stream provider is parametrized with a technology specific IQueueAdapter . When stream producer generates a new stream item and calls stream.OnNext() , Orleans Streaming Runtime invokes the appropriate method on the IQueueAdapter of that stream provider that enqueues the item directly into an appropriate queue. Pulling Agents At the heart of the Persistent Stream Provider are the pulling agents. Pulling agents pull events from a set of durable queues and deliver them to the application code in grains that consumes them. One can think of the pulling agents as a distributed \"micro-service\" -- a partitioned, highly available, and elastic distributed component. The pulling agents run inside the same silos that host application grains and are fully managed by the Orleans Streaming Runtime. StreamQueueMapper and StreamQueueBalancer Pulling agents are parametrized with IStreamQueueMapper and StreamQueueBalancerType . IStreamQueueMapper provides a list of all queues and is also responsible for mapping streams to queues. That way, the producer side of the Persistent Stream Provider know which queue to enqueue the message into. StreamQueueBalancerType expresses the way queues are balanced across Orleans silos and agents. The goal is to assign queues to agents in a balanced way, to prevent bottlenecks and support elasticity. When new silo is added to the Orleans cluster, queues are automatically rebalanced across the old and new silos. StreamQueueBalancer allows to customize that process. Orleans has a number of built in StreamQueueBalancers, to support different balancing scenarios (large and small number of queues) and different environments (Azure, on prem, static). Pulling Protocol Every silo runs a set of pulling agents, every agent is pulling from one queue. Pulling agents themselves are implemented by the internal runtime component, called SystemTarget . SystemTargets are essentially runtime grains, are subject to single threaded concurrency, can use regular grain messaging and are as lightweight as grains. As opposite to grain, SystemTargets are not virtual: they are explicitly created (by the runtime) and are also not location transparent. By implementing pulling agents as SystemTargets Orleans Streaming Runtime can rely on a lot of built-in Orleans features and can also scale to a very large number of queues, since creating a new pulling agent is as cheap as creating a new grain. Every pulling agent runs periodic timer that pulls from the queue (by invoking IQueueAdapterReceiver ) GetQueueMessagesAsync() method. The returned messages are put in the internal per-agent data structure called IQueueCache . Every message is inspected to find out its destination stream. The agent uses the Pub Sub to find out the list of stream consumers that subscribed to this stream. Once the consumer list if retrieved, the agent stores it locally (in its pub-sub cache) so it does not need to consult with Pub Sub on every message. The agent also subscribes with the pub-sub to receive notification of any new consumers that subscribe to that stream. This handshake between the agent and the pub-sub guarantees strong streaming subscription semantics : once the consumer has subscribed to the stream it will see all events that were generated after it has subscribed (in addition, using StreamSequenceToken allows to subscribe in the past). Queue Cache IQueueCache is an internal per-agent data structure that allows to decouple bringing new events from the queue from delivering them to consumers. It also allows to decouple delivery to different streams and to different consumers. Imagine a situation when one stream has 3 stream consumers and one of them is slow. If care not taken, it is possible that this slow consumer will impact agent's progress, slowing the consumption of other consumers of that stream, and even potentially slowing the de-queuing and delivering of events for other stream. To prevent that and allow maximum parallelism in the agent, we use IQueueCache . IQueueCache buffers stream events and provides a way to the agent to deliver events to each consumer at its pace. The per-consumer delivery is implemented by the internal component called IQueueCacheCursor , which tracks per consumer progress. That way each consumer receives events at its own pace :fast consumers receive events as quickly as they are dequeued from the queue, while slow consumers receive them later on. Once the message was delivered to all consumers, it can be deleted from the cache. Backpressure Backpressure in Orleans Streaming Runtime applies in two places: bringing stream events from the queue to the agent and delivering the events from the agent to stream consumers . The latter is provided by the built-in Orleans messaging delivery mechanism. Every stream event is delivered from the agent to consumers via the standard Orleans grain messaging, one at a time. That is, the agents sends one event (or a limited size batch of events) to each individual stream consumer and awaits this call. The next event will not start being delivered until the Task for the previous event was resolved or broken. That way we naturally limit the per-consumer delivery rate to one message at a time. With regard to bringing stream events from the queue to the agent Orleans Streaming provides a new special Backpressure mechanism. Since the agent decouples de-queuing of events from the queue and delivering them to consumers, it is possible that a single slow consumer will fall behind so much that the IQueueCache will fill up. To prevent IQueueCache from growing indefinitely, we limit its size (the size limit is configurable). However, the agent never throws away undelivered events. Instead, when the cache starts to fill up, the agents slows the rate of dequeing events from the queue. That way, we can \"ride\" the slow delivery periods by adjusting the rate at which we consume from the queue (\"backpressure\") and get back into fast consumption rate later on. To detect the \"slow delivery\" valleys the IQueueCache uses an internal data structure of cache buckets that track the progress of delivery of events to individual stream consumer. This results in a very responsive and self-adjusting systems. Next Orleans Streams Extensibility"
  },
  "1.5/Documentation/Orleans-Streams/index.html": {
    "href": "1.5/Documentation/Orleans-Streams/index.html",
    "title": "Orleans Streams | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Orleans v.1.0.0 added support for streaming extensions to the programing model. Streaming extensions provide a set of abstractions and APIs that make thinking about and working with streams simpler and more robust. Streaming extensions allow developers to write reactive applications that operate on a sequence of events in a structured way. The extensibility model of stream providers makes the programming model compatible with and portable across a wide range of existing queuing technologies, such as Event Hubs , ServiceBus , Azure Queues , and Apache Kafka . There is no need to write special code or run dedicated processes to interact with such queues. Why should I care? If you already know all about Stream Processing and are familiar with technologies like Event Hubs , Kafka , Azure Stream Analytics , Apache Storm , Apache Spark Streaming , and Reactive Extensions (Rx) in .NET , you may be asking why should you care. Why do we need yet another Stream Processing System and how Actors are related to Streams? \"Why Orleans Streams?\" is meant to answer that question. Programming Model There is a number of principles behind Orleans Streams Programming Model. Following the philosophy of Orleans virtual actors , Orleans streams are virtual . That is, a stream always exists. It is not explicitly created or destroyed, and it can never fail. Streams are identified by stream IDs, which are just logical names comprised of GUIDs and strings. Orleans Streams allow to decouple generation of data from its processing both in time and space . That means that stream producer and stream consumer may be on different servers, in different times and will withstand failures. Orleans streams are lightweight and dynamic . Orleans Streaming Runtime is designed to handle a large number of streams that come and go at a high rate. Orleans stream bindings are dynamic . Orleans Streaming Runtime is designed to handle cases where grains connect to and disconnect from streams at a high rate. Orleans Streaming Runtime transparently manages the lifecycle of stream consumption . After an application subscribes to a stream, from then on it will receive the stream's events, even in presence of failures. Orleans streams work uniformly across grains and Orleans clients . Programming APIs Applications interact with streams via APIs that are very similar to the well known Reactive Extensions (Rx) in .NET , by using Orleans.Streams.IAsyncStream<T> that implements Orleans.Streams.IAsyncObserver<T> and Orleans.Streams.IAsyncObservable<T> interfaces. In a typical example below a device generates some data, which is sent as an HTTP request to the service running in the Cloud. Orleans client running in the front end server receives this HTTP call and publishes the data into a matching device stream: public async Task OnHttpCall(DeviceEvent deviceEvent) { // Post data directly into device's stream. IStreamProvider streamProvider = GrainClient.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<DeviceEventData> deviceStream = streamProvider.GetStream<DeviceEventData>(deviceEvent.DeviceId); await deviceStream.OnNextAsync(deviceEvent.Data); } In another example below a chat user (implemented as Orleans Grain) joins a chat room, gets a handle to a stream of chat messages generated by all others users in this room and subscribes to it. Notice that the chat user neither does not need to know about the chat room grain itself (there might not be such a grain in our system) nor about other user in that group that produce messages. Needless to say, to produce to the chat stream, users don't need to know who is currently subscribed to the stream. This demonstrates how chat users can be completely decoupled in time and space. public class ChatUser: Grain { public async Task JoinChat(string chatGroupName) { IStreamProvider streamProvider = base.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<string> chatStream = streamProvider.GetStream<string>(chatGroupName); await chatStream.SubscribeAsync((string chatEvent) => Console.Out.Write(chatEvent)); } } Quick Start Sample The Quick Start Sample is a good quick overview of the overall workflow of using streams in the application. After reading it you should read the Streams Programming APIs to get a deeper understanding of the concepts. Streams Programming APIs A Streams Programming APIs provides detailed description of the programming APIs. Stream Providers Streams can come via physical channels of various shapes and forms and can have different semantics. Orleans Streaming is designed to support this diversity via the concept of Stream Providers , which is an extensibility point in the system. Orleans currently has implementation of two stream providers: TCP based Simple Message Stream Provider and Azure Queue based Azure Queue Stream Provider . More details on Steam Providers can be found at Stream Providers . Stream Semantics Stream Subsription Semantics : Orleans Streams guarantee Sequential Consistency for Stream Subsription operations. Specificaly, when consumer subscribes to a stream, once the Task representing the subsription operation was successfuly resolved, the consumer will see all events that were generated after it has subscribed. In addition, Rewindable streams allow to subscribe from an arbitrary point in time in the past by using StreamSequenceToken (more details can be found here ). Individual Stream Events Delivery Guarantees : Individual event delivery guarantees depend on individual stream providers. Some provide only best-effort at-most-once delivery (such as Simple Message Streams), while others provide at-least-once delivery (such as Azure Queue Streams). It is even possible to build a stream provider that will guarantee exactly-once delivery (we don't have such a provider yet, but it is possible to build one with the extensability model ). Events Delivery Order : Event order also depends on a particular stream provider. In SMS streams, the producer explicitelly controls the order of events seen by the consumer by controlling the way it publishes them. Azure Queue streams do not guarantee FIFO order, since the underlaying Azure Queues do not guarantee order in failure cases. Applications can also control their own stream delivery ordering, by using StreamSequenceToken . Streams Implementation The Orleans Streams Implementation provides a high level overview of the internal implementation. Streams Extensibility The Orleans Streams Extensibility describes how to extend streams with new functionality. Code Samples More examples of how to use streaming APIs within a grain can be found here . We plan to create more samples in the future. More Material Orleans Virtual Meetup about Streams [Orleans Streaming Presentation from Virtual Meetup]( http://dotnet.github.io/orleans/Presentations/Orleans Streaming - Virtual meetup - 5-22-2015.pptx)"
  },
  "1.5/Documentation/Samples-Overview/GPS-Tracker.html": {
    "href": "1.5/Documentation/Samples-Overview/GPS-Tracker.html",
    "title": "GPS Tracker | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . GPS Tracker A sample application to show how Orleans could be used in conjunction with SignalR to monitor the position of a number of GPS enabled devices, and report these to a web browser. In order to run this sample, you need a Bing Maps API key. The key is used by the GPSTracker.Web project, in Views\\Home\\Index.cshtml. Get a Bing Maps Key Running the Sample Running the sample locally: Open the GPSTracker.sln file in Visual Studio 2013, and build the solution. Start the local Orleans Silo by running the Host project of the solution. In Visual Studio, right click on the GPSTracker.Web project, and click Set as StartUp Project . Press F5 to start GPSTracker.Web web application. Your browser should open on a map of San Francisco. In a command window, navigate to the GPSTracker.FakeDeviceGateway\\bin\\Debug directory, and run the 'GPSTracker.FakeDeviceGateway.exe' program. Pushpins should appear on the map, and move around. Blue ones are moving slow, orange faster. How it Works The GPSTracker.FakeDeviceGateway.exe program simulates data generated from 20 GPS devices. It randomly alters their speed and heading to simulate the devices moving within rectangular boundaries. It sends the position data to Orleans once a second. In Orleans, each device is represented by a Device grain. The grain records the previous position of the device, and can therefore calculate the speed of the device. If the devices has moved, the 'Device' grain forwards position and speed to a PushNotification grain. This 'PushNotification' grain maintains a C# SignalR client, which connects to a SignalR hub hosted in the GPSTracker.Web project. This allows the grain to 'push' messages to the hub without the need for polling the Orleans API. The grain will batch messages together to improve network performance. The GPSTracker.Web application forwards all messages to connected web browsers using SignalR. JavaScript running in the browser positions the pins using a Bing Maps control. If the pin has a low velocity it colors it blue, otherwise orange. Advantages of using Orleans This sample is designed to show Orleans as a low-latency messaging system. Orleans is able to hold state for each device in memory (of which there may be many), allowing a quick calculation to be performed (calculating velocity) based on previous state. The grain in Orleans can also decide whether the message is worthy of forwarding downstream (has the device moved?) and can therefore filter out unnecessary messages and reduce noise. The sample also illustrates how SignalR may be used from inside a grain to allow 'push' messaging directly to clients. In a real life scenario you would probably not forward all messages to the browser, and would filter based on groups or device type."
  },
  "1.5/Documentation/Samples-Overview/Presence-Service.html": {
    "href": "1.5/Documentation/Samples-Overview/Presence-Service.html",
    "title": "Presence Service | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Presence Service A presence service serves as the hub of many social applications, including multi-player games and chats. Its essential function is to know who is online at given point in time and alert other users of their online presence. Each logged-in player sends a \"heartbeat pulse\" at regular intervals, In this section we walk through the steps involved in defining and using a new Player grain type. The grain type we define will have one property that returns a reference to the game the player is currently in, and two methods for joining and leaving a game. We will create three separate pieces of code: the grain interface definition, the grain implementation, and a standard C# class that uses the grain. Each of these belongs in a different project, built into a different DLL: the interface needs to be available on both the \"client\" and \"server\" sides, while the implementation class should be hidden from the client, and the client class from the server. The interface project should be created using the Visual Studio \"Orleans Grain Interface Collection\" template that is included in the Orleans SDK, and the grain implementation project should be created using the Visual Studio \"Orleans Grain Class Collection\" template. The grain client project can use any standard .NET code project template, such as the standard Console Application or Class Library templates. A grain cannot be explicitly created or deleted. It always exists \"virtually\" and is activated automatically when a request is sent to it. A grain has either a GUID, string or a long integer key within the grain type. Application code creates a reference to a grain by calling the GetGrain<TGrainType>(Guid id) or GetGrain<TGrainType>(long id) or other overloads of a generic grain factory methods for a specific grain identity. The GetGrain() call is a purely local operation to create a grain reference. It does not trigger creation of a grain activation and has not impact on its life cycle. A grain activation is automatically created by the Orleans runtime upon a first request sent to the grain. A grain interface must inherit from one of the IGrainWithXKey .interfaces where X is the type of the key used. The GUID, string or long integer key of a grain can later be retrieved via the GetPrimaryKey() or GetPrimaryKeyLong() extension methods, respectively. Defining the Grain Interface A grain type is defined by an interface that inherits from one of the IGrainWithXKey marker interfaces like 'IGrainWithGuidKey' or 'IGrainWithStringKey'. All of the methods in the grain interface must return a Task or a Task<T> . The underlying type T for value Task must be serializable. Example: public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } Using the Grain Factory After the grain interface has been defined, building the project originally created with the Orleans Visual Studio project template will use the Orleans-specific MSBuild targets to generate a client proxy classes corresponding to the user-defined grain interfaces and to merge this additional code back into the interface DLL. Application should use the generic grain factory class to get references to grains. Inside the grain code, the factory is available via the protected GrainFactory class member property. On the client side the factory is available via the GrainClient.GrainFactory static field. When running inside a grain the following code should be used to get the grain reference: this.GrainFactory.GetGrain<IPlayerGrain>(grainKey); When running on the Orleans client side the following code should be used to get the grain reference: GrainClient.GrainFactory.GetGrain<IPlayerGrain>(grainKey); The Implementation Class A grain type is materialized by a class that implements the grain type’s interface and inherits directly or indirectly from Orleans.Grain . The PlayerGrain grain class implements the IPlayerGrain interface. public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGameAsync() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGameAsync(IGameGrain game) { currentGame = game; Console.WriteLine(\"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return TaskDone.Done; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGameAsync(IGameGrain game) { currentGame = null; Console.WriteLine(\"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return TaskDone.Done; } }"
  },
  "1.5/Documentation/Samples-Overview/Tic-Tac-Toe.html": {
    "href": "1.5/Documentation/Samples-Overview/Tic-Tac-Toe.html",
    "title": "Tic Tac Toe | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Tic Tac Toe TicTacToe is based on the classic board game, also known as \"noughts and crosses.\" Its game logic is simple, which makes it an excellent sample for showing how a turn-based game could be easily implemented in Orleans. A game like this may not at first sight seem a natural fit for Orleans, if you only think about it in terms of a single player game. However, within a social game context, such as a Facebook game, where thousands of players could be playing dozens of games at any one time - some games waiting for the opponent to join, others mid game, waiting for the next move to play out, then it is a much more natural fit. Orleans enables the developer to concentrate on expressing game logic as grains, letting the runtime handle the scale. This sample also demonstrates how an Orleans application can be deployed to Windows Azure. Running the Sample The sample comes complete with a Windows Azure project, so it can be run locally in the Windows Azure local emulator, or deployed as a real cloud service. If running locally, you will need to create multiple \"private\" browsing sessions, to ensure each browser session is recognized as a new player. To run locally without the emulator: Open the TicTacToe.sln file in Visual Studio and build the solution. Set the TicTacToe.Grains project as the startup project. Press F5 to start the application. Start the TicTacToe.Web project manually using the Project context menu -> Debug -> Start new instance Your browser should open, asking you to enter your name. To run locally using the Azure emulator: Open the TicTacToe.sln file in Visual Studio and build the solution. Set the TicTacToe.Azure project as the startup project. Start the Azure Compute Emulator if necessary. Press F5 to start the application. Your browser should open, asking you to enter your name. To run in Windows Azure: Open the TicTacToe.sln file in Visual Studio and build the solution. Expand the TicTacToe.Azure project, and in the Roles folder, open the properties for TicTacToe.Web and TicTacToe.WorkerRole . Set the value for the DataConnectionString setting for both roles to a Windows Azure Storage Account. Right click on the TicTacToe.Azure project, and click Publish . Follow the instructions in the wizard to deploy the application on Azure. The application will deploy, and you will be able to access on http://YOURCLOUDSERVICE.cloudapp.net/ How it works There are two main grain types in OrleansXO, one represents a player, the other representing a game. User Grain A PlayerGrain is activated for each player logging in to the system. A GUID is used to uniquely identify the user, which is stored in a cookie by the MVC web application. The IPlayer interface defines the operations a player can perform: public interface IPlayer : IGrain { Task<List<GameSummary>> GetGameSummaries(); Task<Guid> CreateGame(); Task<GameState> JoinGame(Guid gameId); Task LeaveGame(Guid gameId, GameOutcome outcome); Task SetUsername(string username); Task<string> GetUsername(); } The player grain handles the creating of new games (so another player can then join), leaving a game (once it is over), and tracking the progress of all active games. Game Grain Each game is also represented by a GameGrain . They are also uniquely identify using a GUID. public interface IGame : Orleans.IGrain { Task<GameState> AddPlayerToGame(Guid player); Task<GameState> GetState(); Task<List<GameMove>> GetMoves(); Task<GameState> MakeMove(GameMove move); Task<GameSummary> GetSummary(Guid player); Task SetName(string name); } Once a user grain creates a game, that user is automatically added as one of the players. Once a game is joined by a second player, the game can start. The players make their turns until the game ends with either a draw or a winner. The GameGrain maintains the state of the game, the players in the game, whose turn it is next, and whether the game is in play or finished. The MakeMove method handles the game logic, checking the validity of a move and, once played, checks if that move ends the game. In the case of the game ending, the player grains are informed of the outcome via the LeaveGame call. The game was designed with social gaming in mind, so the main mechanism for inviting other players is an \"out of band\" from the game, and would probably be an invite to a friend, sending the GUID that represents the game. As an optimization purely for testing, a pairing grain was created that uses MemoryCache to hold a the list of games that are available to join, with an expiry of one hour, to stop \"stale\" games appearing on the list. An ASP.NET MVC application serves an HTML page. JavaScript running in the browser polls the web server, and retrieve JSON data, which it renders using Handlebars templates ."
  },
  "1.5/Documentation/Samples-Overview/Azure-Web-Sample.html": {
    "href": "1.5/Documentation/Samples-Overview/Azure-Web-Sample.html",
    "title": "Azure Web Sample | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Azure Web Sample Important note : Worker and web role instances are not automatically removed or disabled, even when they go unused for a long time. To avoid a nasty surprise when your Azure bill comes, make sure to delete the instances after you have finished testing the application! This sample is essentially the same as the Hello World sample, except that it hosts the grains in an Azure Worker Role instead of in the client process itself. While the communication interface and grain implementation are identical, three projects replace the client: OrleansAzureSample , which is the Azure configuration project. OrleansAzureSilos , the Worker Role integration logic that hosts the Orleans silo in the cloud. WebRole , which provides a simple HTML UI for the Orleans backend. Run AzureWebSample Locally The sample is configured to run inside of the Azure Compute Emulator on your desktop by default, so make sure that OrleansAzureSample is set as the Startup Project in this solution and just press F5 to build and run the sample locally. You do not need to start Visual Studio with administrative privileges to run this sample in the emulator - it is designed to use both IIS Express and Express Emulator , so make sure these options are selected in OrleansAzureSample->Properties->Web. You may also need to select the \"Use IIS Express for web sites and projects\" in Tools->Options->Projects and Solutions->Web Projects. Run AzureWebSample in Azure Cloud To get the sample running in the Azure cloud, open the ServiceConfiguration.Cloud.cscfg file in the OrleansAzureSample project. Edit the connection strings, replacing MYACCOUNTNAME and MYACCOUNTKEY with data you get from the Azure portal, logged in to your account. It may be useful to set up a new storage account within your subscription just for samples testing. All four connection strings will look exactly the same. In the file ServiceDefinition.csdef , the configuration sets up all instances as ExtraSmall to avoid any unpleasant surprises. If you want something else, modify the settings as you see fit. Then, build the solution with Visual Studio and right-click on the OrleansAzureSample project, selecting 'Publish.' Visual Studio will take you through the process of publishing your project to Azure, which will take a few minutes. If things work out, you should see something like this: ![](AzureSample 3.png) This means that the site and its backend are ready. Start a web browser and navigate to the link that VS displayed (or just click on it). You will be greeted by this screen: ![](AzureSample 1.png) Click on \"Ask Orleans it's details\" and wait for the response. The first time you interact with the site, it may take a few seconds, since the whole system need to warm up. After that first message, it should go quickly. ![](AzureSample 2.png)"
  },
  "1.5/Documentation/Core-Features/Dependency-Injection.html": {
    "href": "1.5/Documentation/Core-Features/Dependency-Injection.html",
    "title": "Dependency Injection | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . What is Dependency Injection Dependency injection (DI) is a software design pattern that implements inversion of control for resolving dependencies. Orleans is using the abstraction written by the developers of ASP.NET Core . For a detailed explanation about how it works, check out the official documentation . DI in Orleans Dependency Injection is currently supported only on the server side within Orleans. Orleans makes it possible to inject dependencies into application Grains . However Orleans supports every container dependent injection mechanisms, one of the most commonly used method is constructor injection. Theoretically any type can be injected which was previously registered in a IServiceCollection during Silo startup. Note *: As Orleans is evolving, as of the current plans it will be possible to leverage dependency injection in other application classes as well, like StreamProviders . Configuring DI The DI configuration is a global configuration value and must be configured there. Orleans is using a similar approach as ASP.NET Core to configure DI. You must have a Startup class within your application which must contain a ConfigureServices method. It must return an object instance of type: IServiceProvider . Configuration is done by specifying the type of your Startup class via one of the methods described below. Note : Previously DI configuration was specified at the cluster node level, this was changed in the recent release. Configuring from Code It is possible to tell Orleans what Startup type you like to use with code based configuration. There is an extension method named UseStartup on the ClusterConfiguration class which you can use to do that. var configuration = new ClusterConfiguration(); configuration.UseStartupType<MyApplication.Configuration.MyStartup>(); Configuring via XML To register your Startup class with Orleans you add a Startup element to the Defaults section and in the Type attribute you specify the assembly-qualified name for the type. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <tns:OrleansConfiguration xmlns:tns=\"urn:orleans\"> <tns:Defaults> <tns:Startup Type=\"MyApplication.Configuration.Startup,MyApplication\" /> </tns:Defaults> </tns:OrleansConfiguration> Example Here is a complete Startup class example: namespace MyApplication.Configuration { public class MyStartup { public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddSingleton<IInjectedService, InjectedService>(); return services.BuildServiceProvider(); } } } This example shows how a Grain can utilize IInjectedService via constructor injection and also the complete declaration and implementation of the injected service: public interface ISimpleDIGrain : IGrainWithIntegerKey { Task<long> GetTicksFromService(); } public class SimpleDIGrain : Grain, ISimpleDIGrain { private readonly IInjectedService injectedService; public SimpleDIGrain(IInjectedService injectedService) { this.injectedService = injectedService; } public Task<long> GetTicksFromService() { return injectedService.GetTicks(); } } public interface IInjectedService { Task<long> GetTicks(); } public class InjectedService : IInjectedService { public Task<long> GetTicks() { return Task.FromResult(DateTime.UtcNow.Ticks); } } Test Framework Integration DI truly shines when coupled with a testing framework to verify the correctness of the code that build. You can read about the components for testing in Orleans by following our tutorials . You will need to do two things to set up DI with tests. First you will need to implement mocks of your services. This is done in our example using Moq , a popular mocking framework for .NET. Here is an example of mocking a service. public class MockServices { public IServiceProvider ConfigureServices(IServiceCollection services) { var mockInjectedService = new Mock<IInjectedService>(); mockInjectedService.Setup(t => t.GetTicks()).Returns(knownDateTime); services.AddSingleton<IInjectedService>(mockInjectedService.Object); return services.BuildServiceProvider(); } } To include these services in your test silo, you will need to specify MockServices as the silo startup class. Here is an example of doing this. [TestClass] public class IInjectedServiceTests: TestingSiloHost { private static TestingSiloHost host; [TestInitialize] public void Setup() { if (host == null) { host = new TestingSiloHost( new TestingSiloOptions { StartSecondary = false, AdjustConfig = clusterConfig => { clusterConfig.UseStartupType<MockServices>(); } }); } } }"
  },
  "1.5/Documentation/Core-Features/Grain-Persistence.html": {
    "href": "1.5/Documentation/Core-Features/Grain-Persistence.html",
    "title": "Grain Persistence | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain Persistence Goals Allow different grain types to use different types of storage providers (e.g., one uses Azure table, and one uses an ADO.NET one) or the same type of storage provider but with different configurations (e.g., both use Azure table, but one uses storage account #1 and one uses storage account #2) Allow configuration of a storage provider instance to be swapped (e.g., Dev-Test-Prod) with just config file changes, and no code changes required. Provide a framework to allow additional storage providers to be written later, either by the Orleans team or others. Provide a minimal set of production-grade storage providers Storage providers have complete control over how they store grain state data in persistent backing store. Corollary: Orleans is not providing a comprehensive ORM storage solution, but allows custom storage providers to support specific ORM requirements as and when required. Grain Persistence API Grain types can be declared in one of two ways: Extend Grain if they do not have any persistent state, or if they will handle all persistent state themselves, or Extend Grain<T> if they have some persistent state that they want the Orleans runtime to handle. Stated another way, by extending Grain<T> a grain type is automatically opted-in to the Orleans system managed persistence framework. For the remainder of this section, we will only be considering Option #2 / Grain<T> because Option #1 grains will continue to run as now without any behavior changes. Grain State Stores Grain classes that inherit from Grain<T> (where T is an application-specific state data type that needs to be persisted) will have their state loaded automatically from a specified storage. Grains will be marked with a [StorageProvider] attribute that specifies a named instance of a storage provider to use for reading / writing the state data for this grain. [StorageProvider(ProviderName=\"store1\")] public class MyGrain<MyGrainState> ... { ... } The Orleans Provider Manager framework provides a mechanism to specify & register different storage providers and storage options in the silo config file. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"DevStore\" /> <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"store1\" DataConnectionString=\"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\" /> <Provider Type=\"Orleans.Storage.AzureBlobStorage\" Name=\"store2\" DataConnectionString=\"DefaultEndpointsProtocol=https;AccountName=data2;AccountKey=SOMETHING2\" /> </StorageProviders> Configuring Storage Providers AzureTableStorage <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"TableStore\" DataConnectionString=\"UseDevelopmentStorage=true\" /> The following attributes can be added to the <Provider /> element to configure the provider: DataConnectionString=\"...\" (mandatory) - The Azure storage connection string to use TableName=\"OrleansGrainState\" (optional) - The table name to use in table storage, defaults to OrleansGrainState DeleteStateOnClear=\"false\" (optional) - If true, the record will be deleted when grain state is cleared, otherwise an null record will be written, defaults to false UseJsonFormat=\"false\" (optional) - If true, the json serializer will be used, otherwise the Orleans binary serializer will be used, defaults to false UseFullAssemblyNames=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Indents the serialized json, defaults to false Note: state should not exceed 64KB, a limit imposed by Table Storage. AzureBlobStorage <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"BlobStore\" DataConnectionString=\"UseDevelopmentStorage=true\" /> The following attributes can be added to the <Provider /> element to configure the provider: DataConnectionString=\"...\" (mandatory) - The Azure storage connection string to use ContainerName=\"grainstate\" (optional) - The blob storage container to use, defaults to grainstate UseFullAssemblyNames=\"false\" (optional) - Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - Indents the serialized json, defaults to false DynamoDBStorageProvider <Provider Type=\"Orleans.Storage.DynamoDBStorageProvider\" Name=\"DDBStore\" DataConnectionString=\"Service=us-wes-1;AccessKey=MY_ACCESS_KEY;SecretKey=MY_SECRET_KEY;\" /> DataConnectionString=\"...\" (mandatory) - The DynamoDB storage connection string to use. You can set Service , AccessKey , SecretKey , ReadCapacityUnits and WriteCapacityUnits in it. TableName=\"OrleansGrainState\" (optional) - The table name to use in table storage, defaults to OrleansGrainState DeleteStateOnClear=\"false\" (optional) - If true, the record will be deleted when grain state is cleared, otherwise an null record will be written, defaults to false UseJsonFormat=\"false\" (optional) - If true, the json serializer will be used, otherwise the Orleans binary serializer will be used, defaults to false UseFullAssemblyNames=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Indents the serialized json, defaults to false ADO.NET Storage Provider (SQL Storage Provider) The ADO .NET Storage Provider allows you to store grain state in relational databases. Currently following databases are supported: SQL Server MySQL/MariaDB PostgreSQL Oracle First, install the base package: Install-Package Microsoft.Orleans.OrleansSqlUtils Under the folder where the package gets installed alongside your project, you will find different SQL scripts for the supported database vendors. You can also get them from the OrleansSQLUtils repository . Create a database, and then run the appropriate script to create the tables. The next steps are to install a second NuGet package (see table below) specific to the database vendor you want, and to configure the storage provider either programmatically or via XML configuration. Database Script NuGet Package AdoInvariant Remarks SQL Server CreateOrleansTables_SQLServer.sql System.Data.SqlClient System.Data.SqlClient MySQL / MariaDB CreateOrleansTables_MySQL.sql MySql.Data MySql.Data.MySqlClient PostgreSQL CreateOrleansTables_PostgreSQL.sql Npgsql Npgsql Oracle CreateOrleansTables_Oracle.sql ODP.net Oracle.DataAccess.Client No .net Core support The following is an example of how to configure an ADO .NET Storage Provider using XML configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.AdoNetStorageProvider\" Name=\"OrleansStorage\" AdoInvariant=\"<AdoInvariant>\" DataConnectionString=\"<ConnectionString>\" UseJsonFormat=\"true\" /> </StorageProviders> </Globals> </OrleansConfiguration> In code, you would need something like the following: var properties = new Dictionary<string, string>() { [\"AdoInvariant\"] = \"<AdoInvariant>\", [\"DataConnectionString\"] = \"<ConnectionString>\", [\"UseJsonFormat\"] = \"true\" }; config.Globals.RegisterStorageProvider<AdoNetStorageProvider>(\"OrleansStorage\", properties); Essentially, you only need to set the database-vendor-specific connection string and an AdoInvariant (see table above) that identifies the vendor. You may also choose the format in which the data is saved, which may be either binary (default), JSON, or XML. While binary is the most compact option, it is opaque and you will not be able to read or work with the data. JSON is the recommended option. You can set the following properties: Name Type Description Name String Arbitrary name that persistent grains will use to refer to this storage provider Type String Set to Orleans.Storage.AdoNetStorageProvider AdoInvariant String Identifies the database vendor (see above table for values; default is System.Data.SqlClient ) DataConnectionString String Vendor-specific database connection string (required) UseJsonFormat Boolean Use JSON format (recommended) UseXmlFormat Boolean Use XML format UseBinaryFormat Boolean Use compact binary format (default) The StorageProviders sample provides some code you can use to quickly test the above, and also showcases some custom storage providers. Use the following command in the Package Manager Console to update all Orleans packages to the latest version: Get-Package | where Id -like 'Microsoft.Orleans.*' | foreach { update-package $_.Id } The ADO.NET persistence has functionality to version data and define arbitrary (de)serializers with arbitrary application rules and streaming, but currently there is no method to expose them to application code. More information in ADO.NET Persistence Rationale . MemoryStorage MemoryStorage is a simple storage provider that does not really use a persistent data store underneath. It is convenient to learn to work with Storage Providers quickly, but is not intended to be used in real scenarios. Note: This provider persists state to volatile memory which is erased at silo shut down. Use only for testing. To set up the memory storage provider using XML configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"OrleansStorage\" NumStorageGrains=\"10\" /> </StorageProviders> </Globals> </OrleansConfiguration> To set it up in code: siloHost.Config.Globals.RegisterStorageProvider<MemoryStorage>(\"OrleansStorage\"); You can set the following properties: Name Type Description Name String Arbitrary name that persistent grains will use to refer to this storage provider Type String Set to Orleans.Storage.MemoryStorage NumStorageGrains Integer The number of grains to use to store the state, defaults to 10 ShardedStorageProvider <Provider Type=\"Orleans.Storage.ShardedStorageProvider\" Name=\"ShardedStorage\"> <Provider /> <Provider /> <Provider /> </Provider> Simple storage provider for writing grain state data shared across a number of other storage providers. A consistent hash function (default is Jenkins Hash) is used to decide which shard (in the order they are defined in the config file) is responsible for storing state data for a specified grain, then the Read / Write / Clear request is bridged over to the appropriate underlying provider for execution. Notes on Storage Providers If there is no [StorageProvider] attribute specified for a Grain<T> grain class, then a provider named Default will be searched for instead. If not found then this is treated as a missing storage provider. If there is only one provider in the silo config file, it will be considered to be the Default provider for this silo. A grain that uses a storage provider which is not present and defined in the silo configuration when the silo loads will fail to load, but the rest of the grains in that silo can still load and run. Any later calls to that grain type will fail with an Orleans.Storage.BadProviderConfigException error specifying that the grain type is not loaded. The storage provider instance to use for a given grain type is determined by the combination of the storage provider name defined in the [StorageProvider] attribute on that grain type, plus the provider type and configuration options for that provider defined in the silo config. Different grain types can use different configured storage providers, even if both are the same type: for example, two different Azure table storage provider instances, connected to different Azure storage accounts (see config file example above). All configuration details for storage providers is defined statically in the silo configuration that is read at silo startup. There are no mechanisms provided at this time to dynamically update or change the list of storage providers used by a silo. However, this is a prioritization / workload constraint rather than a fundamental design constraint. State Storage APIs There are two main parts to the grain state / persistence APIs: Grain-to-Runtime and Runtime-to-Storage-Provider. Grain State Storage API The grain state storage functionality in the Orleans Runtime will provide read and write operations to automatically populate / save the GrainState data object for that grain. Under the covers, these functions will be connected (within the code generated by Orleans client-gen tool) through to the appropriate persistence provider configured for that grain. Grain State Read / Write Functions Grain state will automatically be read when the grain is activated, but grains are responsible for explicitly triggering the write for any changed grain state as and when necessary. See the Failure Modes section below for details of error handling mechanisms. GrainState will be read automatically (using the equivalent of base.ReadStateAsync() ) before the OnActivateAsync() method is called for that activation. GrainState will not be refreshed before any method calls to that grain, unless the grain was activated for this call. During any grain method call, a grain can request the Orleans runtime to write the current grain state data for that activation to the designated storage provider by calling base.WriteStateAsync() . The grain is responsible for explicitly performing write operations when they make significant updates to their state data. Most commonly, the grain method will return the base.WriteStateAsync() Task as the final result Task returned from that grain method, but it is not required to follow this pattern. The runtime will not automatically update stored grain state after any grain methods. During any grain method or timer callback handler in the grain, the grain can request the Orleans runtime to re-read the current grain state data for that activation from the designated storage provider by calling base.ReadStateAsync() . This will completely overwrite any current state data currently stored in the grain state object with the latest values read from persistent store. An opaque provider-specific Etag value ( string ) may be set by a storage provider as part of the grain state metadata populated when state was read. Some providers may choose to leave this as null if they do not use Etag s. Conceptually, the Orleans Runtime will take a deep copy of the grain state data object for its own use during any write operations. Under the covers, the runtime may use optimization rules and heuristics to avoid performing some or all of the deep copy in some circumstances, provided that the expected logical isolation semantics are preserved. Sample Code for Grain State Read / Write Operations Grains must extend the Grain<T> class in order to participate in the Orleans grain state persistence mechanisms. The T in the above definition will be replaced by an application-specific grain state class for this grain; see the example below. The grain class should also be annotated with a [StorageProvider] attribute that tells the runtime which storage provider (instance) to use with grains of this type. public class MyGrainState { public int Field1 { get; set; } public string Field2 { get; set; } } [StorageProvider(ProviderName=\"store1\")] public class MyPersistenceGrain : Grain<MyGrainState>, IMyPersistenceGrain { ... } Grain State Read The initial read of the grain state will occur automatically by the Orleans runtime before the grain’s OnActivateAsync() method is called; no application code is required to make this happen. From that point forward, the grain’s state will be available through the Grain<T>.State property inside the grain class. Grain State Write After making any appropriate changes to the grain’s in-memory state, the grain should call the base.WriteStateAsync() method to write the changes to the persistent store via the defined storage provider for this grain type. This method is asynchronous and returns a Task that will typically be returned by the grain method as its own completion Task. public Task DoWrite(int val) { State.Field1 = val; return base.WriteStateAsync(); } Grain State Refresh If a grain wishes to explicitly re-read the latest state for this grain from backing store, the grain should call the base.ReadStateAsync() method. This will reload the grain state from persistent store, via the defined storage provider for this grain type, and any previous in-memory copy of the grain state will be overwritten and replaced when the ReadStateAsync() Task completes. public async Task<int> DoRead() { await base.ReadStateAsync(); return State.Field1; } Failure Modes for Grain State Persistence Operations Failure Modes for Grain State Read Operations Failures returned by the storage provider during the initial read of state data for that particular grain will result in the activate operation for that grain to be failed; in this case, there will not be any call to that grain’s OnActivateAsync() life cycle callback method. The original request to that grain which caused the activation will be faulted back to the caller the same way as any other failure during grain activation. Failures encountered by the storage provider to read state data for a particular grain will result in the ReadStateAsync() Task to be faulted. The grain can choose to handle or ignore that faulted Task , just like any other Task in Orleans. Any attempt to send a message to a grain which failed to load at silo startup time due to a missing / bad storage provider config will return the permanent error Orleans.BadProviderConfigException . Failure Modes for Grain State Write Operations Failures encountered by the storage provider to write state data for a particular grain will result in the WriteStateAsync() Task to be faulted. Usually, this will mean the grain call will be faulted back to the client caller provided the WriteStateAsync() Task is correctly chained in to the final return Task for this grain method. However, it will be possible for certain advanced scenarios to write grain code to specifically handle such write errors, just like they can handle any other faulted Task . Grains that execute error-handling / recovery code must catch exceptions / faulted WriteStateAsync() Task s and not re-throw to signify that they have successfully handled the write error. Storage Provider Framework There is a service provider API for writing additional persistence providers – IStorageProvider . The Persistence Provider API covers read and write operations for GrainState data. public interface IStorageProvider { Logger Log { get; } Task Init(); Task Close(); Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); } Storage Provider Semantics Any attempt to perform a write operation when the storage provider detects an Etag constraint violation should cause the write Task to be faulted with transient error Orleans.InconsistentStateException and wrapping the underlying storage exception. public class InconsistentStateException : AggregateException { /// <summary>The Etag value currently held in persistent storage.</summary> public string StoredEtag { get; private set; } /// <summary>The Etag value currently held in memory, and attempting to be updated.</summary> public string CurrentEtag { get; private set; } public InconsistentStateException( string errorMsg, string storedEtag, string currentEtag, Exception storageException ) : base(errorMsg, storageException) { this.StoredEtag = storedEtag; this.CurrentEtag = currentEtag; } public InconsistentStateException(string storedEtag, string currentEtag, Exception storageException) : this(storageException.Message, storedEtag, currentEtag, storageException) { } } Any other failure conditions from a write operation should cause the write Task to be broken with an exception containing the underlying storage exception. Data Mapping Individual storage providers should decide how best to store grain state – blob (various formats / serialized forms) or column-per-field are obvious choices. The basic storage provider for Azure Table encodes state data fields into a single table column using Orleans binary serialization. ADO.NET Persistence Rationale The principles for ADO.NET backed persistence storage are: Keep business critical data safe an accessible while data, the format of data and code evolve. Take advantenge of vendor and storage specific functionality. In practice this means adhering to ADO.NET implementation goals and some added implementation logic in ADO.NET specific storage provider that allow evolving the shape of the data in the storage. In addition to the usual storage provider capabilities, the ADO.NET provider has built-in capability to Change storage data format from one format to another format (e.g. from JSON to binary) when roundtripping state. Shape the type to be saved or read from the storage in arbitrary ways. This helps to evolve the version state. Stream data out of the database. Both 1. and 2. can be applied on arbitrary decision parameters, such as grain ID , grain type , payload data . This happen so that one chooses a format, e.g. Simple Binary Encoding (SBE) and implements IStorageDeserializer and IStorageSerializer . The built-in (de)serializers have been built using this method. The OrleansStorageDefault (De)Serializer can be used as examples on how to implement other formats. When the (de)serializers have been implemented, they need to ba added to the StorageSerializationPicker property in AdoNetStorageProvider . This is an implementation of IStorageSerializationPicker . By default StorageSerializationPicker will be used. And example of changing data storage format or using (de)serializers can be seen at RelationalStorageTests . Currently there is no method to expose this to Orleans application consumption as there is no method to access the framework created AdoNetStorageProvider instance."
  },
  "1.5/Documentation/Core-Features/Timers-and-Reminders.html": {
    "href": "1.5/Documentation/Core-Features/Timers-and-Reminders.html",
    "title": "Timers and Reminders | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Timers and Reminders The Orleans runtime provides two mechanisms, called timers and reminders, that enable the developer to specify periodic behavior for grains. Timers Description Timers are used to create periodic grain behavior that isn't required to span multiple activations (instantiations of the grain). It is essentially identical to the standard . NET System.Threading.Timer class. In addition, it is subject to single threaded execution guarantees within the grain activation that it operates. Each activation may have zero or more timers associated with it. The runtime executes each timer routine within the runtime context of the activation that it is associated with. Usage To start a timer, use the Grain.RegisterTimer method, which returns an IDisposable reference: protected IDisposable RegisterTimer(Func<object, Task> asyncCallback, object state, TimeSpan dueTime, TimeSpan period) asyncCallback is the function to be invoked when the timer ticks. state is an object that will be passed to asyncCallback when the timer ticks. dueTime specifies a quantity of time to wait before issuing the first timer tick. period specifies the period of the timer. Cancel the timer by disposing it. A timer will cease to trigger if the activation is deactivated or when a fault occurs and its silo crashes. Important Considerations When activation collection is enabled, the execution of a timer callback does not change the activation's state from idle to in use. This means that a timer cannot be used to postpone deactivation of otherwise idle activations. The period passed to Grain.RegisterTimer is the amount of time that passes from the moment the Task returned by asyncCallback is resolved to the moment that the next invocation of asyncCallback should occur. This not only makes it impossible for successive calls to asyncCallback to overlap but also makes it so that the length of time asyncCallback takes to complete affects the frequency at which asyncCallback is invoked. This is an important deviation from the semantics of System.Threading.Timer . Each invocation of asyncCallback is delivered to an activation on a separate turn and will never run concurrently with other turns on the same activation. Note however, asyncCallback invocations are not delivered as messages and are thus not subject to message interleaving semantics. This means that invocations of asyncCallback should be considered to behave as if running on a reentrant grain with respect to other messages to that grain. Reminders Description Reminders are similar to timers with a few important differences: Reminders are persistent and will continue to trigger in all situations (including partial or full cluster restarts) unless explicitly cancelled. Reminders are associated with a grain, not any specific activation. If a grain has no activation associated with it and a reminder ticks, one will be created. e.g.: If an activation becomes idle and is deactivated, a reminder associated with the same grain will reactivate the grain when it ticks next. Reminders are delivered by message and are subject to the same interleaving semantics as all other grain methods. Reminders should not be used for high-frequency timers-- their period should be measured in minutes, hours, or days. Configuration Reminders, being persistent, rely upon storage to function. You must specify which storage backing to use before the reminder subsystem will function. The reminder functionality is controlled by the SystemStore element in the server-side configuration. It works with either Azure Table or SQL Server as the store. <SystemStore SystemStoreType=\"AzureTable\" /> OR <SystemStore SystemStoreType=\"SqlServer\" /> If you just want a placeholder implementation of reminders to work with without needing to set up an Azure account or SQL database, then adding this element to the configuration file (under 'Globals') will give you a development-only implementation of the reminder system: <ReminderService ReminderServiceType=\"ReminderTableGrain\"/> Usage A grain that uses reminders must implement the IRemindable.RecieveReminder method. Task IRemindable.ReceiveReminder(string reminderName, TickStatus status) { Console.WriteLine(\"Thanks for reminding me-- I almost forgot!\"); return TaskDone.Done; } To start a reminder, use the Grain.RegisterOrUpdateReminder method, which returns an IOrleansReminder object: protected Task<IOrleansReminder> RegisterOrUpdateReminder(string reminderName, TimeSpan dueTime, TimeSpan period) reminderName is a string that must uniquely identify the reminder within the scope of the contextual grain. dueTime specifies a quantity of time to wait before issuing the first timer tick. period specifies the period of the timer. Since reminders survive the lifetime of any single activation, they must be explicitly cancelled (as opposed to being disposed). You cancel a reminder by calling Grain.UnregisterReminder : protected Task UnregisterReminder(IOrleansReminder reminder) reminder is the handle object returned by Grain.RegisterOrUpdateReminder . Instances of IOrleansReminder aren't guaranteed to be valid beyond the lifespan of an activation. If you wish to identify a reminder in a way that persists, use a string containing the reminder's name. If you only have the reminder's name and need the corresponding instance of IOrleansReminder , call the Grain.GetReminder method: protected Task<IOrleansReminder> GetReminder(string reminderName) Which Should I Use? We recommend that you use timers in the following circumstances: It doesn't matter (or is desirable) that the timer ceases to function if the activation is deactivated or failures occur. If the resolution of the timer is small (e.g. reasonably expressible in seconds or minutes). The timer callback can be started from Grain.OnActivateAsync or when a grain method is invoked. We recommend that you use reminders in the following circumstances: When the periodic behavior needs to survive the activation and any failures. To perform infrequent tasks (e.g. reasonably expressible in minutes, hours, or days). Combining Timers and Reminders You might consider using a combination of reminders and timers to accomplish your goal. For example, if you need a timer with a small resolution that needs to survive across activations, you can use a reminder that runs every five minutes, whose purpose is to wake up a grain that restarts a local timer that may have been lost due to a deactivation."
  },
  "1.5/Documentation/Core-Features/Observers.html": {
    "href": "1.5/Documentation/Core-Features/Observers.html",
    "title": "Client Observers | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . There are situations in which a simple message/response pattern is not enough, and the client needs to receive asynchronous notifications. For example, a user might want to be notified when a new instant message has been published by a friend. Client observers is a mechanism that allows notifying clients asynchronously. An observer is a one-way asynchronous interface that inherits from IGrainObserver , and all its methods must be void. The grain sends a notification to the observer by invoking it like a grain interface method, except that it has no return value, and so the grain need not depend on the result. The Orleans runtime will ensure one-way delivery of the notifications. A grain that publishes such notifications should provide an API to add or remove observers. In addition, it is usually convenient to expose a method that allows an existing subscription to be cancelled. Grain developers may use the Orleans ObserverSubscriptionManager<T> generic class to simplify development of observed grain types. To subscribe to a notification, the client must first create a local C# object that implements the observer interface. It then calls a static method on the observer factory, CreateObjectReference() , to turn the C# object into a grain reference, which can then be passed to the subscription method on the notifying grain. This model can also be used by other grains to receive asynchronous notifications. Unlike in the client subscription case, the subscribing grain simply implements the observer interface as a facet, and passes in a reference to itself (e.g. this.AsReference<IMyGrainObserverInterface> ). Code Example Let's assume that we have a grain that periodicaly sends messages to clients. For simplicity, the message in our example will be a string. We first define the interface on the client that will receive the message. the interface will look like this public interface IChat : IGrainObserver { void ReceiveMessage(string message); } The only special thing is that the interface should inherit from IGrainObserver . Now any client that wants to observe those messages should implement a class which implements IChat . The simplest case would be something like this: public class Chat : IChat { public void ReceiveMessage(string message) { Console.WriteLine(message); } } Now on the server we should have a Grain which sends these chat messages to clients. The Grain also should have a mechanism for clients to subscribe and unsubscribe themselves to receive notifications. For subscription the Grain can use the utility class ObserverSubscriptionManager : class HelloGrain : Grain, IHello { private ObserverSubscriptionManager<IChat> _subsManager; public override async Task OnActivateAsync() { // We created the utility at activation time. _subsManager = new ObserverSubscriptionManager<IChat>(); await base.OnActivateAsync(); } // Clients call this to subscribe. public Task Subscribe(IChat observer) { _subsManager.Subscribe(observer); return TaskDone.Done; } //Also clients use this to unsubscribe themselves to no longer receive the messages. public Task UnSubscribe(IChat observer) { _subsManager.Unsubscribe(observer); return TaskDone.Done; } } To send the message to clients the Notify method of the ObserverSubscriptionManager<IChat> instance can be used. The method takes an Action<T> method or lambda expression (where T is of type IChat here). You can call any method on the interface to send it to clients. In our case we only have one method ReceiveMessage and our sending code on the server would look like this: public Task SendUpdateMessage(string message) { _subsManager.Notify(s => s.ReceiveMessage(message)); return TaskDone.Done; } Now our server has a method to send messages to observer clients, two methods for subscribing/unsubscribing and the client implemented a class to be able to observe the grain messages. The last step is to create an observer reference on the client using our previously implemented Chat class and let it receive the messages after subscribing it. The code would look like this: //First create the grain reference var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Chat c = new Chat(); //Create a reference for chat usable for subscribing to the observable grain. var obj = await GrainClient.GrainFactory.CreateObjectReference<IChat>(c); //Subscribe the instance to receive messages. await friend.Subscribe(obj); Now whenever our grain on the server calls the SendUpdateMessage method, all subscribed clients will receive the message. In our client code, the Chat instance in variable c will receive the message and output it to the console. Note: Objects passed to CreateObjectReference are held via a WeakReference<T> and will therefore be garbage collected if no other references exist. Users should maintain a reference for each observer which they do not want to be collected. Note: Observers are inherently unreliable since you don't get any response back to know if the message is received and processed or simply failed due to any condition which might arise in a distributed system. Because of that your observers should poll the grain periodically or use any other mechanism to ensure that they received all messages which they should have received. In some situations you can afford to lose some messages and you don't need any additional mechanism but if you need to make sure that all observers are always receiving the messages and are receiving all of them, both periodic resubscriptions and polling the observer grain, can help to ensure eventual processing of all messages."
  },
  "1.5/Documentation/Event-Sourcing/MultiInstance.html": {
    "href": "1.5/Documentation/Event-Sourcing/MultiInstance.html",
    "title": "Replicated Grains | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Replicated Grains Sometimes, there can be multiple instances of the same grain active, such as when operating a multi-cluster, and using the [OneInstancePerCluster] attribute. The JournaledGrain is designed to support replicated instances with minimal friction. It relies on log-consistency providers to run the necessary protocols to ensure all instances agree on the same sequence of events. In particular, it takes care of the following aspects: Consistent Versions : All versions of the grain state (except for tentative versions) are based on the same global sequence of events. In particular, if two instances see the same version number, then they see the same state. Racing Events : Multiple instances can simultaneously raise an event. The consistency provider resolves this race and ensures everyone agrees on the same sequence. Notifications/Reactivity : After an event is raised at one grain instance, the consistency provider not only updates storage, but also notifies all the other grain instances. For a general discussion of the consistency model see our TechReport and the GSP paper (Global Sequence Protocol). Conditional Events Racing events can be problematic if they have a conflict, i.e. should not both commit for some reason. For example, when withdrawing money from a bank account, two instances may independently determine that there are sufficient funds for a withdrawal, and issue a withdrawal event. But the combination of both events could overdraw. To avoid this, the JournaledGrain API supports a RaiseConditionalEvent method. bool success = await RaiseConditionalEvent(new WithdrawalEvent() { ... }); Conditional events double-check if the local version matches the version in storage. If not, it means the event sequence has grown in the meantime, which means this event has lost a race against some other event. In that case, the conditional event is not appended to the log, and RaiseConditionalEvent returns false. This is the analogue of using e-tags with conditional storage updates, and likewise provides a simple mechanism to avoid committing conflicting events. It is possible and sensible to use both conditional and unconditional events for the same grain, such as a DepositEvent and a WithdrawalEvent . Deposits need not be conditional: even if a DepositEvent loses a race, it does not have to be cancelled, but can still be appended to the global event sequence. Awaiting the task returned by RaiseConditionalEvent is sufficient to confirm the event, i.e. it is not necessary to also call ConfirmEvents . Explicit Synchronization Sometimes, it is desirable to ensure that a grain is fully caught up with the latest version. This can be enforced by calling await RefreshNow(); which both (1) confirms all unconfirmed events, and (2) loads the latest version from storage."
  },
  "1.5/Documentation/Event-Sourcing/Subscribe.html": {
    "href": "1.5/Documentation/Event-Sourcing/Subscribe.html",
    "title": "Notifications | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Notifications It is often convenient to have the ability to react to state changes. All callbacks are subject to Orleans' turn-based guarantees; see also the section on Concurrency Guarantees . Tracking Confirmed State To be notified of any changes to the confirmed state, JournaledGrain subclasses can override this method: protected override void OnStateChanged() { // read state and/or event log and take appropriate action } OnStateChanged is called whenever the confirmed state is updated, i.e. the version number increases. This can happen when A newer version of the state was loaded from storage. An event that was raised by this instance has been successfully written to storage. A notification message was received from some other instance. Note that since all grains initially have version zero, until the initial load from storage completes, this means that OnStateChanged is called whenever the initial load completes with a version larger than zero. Tracking Tentative State To be notified of any changes to the tentative state, JournaledGrain subclasses can override this method: protected override void OnTentativeStateChanged() { // read state and/or events and take appropriate action } OnTentativeStateChanged is called whenever the tentative state changes, i.e. if the combined sequence (ConfirmedEvents + UnconfirmedEvents) changes. In particular, a callback to OnTentativeStateChanged() always happens during RaiseEvent ."
  },
  "1.5/Documentation/Event-Sourcing/MultiVersion.html": {
    "href": "1.5/Documentation/Event-Sourcing/MultiVersion.html",
    "title": "Immediate vs. Delayed Confirmation | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Immediate Confirmation For many applications, we want to ensure that events are confirmed immediately, so that the persisted version does not lag behind the current version in memory, and we do not risk losing the latest state if the grain should fail. We can guarantee this by following these rules: Confirm all RaiseEvent calls using ConfirmEvents before the grain method returns. Make sure tasks returned by RaiseConditionalEvent complete before the grain method returns. Avoid [Reentrant] or [AlwaysInterleave] attributes, so only one grain call can be processed at a time. If we follow these rules, it means that after an event is raised, no other grain code can execute until the event has been written to storage. Therefore, it is impossible to observe inconsistencies between the version in memory and the version in storage. While this is often exactly what we want, it also has some potential disadvantages. Potential Disadvantages if the connection to a remote cluster or to storage is temporarily interrupted , then the grain becomes unavailable: effectively, the grain cannot execute any code while it is stuck waiting to confirm the events, which can take an indefinite amount of time (the log-consistency protocol keeps retrying until storage connectivity is restored). when handling a lot of of updates to a single grain instance , confirming them one at a time can become very inefficient, i.e. have poor throughput. Delayed Confirmation To improve availability and throughput in the situations mentioned above, grains can choose to do one or both of the following: allow grain methods to raise events without waiting for confirmation. allow reentrancy, so the grain can keep processing new calls even if previous calls get stuck waiting for confirmation. This means it is possible for grain code to execute while some events are still in the process of being confirmed. The JournaledGrain API has some specific provisions to give developers precise control over how to deal with unconfirmed events that are currently \"in flight\". The following property can be examined to find out what events are currently unconfirmed: IEnumerable<EventType> UnconfirmedEvents { get; } Also, since the state returned by the State property does not include the effect of unconfirmed events, there is an alternative property StateType TentativeState { get; } which returns a \"tentative\" state, obtained from \"State\" by applying all the unconfirmed events. The tentative state is essentially a \"best guess\" at what will likely become the next confirmed state, after all unconfirmed events are confirmed. However, there is no guarantee that it actually will, because the grain may fail, or because the events may race against other events and lose, causing them to be canceled (if they are conditional) or appear at a later position in the sequence than anticipated (if they are unconditional). Concurrency Guarantees Note that Orleans turn-based scheduling (cooperative concurrency) guarantees always apply, even when using reentrancy or delayed confirmation. This means that even though several methods may be in progress, only one can be actively executing --- all others are stuck at an await, so there are never any true races caused by parallel threads. In particular, note that: The properties State , TentativeState , Version , and UnconfirmedEvents can change during the execution of a method. But such changes can only happen while stuck at an await. These guarantees assume that the user code stays within the recommended practice with respect to tasks and async/await (in particular, does not use thread pool tasks, or only uses them for code that does not call grain functionality and that are properly awaited)."
  },
  "1.5/Documentation/Presentations/index.html": {
    "href": "1.5/Documentation/Presentations/index.html",
    "title": "Orleans Presentations | Microsoft Orleans 中文文档",
    "keywords": "Orleans Best Practices A collection of tips and trick to help design, build, and run an Orleans-based application. Orleans Presentation from the 28th International Symposium on Distributed Computing (DISC 2014) Orleans Presentation from the 15th International Workshop on High Performance Transaction Systems (HPTS 2013) [Balancing Techniques in Orleans]( http://dotnet.github.io/orleans/Presentations/Balancing Techniques in Orleans.pptx) [Uniform API is 42 - Virtual Meetup #3]( http://dotnet.github.io/orleans/Presentations/(VM03 ) Uniform Api is 42.pptx) [Orleans at FreeBay - Virtual Meetup #4]( http://dotnet.github.io/orleans/Presentations/VM-4 - Using Orleans at FreeBay.pptx) [Orleans Streaming - Virtual Meetup #5 - May 2015]( http://dotnet.github.io/orleans/Presentations/Orleans Streaming - Virtual meetup - 5-22-2015.pptx) [Geo Distributed Orleans - Virtual Meetup #6 - October 2015]( http://dotnet.github.io/orleans/Presentations/VM-6 - Orleans-Geo-Replication.pptx) [Orleankka Functional API for Orleans - Virtual Meetup #7]( http://dotnet.github.io/orleans/Presentations/(VM07 ) Orleankka Functional API for Orleans.pptx) [Orleans Roadmap - Virtual Meetup #8 - January 2016]( http://dotnet.github.io/orleans/Presentations/Orleans Roadmap 1-21-2016.pptx) [Orleans Networking discussion- Virtual Meetup #8.5 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-8.5 - Orleans Networking.pptx) [Orleans on Service Fabric - Virtual Meetup #9 Part 1 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-9 - Part.1 Orleans-on-Service-Fabric.pptx) [Orleans with YAMS - Virtual Meetup #9 Part 2 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-9 - Part.2 Orleans-with-YAMS.pptx) [Walk In Distributed Systems Park With Orleans]( http://dotnet.github.io/orleans/Presentations/(FWDAYSKIEV2016 ) Walk.In.Distributed.Systems.Park.With.Orleans.pptx)"
  },
  "1.5/Documentation/Convert-Orleans-v0.9-csproj-to-Use-v1.0-NuGet.html": {
    "href": "1.5/Documentation/Convert-Orleans-v0.9-csproj-to-Use-v1.0-NuGet.html",
    "title": "Convert Orleans v0.9 csproj to use V1.0 NuGet | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . How To Convert a .csproj File To Use Orleans NuGet Packages This note shows how to manually convert a Visual Studio .csproj file which was created with Orleans v0.9 Visual Studio templates from using assembly references based on the $(OrleansSDK) environment variable to using Orleans NuGet packages. These examples assume you are using the latest v1.0.3 NuGet packages from Feb-2015. For simplicity I will use \"v0.9\" to refer to the \"old\" .csproj and \"v1.0\" to refer to the \"new\" .csproj although strictly speaking \"v1.0 really means \">= v1.0.3\" in practice because there was significant restructuring and changes in the Orleans NuGet packages before that point. Grain Interface Project Orleans Grain Interface project -- Example: HelloWorldInterfaces.csproj You might want to preserve a copy of the old .csproj file before you start, if you do not have a copy already preserved in your source code control system. Steps to to change Orleans Grain Interface project: Do Build->Clean on the project to remove any old binaries. Remove old v0.9 assembly references for any Orleans binaries. <ItemGroup> <Reference Include=\"Orleans\"> <HintPath>$(OrleansSDK)\\Binaries\\OrleansClient\\Orleans.dll</HintPath> <Private>False</Private> </Reference> </ItemGroup> Remove old v0.9 Orleans code-gen metadata and script trigger. <PropertyGroup> <OrleansProjectType>Server</OrleansProjectType> </PropertyGroup> <Import Project=\"$(OrleansSDK)\\Binaries\\OrleansClient\\Orleans.SDK.targets\" /> Make sure to re-save the .csproj to disk at this point, otherwise the next step will fail ! Use Visual Studio Package manager to add the Microsoft.Orleans.Templates.Interfaces package to the grain interfaces project. Do this by right-click on project node in Solution Explorer, select \"Manage NuGet Packages...\" context menu item, then search for Orleans and select the Microsoft.Orleans.Templates.Interfaces package. This will add a packages.config file to the project, and add the normal NuGet link code into the .csproj This will also add the Orleans assembly references into the project, and recreate the code-gen metadata and script links for you. Ensure .csproj file is saved to disk again. Do Build->Rebuild on the project to rebuild with the new packages and binaries. Going forward, you should only need to change the version number in packages.config to use a newer package -- either manually edit the packages.config file or use NuGet Package Manager UI in Visual Studio. Orleans Grain Class project -- Example: HelloWorldGrains.csproj Steps to to change Orleans Grain Class project: Steps 1..4 and 6..8 are the same as for the grain interfaces .csproj above. Build->Clean Remove old v0.9 Orleans assembly references Remove old v0.9 Orleans code-gen metadata Save .csproj file to disk Use Visual Studio Package manager to add the Microsoft.Orleans.Templates.Grains package to the project. Follow Steps 6..8 from the grain interfaces .csproj above. Problems? If you have problems getting these conversions to work for you, then please post a full copy of your .csproj into a Gist on your GitHub account and then open a new Issue in the Orleans GitHub Project asking for assistance and pointing to the Gist for your specific project file."
  },
  "1.5/Documentation/Benefits.html": {
    "href": "1.5/Documentation/Benefits.html",
    "title": "Main Benefits | Microsoft Orleans 中文文档",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Benefits The main benefits of Orleans are: developer productivity , even for non-expert programmers; and transparent scalability by default with no special effort from the programmer. We expand on each of these benefits below. Developer Productivity The Orleans programming model raises productivity of both expert and non-expert programmers by providing the following key abstractions, guarantees and system services. Familiar object-oriented programming (OOP) paradigm . Actors are .NET classes that implement declared .NET actor interfaces with asynchronous methods. Thus actors appear to the programmer as remote objects whose methods can be directly invoked. This provides the programmer the familiar OOP paradigm by turning method calls into messages, routing them to the right endpoints, invoking the target actor’s methods and dealing with failures and corner cases in a completely transparent way. Single-threaded execution of actors . The runtime guarantees that an actor never executes on more than one thread at a time. Combined with the isolation from other actors, the programmer never faces concurrency at the actor level, and hence never needs to use locks or other synchronization mechanisms to control access to shared data. This feature alone makes development of distributed applications tractable for non-expert programmers. Transparent activation . The runtime activates an actor as-needed, only when there is a message for it to process. This cleanly separates the notion of creating a reference to an actor, which is visible to and controlled by application code, and physical activation of the actor in memory, which is transparent to the application. In many ways, this is similar to virtual memory in that it decides when to “page out” (deactivate) or “page in” (activate) an actor; the application has uninterrupted access to the full “memory space” of logically created actors, whether or not they are in the physical memory at any particular point in time. Transparent activation enables dynamic, adaptive load balancing via placement and migration of actors across the pool of hardware resources. This features is a significant improvement on the traditional actor model, in which actor lifetime is application-managed. Location transparency . An actor reference (proxy object) that the programmer uses to invoke the actor’s methods or pass to other components only contains the logical identity of the actor. The translation of the actor’s logical identity to its physical location and the corresponding routing of messages are done transparently by the Orleans runtime. Application code communicates with actors oblivious to their physical location, which may change over time due to failures or resource management, or because an actor is deactivated at the time it is called. Transparent integration with persistent store . Orleans allows for declarative mapping of actors’ in-memory state to persistent store. It synchronizes updates, transparently guaranteeing that callers receive results only after the persistent state has been successfully updated. Extending and/or customizing the set of existing persistent storage providers available is straight-forward. Automatic propagation of errors . The runtime automatically propagates unhandled errors up the call chain with the semantics of asynchronous and distributed try/catch. As a result, errors do not get lost within an application. This allows the programmer to put error handling logic at the appropriate places, without the tedious work of manually propagating errors at each level. Transparent Scalability by Default The Orleans programming model is designed to guide the programmer down a path of likely success in scaling their application or service through several orders of magnitude. This is done by incorporating the proven best practices and patterns, and providing an efficient implementation of the lower level system functionality. Here are some key factors that enable scalability and performance. Implicit fine grain partitioning of application state . By using actors as directly addressable entities, the programmer implicitly breaks down the overall state of their application. While the Orleans programming model does not prescribe how big or small an actor should be, in most cases it makes sense to have a relative large number of actors – millions or more – with each representing a natural entity of the application, such as a user account, a purchase order, etc. With actors being individually addressable and their physical location abstracted away by the runtime, Orleans has enormous flexibility in balancing load and dealing with hot spots in a transparent and generic way without any thought from the application developer. Adaptive resource management . With actors making no assumption about locality of other actors they interact with and because of the location transparency, the runtime can manage and adjust allocation of available HW resources in a very dynamic way by making fine grain decisions on placement/migration of actors across the compute cluster in reaction to load and communication patterns without failing incoming requests. By creating multiple replicas of a particular actor the runtime can increase throughput of the actor if necessary without making any changes to the application code. Multiplexed communication . Actors in Orleans have logical endpoints, and messaging between them is multiplexed across a fixed set of all-to-all physical connections (TCP sockets). This allows the runtime to host a very large number (millions) of addressable entities with low OS overhead per actor. In addition, activation/deactivation of an actor does not incur the cost of registering/unregistering of a physical endpoint, such as a TCP port or a HTTP URL, or even closing a TCP connection. Efficient scheduling . The runtime schedules execution of a large number of single-threaded actors across a custom thread pool with a thread per physical processor core. With actor code written in the non-blocking continuation based style (a requirement of the Orleans programming model) application code runs in a very efficient “cooperative” multi-threaded manner with no contention. This allows the system to reach high throughput and run at very high CPU utilization (up to 90%+) with great stability. The fact that a growth in the number of actors in the system and the load does not lead to additional threads or other OS primitives helps scalability of individual nodes and the whole system. Explicit asynchrony . The Orleans programming model makes the asynchronous nature of a distributed application explicit and guides programmers to write non-blocking asynchronous code. Combined with asynchronous messaging and efficient scheduling, this enables a large degree of distributed parallelism and overall throughput without the explicit use of multi-threading."
  }
}