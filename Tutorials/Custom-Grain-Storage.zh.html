<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Custom Grain Storage | Microsoft Orleans &#20013;&#25991;&#25991;&#26723; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Custom Grain Storage | Microsoft Orleans &#20013;&#25991;&#25991;&#26723; ">
    <meta name="generator" content="docfx 2">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="自定义grains存储">自定义Grains存储</h1>

<h2 id="编写自定义grains存储">编写自定义Grains存储</h2>
<p>在有关声明性参与者存储的教程中，我们研究了允许Grains使用内置存储提供程序之一将其状态存储在Azure表中。尽管Azure是松散数据的好地方，但还有许多替代方法。实际上，有太多的人无法支持所有人。取而代之的是，Orleans旨在让您通过编写Grains存储来轻松添加对您自己的存储形式的支持。</p>
<p>在本教程中，我们将逐步介绍如何编写基于文件的简单Grains存储。文件系统不是存储Grains状态的最佳位置，因为它是本地的，文件锁可能存在问题，并且最后更新日期不足以防止不一致。但这是一个简单的示例，可以帮助我们说明<code>Grains储存</code>。</p>
<h2 id="入门">入门</h2>
<p>OrleansGrains仓库是实现<code>IGrain存储</code>包含在其中<a href="https://www.nuget.org/packages/Microsoft.Orleans.Core/">Microsoft.Orleans.Core NuGet程序包</a>。</p>
<p>我们也从<code>ILifecycleParticipant &lt;ISiloLifecycle&gt;</code>这将使我们能够订阅孤岛生命周期中的特定事件。</p>
<p>我们首先创建一个名为<code>FileGrainStorage</code>。</p>
<pre><code class="lang-csharp">using Orleans;
using System;
using Orleans.Storage;
using Orleans.Runtime;
using System.Threading.Tasks;

namespace GrainStorage
{
    public class FileGrainStorage : IGrainStorage, ILifecycleParticipant&lt;ISiloLifecycle&gt;
    {
        private readonly string _storageName;
        private readonly FileGrainStorageOptions _options;
        private readonly ClusterOptions _clusterOptions;
        private readonly IGrainFactory _grainFactory;
        private readonly ITypeResolver _typeResolver;
        private JsonSerializerSettings _jsonSettings;

        public FileGrainStorage(string storageName, FileGrainStorageOptions options, IOptions&lt;ClusterOptions&gt; clusterOptions, IGrainFactory grainFactory, ITypeResolver typeResolver)
        {
            _storageName = storageName;
            _options = options;
            _clusterOptions = clusterOptions.Value;
            _grainFactory = grainFactory;
            _typeResolver = typeResolver;
        }

        public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
        {
            throw new NotImplementedException();
        }

        public Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
        {
            throw new NotImplementedException();
        }

        public Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
        {
            throw new NotImplementedException();
        }

        public void Participate(ISiloLifecycle lifecycle)
        {
            throw new NotImplementedException();
        }

        public void Participate(ISiloLifecycle lifecycle)
        {
            throw new NotImplementedException();
        }
    }
}
</code></pre><p>在开始实施之前，我们创建一个包含根目录的选项类，Grains状态文件将存储在该目录下。为此，我们将创建一个选项文件<code>FileGrainStorageOptions</code>：</p>
<pre><code class="lang-csharp">public class FileGrainStorageOptions
{
    public string RootDirectory { get; set; }
}
</code></pre><p>创建一个包含两个字段的构造函数，<code>storageName</code>指定使用此存储应该写入哪些纹理<code>[StorageProvider(ProviderName =“文件”)]</code>和<code>目录</code>这将是保存grains状态的目录。</p>
<p><code>IGrain工厂</code>，<code>ITypeResolver</code>将在下一部分中使用，我们将在其中初始化存储。</p>
<p>我们也有两个选择，我们自己<code>FileGrainStorageOptions</code>和<code>集群选项</code>。实现存储功能将需要这些。</p>
<p>我们还需要<code>JsonSerializerSettings</code>因为我们正在以Json格式进行序列化和反序列化。</p>
<p><em>Json是一个实现细节，由开发人员决定哪种串行化/反序列化协议适合该应用程序。另一种常见格式是二进制格式。</em></p>
<h2 id="初始化存储">初始化存储</h2>
<p>要初始化存储，我们注册一个<code>在里面</code>功能上<code>应用服务</code>生命周期。</p>
<pre><code class="lang-csharp">public void Participate(ISiloLifecycle lifecycle)
{
    lifecycle.Subscribe(OptionFormattingUtilities.Name&lt;FileGrainStorage&gt;(_storageName), ServiceLifecycleStage.ApplicationServices, Init);
}
</code></pre><p>的<code>在里面</code>功能用于设置<code>_jsonSettings</code>将用于配置<code>Json</code>序列化器。同时，我们创建文件夹来存储grains状态(如果尚不存在)。</p>
<pre><code class="lang-csharp">private Task Init(CancellationToken ct)
{
    // Settings could be made configurable from Options.
    _jsonSettings = OrleansJsonSerializer.UpdateSerializerSettings(OrleansJsonSerializer.GetDefaultSerializerSettings(_typeResolver, _grainFactory), false, false, null);

    var directory = new System.IO.DirectoryInfo(_rootDirectory);
    if (!directory.Exists)
        directory.Create();

    return Task.CompletedTask;
}
</code></pre><p>我们还提供了一个通用函数来构造文件名，以确保每个服务，GrainID和Grain类型的唯一性。</p>
<pre><code class="lang-csharp">private string GetKeyString(string grainType, GrainReference grainReference)
{
    return $&quot;{_clusterOptions.ServiceId}.{grainReference.ToKeyString()}.{grainType}&quot;;
}
</code></pre><h2 id="阅读状态">阅读状态</h2>
<p>要读取grains状态，我们使用先前定义的函数获取文件名，并将其组合到来自选项的根目录中。</p>
<pre><code class="lang-csharp">public async Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
{
    var fName = GetKeyString(grainType, grainReference);
    var path = Path.Combine(_options.RootDirectory, fName);

    var fileInfo = new FileInfo(path);
    if (!fileInfo.Exists)
    {
        grainState.State = Activator.CreateInstance(grainState.State.GetType());
        return;
    }

    using (var stream = fileInfo.OpenText())
    {
        var storedData = await stream.ReadToEndAsync();
        grainState.State = JsonConvert.DeserializeObject(storedData, _jsonSettings);
    }

    grainState.ETag = fileInfo.LastWriteTimeUtc.ToString();
}
</code></pre><p>我们使用<code>fileInfo.LastWriteTimeUtc</code>作为ETag，其他功能将使用该ETag进行不一致检查以防止数据丢失。</p>
<p>请注意，对于反序列化，我们使用<code>_jsonSettings</code>这是在<code>在里面</code>功能。这对于能够正确地序列化/反序列化状态很重要。</p>
<h2 id="写作状态">写作状态</h2>
<p>写入状态类似于读取状态。</p>
<pre><code class="lang-csharp">public async Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
{
    var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings);

    var fName = GetKeyString(grainType, grainReference);
    var path = Path.Combine(_options.RootDirectory, fName);

    var fileInfo = new FileInfo(path);

    if (fileInfo.Exists &amp;&amp; fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag)
    {
        throw new InconsistentStateException($&quot;Version conflict (WriteState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.&quot;);
    }

    using (var stream = new StreamWriter(fileInfo.Open(FileMode.Create, FileAccess.Write)))
    {
        await stream.WriteAsync(storedData);
    }

    fileInfo.Refresh();
    grainState.ETag = fileInfo.LastWriteTimeUtc.ToString();
}
</code></pre><p>与阅读类似，我们使用<code>_jsonSettings</code>写状态。当前的ETag用于检查文件的UTC中的最后更新时间。如果日期不同，则意味着同一粒Grains的另一次激活会同时更改状态。在这种情况下，我们将<code>InconsistentStateException</code>这将导致当前激活被杀死，以防止覆盖先前由其他激活grains保存的状态。</p>
<h2 id="清算国">清算国</h2>
<p>如果文件存在，则清除状态将删除该文件。</p>
<pre><code class="lang-csharp">public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState)
{
    var fName = GetKeyString(grainType, grainReference);
    var path = Path.Combine(_options.RootDirectory, fName);

    var fileInfo = new FileInfo(path);
    if (fileInfo.Exists)
    {
        if (fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag)
        {
            throw new InconsistentStateException($&quot;Version conflict (ClearState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.&quot;);
        }

        grainState.ETag = null;
        grainState.State = Activator.CreateInstance(grainState.State.GetType());
        fileInfo.Delete();
    }

    return Task.CompletedTask;
}
</code></pre><p>出于同样的原因<code>写状态</code>，我们在继续删除文件并重置ETag之前检查是否存在不一致，并检查当前ETag是否与上次写入时间UTC相同。</p>
<h2 id="把它放在一起">把它放在一起</h2>
<p>之后，我们将创建一个工厂，该工厂将使我们可以将选项设置的范围限定在提供程序名称上，同时创建一个实例。<code>FileGrainStorage</code>简化向服务集合的注册。</p>
<pre><code class="lang-csharp">public static class FileGrainStorageFactory
{
    internal static IGrainStorage Create(IServiceProvider services, string name)
    {
        IOptionsSnapshot&lt;FileGrainStorageOptions&gt; optionsSnapshot = services.GetRequiredService&lt;IOptionsSnapshot&lt;FileGrainStorageOptions&gt;&gt;();
        return ActivatorUtilities.CreateInstance&lt;FileGrainStorage&gt;(services, name, optionsSnapshot.Get(name), services.GetProviderClusterOptions(name));
    }
}
</code></pre><p>最后，要注册Grains储存库，我们在<code>ISiloHostBuilder</code>在内部使用以下方式将Grains存储注册为命名服务<code>.AddSingletonNamedService(...)</code>，由提供的扩展<code>Orleans</code>。</p>
<pre><code class="lang-csharp">public static class FileSiloBuilderExtensions
{
    public static ISiloHostBuilder AddFileGrainStorage(this ISiloHostBuilder builder, string providerName, Action&lt;FileGrainStorageOptions&gt; options)
    {
        return builder.ConfigureServices(services =&gt; services.AddFileGrainStorage(providerName, options));
    }

    public static IServiceCollection AddFileGrainStorage(this IServiceCollection services, string providerName, Action&lt;FileGrainStorageOptions&gt; options)
    {
        services.AddOptions&lt;FileGrainStorageOptions&gt;(providerName).Configure(options);
        return services
            .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create)
            .AddSingletonNamedService(providerName, (s, n) =&gt; (ILifecycleParticipant&lt;ISiloLifecycle&gt;)s.GetRequiredServiceByName&lt;IGrainStorage&gt;(n));
    }
}
</code></pre><p>我们的<code>FileGrainStorage</code>实现两个接口，<code>IGrain存储</code>和<code>ILifecycleParticipant &lt;ISiloLifecycle&gt;</code>因此，我们需要为每个接口注册两个命名服务：</p>
<pre><code class="lang-csharp">return services
    .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create)
    .AddSingletonNamedService(providerName, (s, n) =&gt; (ILifecycleParticipant&lt;ISiloLifecycle&gt;)s.GetRequiredServiceByName&lt;IGrainStorage&gt;(n));
</code></pre><p>这使我们能够使用扩展名添加文件存储。<code>ISiloHostBuilder</code>：</p>
<pre><code class="lang-csharp">var silo = new SiloHostBuilder()
    .UseLocalhostClustering()
    .AddFileGrainStorage(&quot;File&quot;, opts =&gt;
    {
        opts.RootDirectory = &quot;C:/TestFiles&quot;;
    })
    .Build();
</code></pre><p>现在，我们将可以与供应商一起装饰Grains<code>[StorageProvider(ProviderName =“文件”)]</code>它将以谷Grain态存储在选项中设置的根目录中。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sheng-jie/orleans/blob/docs/zh-cn/Tutorials/Custom-Grain-Storage.zh.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
