---
layout: page
title: Immediate vs. Delayed Confirmation
---

# 立即确认

对于许多应用程序，我们希望确保事件立即得到确认，以便持久化的版本不会落后于内存中的当前版本，并且我们不会冒丢失最新状态的风险(如果grain失败)。我们可以通过以下规则来保证：

1.  在Grain方法返回之前，使用`ConfirmEvents`确认所有`RaiseEvent`调用。

2.  在Grain方法返回之前确保由`RaiseConditionalEvent`返回的任务已完成。

3.  避免`[Reentrant]`或`[AlwaysInterleave]`属性，因此一次只能处理一个grain调用。

如果我们遵循这些规则，则意味着在引发事件之后，在将事件写入存储器之前，不能执行其他Grain代码。因此，不可能观察到内存中的版本和存储中的版本之间的不一致。虽然这通常正是我们想要的，但它也有一些潜在的缺点。

### 潜在劣势

-   如果**与远程群集或存储的连接暂时中断**，则grain变得不可用：实际上，grain在等待确认事件时无法执行任何代码，这可能需要无限长的时间(日志一致性协议一直在重试，直到恢复存储连接)。

-   处理时**对单个grain实例的大量更新**，一次确认一个会变得非常低效，即吞吐量很低。

# 延迟确认

为了提高上述情况下的可用性和吞吐量，Grains可以选择执行以下一项或两项操作：

-   允许grain方法在不等待确认的情况下引发事件。

-   允许重入，这样即使以前的调用在等待确认时被阻塞，grain也可以继续处理新的调用。

这意味着当某些事件仍在确认过程中时，可以执行Grain代码。这个`日志记录`api有一些具体规定，让开发人员能够精确控制如何处理当前“正在运行”的未经确认的事件。

可以检查以下属性以了解当前未确认的事件：

```csharp
IEnumerable<EventType> UnconfirmedEvents { get; }
```

而且，由于`State`属性不包括未确认事件的影响，有一个可选属性

```csharp
StateType TentativeState { get; }
```

它返回一个“暂定”状态，通过应用所有未确认的事件从“状态”获得。在所有未经证实的事件被证实后，暂时状态本质上是对下一个确认状态的“最佳猜测”。然而，并不能保证它真的会发生，因为Grains可能会失败，或者因为事件可能与其他事件竞争而失败，导致它们被取消(如果它们是有条件的)或者出现在序列中比预期的更晚的位置(如果它们是无条件的)。

# 并发保证

请注意，即使在使用Reentrant性或延迟确认的情况下，基于orleans turn的调度(协作并发)保证也始终适用。这意味着，即使有几个方法在进行中，也只有一个方法可以主动执行——所有其他的方法都处于等待状态，因此从来没有任何真正的竞争是由并行线程引起的。

尤其要注意：

-   `State`, `TentativeState`, `Version`, 和 `UnconfirmedEvents` 属性可以在方法执行期间更改。

-   但这种变化只能在等待的时候发生。

这些保证假定用户代码保持在[推荐做法](../external_tasks_and_grains.md)关于任务和异步/等待(特别是，不使用线程池任务，或者只将它们用于不调用grain功能且等待正确的代码)。
